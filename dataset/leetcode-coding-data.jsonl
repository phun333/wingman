{"leetcodeId":3,"title":"Longest Substring Without Repeating Characters","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    \n};","python":"def lengthOfLongestSubstring(s: str) -> int:\n    pass","typescript":"/**\n * @param {string} s\n * @return {number}\n */\nfunction lengthOfLongestSubstring(s: string): number {\n\n};"},"testCases":[{"input":"\"abcabcbb\"","expectedOutput":3,"isHidden":false},{"input":"\"bbbbb\"","expectedOutput":1,"isHidden":false},{"input":"\"pwwkew\"","expectedOutput":3,"isHidden":false},{"input":"\"\"","expectedOutput":0,"isHidden":false},{"input":"\"au\"","expectedOutput":2,"isHidden":true},{"input":"\"dvdf\"","expectedOutput":3,"isHidden":true},{"input":"\" \"","expectedOutput":1,"isHidden":true},{"input":"\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}\\|;':\\\",.<>/?`~\"","expectedOutput":95,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let maxLength = 0;\n    let left = 0;\n    const charSet = new Set();\n\n    for (let right = 0; right < s.length; right++) {\n        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }\n        charSet.add(s[right]);\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n};"}}}
{"leetcodeId":1,"title":"Two Sum","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};","python":"from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nfunction twoSum(nums: number[], target: number): number[] {\n\n};"},"testCases":[{"input":"[2,7,11,15]\n9","expectedOutput":"[0,1]","isHidden":false},{"input":"[3,2,4]\n6","expectedOutput":"[1,2]","isHidden":false},{"input":"[3,3]\n6","expectedOutput":"[0,1]","isHidden":false},{"input":"[0,4,3,0]\n0","expectedOutput":"[0,3]","isHidden":true},{"input":"[-1,-2,-3,-4,-5]\n-8","expectedOutput":"[2,4]","isHidden":true},{"input":"[1,1]\n2","expectedOutput":"[0,1]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const numMap = new Map();\n\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (numMap.has(complement)) {\n            return [numMap.get(complement), i];\n        }\n        numMap.set(nums[i], i);\n    }\n    // As per problem statement, exactly one solution exists, \n    // so this line should theoretically not be reached.\n    return []; \n};"}}}
{"leetcodeId":5,"title":"Longest Palindromic Substring","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    \n};","python":"def longestPalindrome(s: str) -> str:\n    pass","typescript":"function longestPalindrome(s: string): string {\n\n};"},"testCases":[{"input":"\"babad\"","expectedOutput":"\"bab\"","isHidden":false},{"input":"\"cbbd\"","expectedOutput":"\"bb\"","isHidden":false},{"input":"\"a\"","expectedOutput":"\"a\"","isHidden":false},{"input":"\"ac\"","expectedOutput":"\"a\"","isHidden":false},{"input":"\"racecar\"","expectedOutput":"\"racecar\"","isHidden":true},{"input":"\"abcdefg\"","expectedOutput":"\"a\"","isHidden":true},{"input":"\"aaaaa\"","expectedOutput":"\"aaaaa\"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    if (s.length < 1) return \"\";\n\n    let start = 0;\n    let end = 0;\n\n    function expandAroundCenter(left, right) {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        let len1 = expandAroundCenter(i, i); // Odd length palindrome\n        let len2 = expandAroundCenter(i, i + 1); // Even length palindrome\n        let len = Math.max(len1, len2);\n\n        if (len > end - start) {\n            start = i - Math.floor((len - 1) / 2);\n            end = i + Math.floor(len / 2);\n        }\n    }\n\n    return s.substring(start, end + 1);\n};"}}}
{"leetcodeId":4,"title":"Median of Two Sorted Arrays","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    \n};","python":"class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n        pass","typescript":"function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n\n};"},"testCases":[{"input":"[1,3]\n[2]","expectedOutput":2,"isHidden":false},{"input":"[1,2]\n[3,4]","expectedOutput":2.5,"isHidden":false},{"input":"[0,0]\n[0,0]","expectedOutput":0,"isHidden":false},{"input":"[]\n[1]","expectedOutput":1,"isHidden":false},{"input":"[2]\n[]","expectedOutput":2,"isHidden":false},{"input":"[1,2,3,4,5]\n[6,7,8,9,10]","expectedOutput":5.5,"isHidden":true},{"input":"[100]\n[1,2,3,4,5,6,7,8,9,10]","expectedOutput":6,"isHidden":true},{"input":"[1,2,3,4,5,6,7,8,9,10]\n[100]","expectedOutput":6,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    const m = nums1.length;\n    const n = nums2.length;\n    const totalLength = m + n;\n\n    // Ensure nums1 is the shorter array for simpler logic\n    if (m > n) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n\n    let low = 0;\n    let high = m;\n\n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((totalLength + 1) / 2) - partitionX;\n\n        const maxX = (partitionX === 0) ? -Infinity : nums1[partitionX - 1];\n        const minX = (partitionX === m) ? Infinity : nums1[partitionX];\n\n        const maxY = (partitionY === 0) ? -Infinity : nums2[partitionY - 1];\n        const minY = (partitionY === n) ? Infinity : nums2[partitionY];\n\n        if (maxX <= minY && maxY <= minX) {\n            // We found the correct partition\n            if (totalLength % 2 === 0) {\n                // Even number of elements\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n            } else {\n                // Odd number of elements\n                return Math.max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            // We are too far right in nums1, need to move left\n            high = partitionX - 1;\n        } else {\n            // We are too far left in nums1, need to move right\n            low = partitionX + 1;\n        }\n    }\n    // Should not reach here if inputs are valid sorted arrays\n    throw new Error(\"Input arrays are not sorted or invalid.\");\n};"}}}
{"leetcodeId":2,"title":"Add Two Numbers","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nfunction addTwoNumbers(l1, l2) {\n    // Implement your solution here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        # Implement your solution here\n        pass","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    // Implement your solution here\n}"},"testCases":[{"input":"{\"val\":2,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":null}}}\n{\"val\":5,\"next\":{\"val\":6,\"next\":{\"val\":4,\"next\":null}}}","expectedOutput":"{\"val\":7,\"next\":{\"val\":0,\"next\":{\"val\":8,\"next\":null}}}","isHidden":false},{"input":"{\"val\":0,\"next\":null}\n{\"val\":0,\"next\":null}","expectedOutput":"{\"val\":0,\"next\":null}","isHidden":false},{"input":"{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":null}}}}}}}\n{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":null}}}}","expectedOutput":"{\"val\":8,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":9,\"next\":{\"val\":0,\"next\":{\"val\":0,\"next\":{\"val\":0,\"next\":{\"val\":1,\"next\":null}}}}}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":null}\n{\"val\":9,\"next\":{\"val\":9,\"next\":null}}","expectedOutput":"{\"val\":0,\"next\":{\"val\":0,\"next\":{\"val\":1,\"next\":null}}}","isHidden":true},{"input":"{\"val\":5,\"next\":null}\n{\"val\":5,\"next\":null}","expectedOutput":"{\"val\":0,\"next\":{\"val\":1,\"next\":null}}","isHidden":true},{"input":"{\"val\":9,\"next\":null}\n{\"val\":1,\"next\":null}","expectedOutput":"{\"val\":0,\"next\":{\"val\":1,\"next\":null}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nfunction addTwoNumbers(l1, l2) {\n    let dummyHead = new ListNode(0);\n    let current = dummyHead;\n    let carry = 0;\n\n    while (l1 !== null || l2 !== null || carry !== 0) {\n        let val1 = l1 ? l1.val : 0;\n        let val2 = l2 ? l2.val : 0;\n\n        let sum = val1 + val2 + carry;\n        carry = Math.floor(sum / 10);\n        let digit = sum % 10;\n\n        current.next = new ListNode(digit);\n        current = current.next;\n\n        if (l1) {\n            l1 = l1.next;\n        }\n        if (l2) {\n            l2 = l2.next;\n        }\n    }\n\n    return dummyHead.next;\n}"}}}
{"leetcodeId":12,"title":"Integer to Roman","codingData":{"starterCode":{"javascript":"/**\n * @param {number} num\n * @return {string}\n */\nvar intToRoman = function(num) {\n    \n};\n","python":"class Solution:\n    def intToRoman(self, num: int) -> str:\n        pass\n","typescript":"/**\n * @param {number} num\n * @return {string}\n */\nfunction intToRoman(num: number): string {\n\n};\n"},"testCases":[{"input":"3","expectedOutput":"\"III\"","isHidden":false},{"input":"4","expectedOutput":"\"IV\"","isHidden":false},{"input":"9","expectedOutput":"\"IX\"","isHidden":false},{"input":"58","expectedOutput":"\"LVIII\"","isHidden":false},{"input":"1994","expectedOutput":"\"MCMXCIV\"","isHidden":false},{"input":"1","expectedOutput":"\"I\"","isHidden":true},{"input":"3999","expectedOutput":"\"MMMCMXCIX\"","isHidden":true},{"input":"100","expectedOutput":"\"C\"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} num\n * @return {string}\n */\nvar intToRoman = function(num) {\n    const values = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ];\n    const symbols = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ];\n\n    let romanNumeral = \"\";\n\n    for (let i = 0; i < values.length; i++) {\n        while (num >= values[i]) {\n            romanNumeral += symbols[i];\n            num -= values[i];\n        }\n    }\n\n    return romanNumeral;\n};\n"}}}
{"leetcodeId":11,"title":"Container With Most Water","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n\n};","python":"def max_area(height: list[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} height\n * @return {number}\n */\nfunction maxArea(height: number[]): number {\n\n};"},"testCases":[{"input":"[1,8,6,2,5,4,8,3,7]","expectedOutput":49,"isHidden":false},{"input":"[1,1]","expectedOutput":1,"isHidden":false},{"input":"[4,3,2,1,4]","expectedOutput":16,"isHidden":false},{"input":"[1,2,1]","expectedOutput":2,"isHidden":false},{"input":"[2,3,4,5,18,17,6]","expectedOutput":17,"isHidden":true},{"input":"[0,0,0,0,0]","expectedOutput":0,"isHidden":true},{"input":"[10,9,8,7,6,5,4,3,2,1]","expectedOutput":25,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n    let maxWater = 0;\n    let left = 0;\n    let right = height.length - 1;\n\n    while (left < right) {\n        const h = Math.min(height[left], height[right]);\n        const w = right - left;\n        maxWater = Math.max(maxWater, h * w);\n\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return maxWater;\n};"}}}
{"leetcodeId":6,"title":"ZigZag Conversion","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nvar convert = function(s, numRows) {\n\n};","python":"class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        pass","typescript":"function convert(s: string, numRows: number): string {\n\n};"},"testCases":[{"input":"\"PAYPALISHIRING\"\n3","expectedOutput":"PAHNAPLSIIGYIR","isHidden":false},{"input":"\"PAYPALISHIRING\"\n4","expectedOutput":"PINALSIGYAHRPI","isHidden":false},{"input":"\"A\"\n1","expectedOutput":"A","isHidden":false},{"input":"\"ABCDE\"\n2","expectedOutput":"ACEBD","isHidden":true},{"input":"\"ABCDEFGH\"\n5","expectedOutput":"AGBHCEDF","isHidden":true},{"input":"\"AB\"\n1","expectedOutput":"AB","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nvar convert = function(s, numRows) {\n    if (numRows === 1 || s.length <= numRows) {\n        return s;\n    }\n\n    const rows = new Array(numRows).fill('');\n    let currentRow = 0;\n    let goingDown = false;\n\n    for (let i = 0; i < s.length; i++) {\n        rows[currentRow] += s[i];\n\n        if (currentRow === 0 || currentRow === numRows - 1) {\n            goingDown = !goingDown;\n        }\n\n        if (goingDown) {\n            currentRow++;\n        } else {\n            currentRow--;\n        }\n    }\n\n    return rows.join('');\n};"}}}
{"leetcodeId":13,"title":"Roman to Integer","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    \n};","python":"class Solution:\n    def romanToInt(self, s: str) -> int:\n        ","typescript":"/**\n * @param {string} s\n * @return {number}\n */\nfunction romanToInt(s: string): number {\n\n};"},"testCases":[{"input":"\"III\"","expectedOutput":3,"isHidden":false},{"input":"\"IV\"","expectedOutput":4,"isHidden":false},{"input":"\"IX\"","expectedOutput":9,"isHidden":false},{"input":"\"LVIII\"","expectedOutput":58,"isHidden":false},{"input":"\"MCMXCIV\"","expectedOutput":1994,"isHidden":false},{"input":"\"MMMCMXCIX\"","expectedOutput":3999,"isHidden":true},{"input":"\"I\"","expectedOutput":1,"isHidden":true},{"input":"\"CDXLIV\"","expectedOutput":444,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    const romanMap = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    };\n\n    let total = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        const currentVal = romanMap[s[i]];\n        const nextVal = romanMap[s[i + 1]];\n\n        if (nextVal > currentVal) {\n            total += (nextVal - currentVal);\n            i++; // Skip the next character as it's already processed\n        } else {\n            total += currentVal;\n        }\n    }\n\n    return total;\n};"}}}
{"leetcodeId":9,"title":"Palindrome Number","codingData":{"starterCode":{"javascript":"/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    \n};","python":"class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        ","typescript":"function isPalindrome(x: number): boolean {\n\n};"},"testCases":[{"input":"121","expectedOutput":true,"isHidden":false},{"input":"-121","expectedOutput":false,"isHidden":false},{"input":"10","expectedOutput":false,"isHidden":false},{"input":"-101","expectedOutput":false,"isHidden":false},{"input":"0","expectedOutput":true,"isHidden":true},{"input":"12321","expectedOutput":true,"isHidden":true},{"input":"12345","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    if (x < 0 || (x % 10 === 0 && x !== 0)) {\n        return false;\n    }\n\n    let revertedNumber = 0;\n    while (x > revertedNumber) {\n        revertedNumber = revertedNumber * 10 + (x % 10);\n        x = Math.floor(x / 10);\n    }\n\n    // When the length is an odd number, we can get rid of the middle digit by revertedNumber/10\n    // For example when the input is 12321, at the end of the while loop we get x = 12, revertedNumber = 123,\n    // since the middle digit doesn't matter in a palindrome (it will always equal to itself),\n    // we can simply remove it.\n    return x === revertedNumber || x === Math.floor(revertedNumber / 10);\n};"}}}
{"leetcodeId":14,"title":"Longest Common Prefix","codingData":{"starterCode":{"javascript":"/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function(strs) {\n    \n};","python":"def longest_common_prefix(strs: list[str]) -> str:\n    pass","typescript":"/**\n * @param {string[]} strs\n * @return {string}\n */\nfunction longestCommonPrefix(strs: string[]): string {\n\n};"},"testCases":[{"input":"[\"flower\",\"flow\",\"flight\"]","expectedOutput":"\"fl\"","isHidden":false},{"input":"[\"dog\",\"racecar\",\"car\"]","expectedOutput":"\"\"","isHidden":false},{"input":"[\"apple\",\"apricot\",\"april\"]","expectedOutput":"\"ap\"","isHidden":true},{"input":"[\"a\"]","expectedOutput":"\"a\"","isHidden":true},{"input":"[\"\"]","expectedOutput":"\"\"","isHidden":true},{"input":"[]","expectedOutput":"\"\"","isHidden":true},{"input":"[\"ab\",\"a\"]","expectedOutput":"\"a\"","isHidden":true},{"input":"[\"cir\",\"car\"]","expectedOutput":"\"c\"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function(strs) {\n    if (!strs || strs.length === 0) {\n        return \"\";\n    }\n\n    let prefix = strs[0];\n\n    for (let i = 1; i < strs.length; i++) {\n        while (strs[i].indexOf(prefix) !== 0) {\n            prefix = prefix.substring(0, prefix.length - 1);\n            if (prefix.length === 0) {\n                return \"\";\n            }\n        }\n    }\n\n    return prefix;\n};"}}}
{"leetcodeId":15,"title":"3Sum","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    \n};\n","python":"from typing import List\n\ndef three_sum(nums: List[int]) -> List[List[int]]:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nfunction threeSum(nums: number[]): number[][] {\n\n};\n"},"testCases":[{"input":"[-1,0,1,2,-1,-4]","expectedOutput":"[[-1,-1,2],[-1,0,1]]","isHidden":false},{"input":"[]","expectedOutput":"[]","isHidden":false},{"input":"[0]","expectedOutput":"[]","isHidden":false},{"input":"[0,0,0]","expectedOutput":"[[0,0,0]]","isHidden":true},{"input":"[1,2,-2,-1]","expectedOutput":"[]","isHidden":true},{"input":"[-2,0,1,1,2]","expectedOutput":"[[-2,0,2],[-2,1,1]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    const n = nums.length;\n\n    for (let i = 0; i < n - 2; i++) {\n        // Skip duplicate for the first element\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n\n        let left = i + 1;\n        let right = n - 1;\n\n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n\n            if (sum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n\n                // Skip duplicates for the second element\n                while (left < right && nums[left] === nums[left + 1]) {\n                    left++;\n                }\n                // Skip duplicates for the third element\n                while (left < right && nums[right] === nums[right - 1]) {\n                    right--;\n                }\n\n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    return result;\n};\n"}}}
{"leetcodeId":7,"title":"Reverse Integer","codingData":{"starterCode":{"javascript":"/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n\n};\n","python":"def reverse(x: int) -> int:\n    pass\n","typescript":"/**\n * @param {number} x\n * @return {number}\n */\nfunction reverse(x: number): number {\n\n};\n"},"testCases":[{"input":"123","expectedOutput":321,"isHidden":false},{"input":"-123","expectedOutput":-321,"isHidden":false},{"input":"120","expectedOutput":21,"isHidden":false},{"input":"0","expectedOutput":0,"isHidden":false},{"input":"1534236469","expectedOutput":0,"isHidden":true},{"input":"-2147483648","expectedOutput":0,"isHidden":true},{"input":"2147483647","expectedOutput":0,"isHidden":true},{"input":"1","expectedOutput":1,"isHidden":true},{"input":"-1","expectedOutput":-1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n    const sign = x < 0 ? -1 : 1;\n    let num = Math.abs(x);\n    let reversedNum = 0;\n\n    const MAX_INT = 2147483647;\n    const MIN_INT = -2147483648;\n\n    while (num > 0) {\n        const digit = num % 10;\n        \n        // Check for overflow before adding the new digit\n        // If reversedNum > MAX_INT / 10, then reversedNum * 10 + digit will overflow\n        // If reversedNum == MAX_INT / 10, then reversedNum * 10 + digit will overflow if digit > 7 (for positive) or digit > 8 (for negative)\n        // For positive numbers, MAX_INT is 2147483647. MAX_INT / 10 is 214748364.7. The last digit is 7.\n        // For negative numbers, MIN_INT is -2147483648. MIN_INT / 10 is -214748364.8. The last digit is 8.\n        \n        if (reversedNum > Math.floor(MAX_INT / 10) || (reversedNum === Math.floor(MAX_INT / 10) && digit > 7)) {\n            return 0;\n        }\n\n        reversedNum = reversedNum * 10 + digit;\n        num = Math.floor(num / 10);\n    }\n\n    const finalResult = reversedNum * sign;\n\n    if (finalResult > MAX_INT || finalResult < MIN_INT) {\n        return 0;\n    }\n\n    return finalResult;\n};\n"}}}
{"leetcodeId":10,"title":"Regular Expression Matching","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    \n};","python":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ","typescript":"function isMatch(s: string, p: string): boolean {\n\n};"},"testCases":[{"input":"\"aa\"\n\"a\"","expectedOutput":false,"isHidden":false},{"input":"\"aa\"\n\"a*\"","expectedOutput":true,"isHidden":false},{"input":"\"ab\"\n\".*\"","expectedOutput":true,"isHidden":false},{"input":"\"aab\"\n\"c*a*b\"","expectedOutput":true,"isHidden":false},{"input":"\"mississippi\"\n\"mis*is*p*.\"","expectedOutput":false,"isHidden":false},{"input":"\"\"\n\"a*\"","expectedOutput":true,"isHidden":true},{"input":"\"\"\n\".*\"","expectedOutput":true,"isHidden":true},{"input":"\"a\"\n\"ab*\"","expectedOutput":true,"isHidden":true},{"input":"\"aaa\"\n\"a*a\"","expectedOutput":true,"isHidden":true},{"input":"\"ab\"\n\".*c\"","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    const dp = Array(s.length + 1).fill(false).map(() => Array(p.length + 1).fill(false));\n\n    // Base case: empty string matches empty pattern\n    dp[s.length][p.length] = true;\n\n    // Fill the DP table from bottom-up\n    for (let i = s.length; i >= 0; i--) {\n        for (let j = p.length - 1; j >= 0; j--) {\n            // Check if the current characters match (or if pattern has '.')\n            const firstMatch = (i < s.length && (p[j] === s[i] || p[j] === '.'));\n\n            // If the next character in pattern is '*'\n            if (j + 1 < p.length && p[j + 1] === '*') {\n                // Option 1: '*' matches zero occurrences of the preceding element\n                // So, we skip p[j] and p[j+1]\n                // Option 2: '*' matches one or more occurrences of the preceding element\n                // So, s[i] matches p[j], and we check if the rest of s matches the same pattern p[j]*\n                dp[i][j] = dp[i][j + 2] || (firstMatch && dp[i + 1][j]);\n            } else {\n                // If no '*' or '*' is not the next character\n                // Current characters must match, and the rest of s and p must match\n                dp[i][j] = firstMatch && dp[i][j + 1];\n            }\n        }\n    }\n\n    return dp[0][0];\n};"}}}
{"leetcodeId":8,"title":"String to Integer (atoi)","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar myAtoi = function(s) {\n    \n};\n","python":"class Solution:\n    def myAtoi(self, s: str) -> int:\n        \n","typescript":"/**\n * @param {string} s\n * @return {number}\n */\nfunction myAtoi(s: string): number {\n\n};\n"},"testCases":[{"input":"\"42\"","expectedOutput":42,"isHidden":false},{"input":"\"   -42\"","expectedOutput":-42,"isHidden":false},{"input":"\"4193 with words\"","expectedOutput":4193,"isHidden":false},{"input":"\"words and 987\"","expectedOutput":0,"isHidden":false},{"input":"\"-91283472332\"","expectedOutput":-2147483648,"isHidden":false},{"input":"\"+\"","expectedOutput":0,"isHidden":true},{"input":"\"   +0 123\"","expectedOutput":0,"isHidden":true},{"input":"\"2147483647\"","expectedOutput":2147483647,"isHidden":true},{"input":"\"2147483648\"","expectedOutput":2147483647,"isHidden":true},{"input":"\"-2147483648\"","expectedOutput":-2147483648,"isHidden":true},{"input":"\"-2147483649\"","expectedOutput":-2147483648,"isHidden":true},{"input":"\"  -0012a42\"","expectedOutput":-12,"isHidden":true},{"input":"\"   - 321\"","expectedOutput":0,"isHidden":true},{"input":"\"\"","expectedOutput":0,"isHidden":true},{"input":"\"0\"","expectedOutput":0,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar myAtoi = function(s) {\n    let i = 0;\n    let sign = 1;\n    let result = 0;\n    const MAX_INT = 2147483647; // 2^31 - 1\n    const MIN_INT = -2147483648; // -2^31\n\n    // 1. Read in and ignore any leading whitespace.\n    while (i < s.length && s[i] === ' ') {\n        i++;\n    }\n\n    // 2. Check if the next character is '-' or '+'.\n    if (i < s.length && (s[i] === '-' || s[i] === '+')) {\n        sign = (s[i] === '-') ? -1 : 1;\n        i++;\n    }\n\n    // 3. Read in next the characters until the next non-digit character or the end of the input is reached.\n    while (i < s.length && s[i] >= '0' && s[i] <= '9') {\n        const digit = parseInt(s[i]);\n\n        // Check for overflow before adding the digit\n        if (sign === 1) {\n            if (result > Math.floor(MAX_INT / 10) || (result === Math.floor(MAX_INT / 10) && digit > 7)) {\n                return MAX_INT;\n            }\n        } else { // sign === -1\n            if (result < Math.ceil(MIN_INT / 10) || (result === Math.ceil(MIN_INT / 10) && digit > 8)) {\n                return MIN_INT;\n            }\n        }\n\n        result = result * 10 + digit;\n        i++;\n    }\n\n    // 4. Apply the sign and clamp the result.\n    result = result * sign;\n\n    if (result > MAX_INT) {\n        return MAX_INT;\n    }\n    if (result < MIN_INT) {\n        return MIN_INT;\n    }\n\n    return result;\n};\n"}}}
{"leetcodeId":16,"title":"3Sum Closest","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function(nums, target) {\n    \n};\n","python":"def threeSumClosest(nums: list[int], target: int) -> int:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nfunction threeSumClosest(nums: number[], target: number): number {\n\n};\n"},"testCases":[{"input":"[-1,2,1,-4]\n1","expectedOutput":2,"isHidden":false},{"input":"[0,0,0]\n1","expectedOutput":0,"isHidden":true},{"input":"[1,1,1,0]\n-100","expectedOutput":2,"isHidden":true},{"input":"[1,2,3,4,5]\n10","expectedOutput":10,"isHidden":true},{"input":"[1,2,3,4,5]\n-1","expectedOutput":6,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closestSum = Infinity;\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        let left = i + 1;\n        let right = nums.length - 1;\n\n        while (left < right) {\n            let currentSum = nums[i] + nums[left] + nums[right];\n\n            if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n                closestSum = currentSum;\n            }\n\n            if (currentSum < target) {\n                left++;\n            } else if (currentSum > target) {\n                right--;\n            } else {\n                // Found exact target sum, which is the closest possible\n                return currentSum;\n            }\n        }\n    }\n\n    return closestSum;\n};\n"}}}
{"leetcodeId":17,"title":"Letter Combinations of a Phone Number","codingData":{"starterCode":{"javascript":"/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function(digits) {\n    \n};\n","python":"def letter_combinations(digits: str) -> list[str]:\n    pass\n","typescript":"/**\n * @param {string} digits\n * @return {string[]}\n */\nfunction letterCombinations(digits: string): string[] {\n\n};\n"},"testCases":[{"input":"\"23\"","expectedOutput":"[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]","isHidden":false},{"input":"\"\"","expectedOutput":"[]","isHidden":false},{"input":"\"2\"","expectedOutput":"[\"a\",\"b\",\"c\"]","isHidden":false},{"input":"\"7\"","expectedOutput":"[\"p\",\"q\",\"r\",\"s\"]","isHidden":true},{"input":"\"9\"","expectedOutput":"[\"w\",\"x\",\"y\",\"z\"]","isHidden":true},{"input":"\"29\"","expectedOutput":"[\"aw\",\"ax\",\"ay\",\"az\",\"bw\",\"bx\",\"by\",\"bz\",\"cw\",\"cx\",\"cy\",\"cz\"]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function(digits) {\n    if (!digits) {\n        return [];\n    }\n\n    const mapping = {\n        '2': 'abc',\n        '3': 'def',\n        '4': 'ghi',\n        '5': 'jkl',\n        '6': 'mno',\n        '7': 'pqrs',\n        '8': 'tuv',\n        '9': 'wxyz'\n    };\n\n    const result = [];\n\n    function backtrack(index, currentCombination) {\n        if (index === digits.length) {\n            result.push(currentCombination);\n            return;\n        }\n\n        const digit = digits[index];\n        const letters = mapping[digit];\n\n        for (let i = 0; i < letters.length; i++) {\n            backtrack(index + 1, currentCombination + letters[i]);\n        }\n    }\n\n    backtrack(0, '');\n    return result;\n};\n"}}}
{"leetcodeId":20,"title":"Valid Parentheses","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};\n","python":"class Solution:\n    def isValid(self, s: str) -> bool:\n        \n","typescript":"/**\n * @param {string} s\n * @return {boolean}\n */\nfunction isValid(s: string): boolean {\n\n};\n"},"testCases":[{"input":"\"()\"","expectedOutput":true,"isHidden":false},{"input":"\"()[]{}\"","expectedOutput":true,"isHidden":false},{"input":"\"(]\"","expectedOutput":false,"isHidden":false},{"input":"\"([)]\"","expectedOutput":false,"isHidden":false},{"input":"\"{[]}\"","expectedOutput":true,"isHidden":false},{"input":"\"\"","expectedOutput":true,"isHidden":true},{"input":"\"[\"","expectedOutput":false,"isHidden":true},{"input":"\"]\"","expectedOutput":false,"isHidden":true},{"input":"\"(((\"","expectedOutput":false,"isHidden":true},{"input":"\")))\"","expectedOutput":false,"isHidden":true},{"input":"\"{[()]}\"","expectedOutput":true,"isHidden":true},{"input":"\"({[({})]})\"","expectedOutput":true,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    const stack = [];\n    const map = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\"\n    };\n\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n\n        if (map[char]) { // It's an opening bracket\n            stack.push(char);\n        } else { // It's a closing bracket\n            if (stack.length === 0) {\n                return false; // No opening bracket to match\n            }\n            const lastOpen = stack.pop();\n            if (map[lastOpen] !== char) {\n                return false; // Mismatched closing bracket\n            }\n        }\n    }\n\n    return stack.length === 0; // All opening brackets must be closed\n};\n"}}}
{"leetcodeId":22,"title":"Generate Parentheses","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function(n) {\n    \n};","python":"def generateParenthesis(n: int) -> list[str]:\n    pass","typescript":"/**\n * @param {number} n\n * @return {string[]}\n */\nfunction generateParenthesis(n: number): string[] {\n\n};"},"testCases":[{"input":"3","expectedOutput":"[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]","isHidden":false},{"input":"1","expectedOutput":"[\"()\"]","isHidden":false},{"input":"2","expectedOutput":"[\"(())\",\"()()\"]","isHidden":true},{"input":"0","expectedOutput":"[]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function(n) {\n    const result = [];\n\n    /**\n     * @param {string} currentString\n     * @param {number} openCount\n     * @param {number} closeCount\n     */\n    function backtrack(currentString, openCount, closeCount) {\n        // Base case: if the current string has reached the maximum length (2 * n)\n        if (currentString.length === 2 * n) {\n            result.push(currentString);\n            return;\n        }\n\n        // Recursive step 1: Add an opening parenthesis if we haven't used all n open parentheses yet\n        if (openCount < n) {\n            backtrack(currentString + '(', openCount + 1, closeCount);\n        }\n\n        // Recursive step 2: Add a closing parenthesis if it forms a valid pair\n        // (i.e., the number of closing parentheses is less than the number of opening parentheses)\n        if (closeCount < openCount) {\n            backtrack(currentString + ')', openCount, closeCount + 1);\n        }\n    }\n\n    // Start the backtracking process with an empty string and zero counts\n    backtrack('', 0, 0);\n    return result;\n};"}}}
{"leetcodeId":18,"title":"4Sum","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function(nums, target) {\n    \n};\n","python":"def fourSum(nums: list[int], target: int) -> list[list[int]]:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nfunction fourSum(nums: number[], target: number): number[][] {\n\n};\n"},"testCases":[{"input":"[1,0,-1,0,-2,2]\n0","expectedOutput":"[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]","isHidden":false},{"input":"[]\n0","expectedOutput":"[]","isHidden":false},{"input":"[2,2,2,2,2]\n8","expectedOutput":"[[2,2,2,2]]","isHidden":true},{"input":"[0,0,0,0]\n0","expectedOutput":"[[0,0,0,0]]","isHidden":true},{"input":"[1,2,3,4,5,6]\n100","expectedOutput":"[]","isHidden":true},{"input":"[-3,-2,-1,0,0,1,2,3]\n0","expectedOutput":"[[-3,-2,2,3],[-3,-1,1,3],[-3,0,0,3],[-3,0,1,2],[-2,-1,0,3],[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function(nums, target) {\n    const result = [];\n    if (nums.length < 4) {\n        return result;\n    }\n\n    nums.sort((a, b) => a - b);\n\n    const n = nums.length;\n\n    for (let i = 0; i < n - 3; i++) {\n        // Skip duplicate for i\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n\n        for (let j = i + 1; j < n - 2; j++) {\n            // Skip duplicate for j\n            if (j > i + 1 && nums[j] === nums[j - 1]) {\n                continue;\n            }\n\n            let left = j + 1;\n            let right = n - 1;\n\n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n\n                if (sum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n\n                    // Skip duplicates for left\n                    while (left < right && nums[left] === nums[left + 1]) {\n                        left++;\n                    }\n                    // Skip duplicates for right\n                    while (left < right && nums[right] === nums[right - 1]) {\n                        right--;\n                    }\n\n                    left++;\n                    right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n\n    return result;\n};\n"}}}
{"leetcodeId":19,"title":"Remove Nth Node From End of List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param head: ListNode\n * @param n: number\n * @return ListNode\n */\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n\n};"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}\n2","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":5,\"next\":null}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":null}\n1","expectedOutput":"null","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}\n1","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}\n2","expectedOutput":"{\"val\":2,\"next\":null}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}\n3","expectedOutput":"{\"val\":2,\"next\":{\"val\":3,\"next\":null}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let first = dummy;\n    let second = dummy;\n\n    // Advance first pointer so that the gap between first and second is n nodes apart\n    for (let i = 0; i <= n; i++) {\n        first = first.next;\n    }\n\n    // Move first to the end, maintaining the gap\n    while (first !== null) {\n        first = first.next;\n        second = second.next;\n    }\n\n    // second is now at the node just before the one to be removed\n    second.next = second.next.next;\n\n    return dummy.next;\n};"}}}
{"leetcodeId":24,"title":"Swap Nodes in Pairs","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction swapPairs(head) {\n  // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode | null} head\n * @return {ListNode | null}\n */\nfunction swapPairs(head: ListNode | null): ListNode | null {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":null}}}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":false},{"input":"{\"val\":1,\"next\":null}","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":3,\"next\":null}}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction swapPairs(head) {\n  // Base case: if head is null or only one node, no swap needed\n  if (!head || !head.next) {\n    return head;\n  }\n\n  // Nodes to be swapped\n  let firstNode = head;\n  let secondNode = head.next;\n\n  // Swap\n  firstNode.next = swapPairs(secondNode.next);\n  secondNode.next = firstNode;\n\n  // Return the new head of the swapped pair\n  return secondNode;\n}"}}}
{"leetcodeId":21,"title":"Merge Two Sorted Lists","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nfunction mergeTwoLists(l1, l2) {\n  // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    // Your code here\n};"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":4,\"next\":null}}}\n{\"val\":1,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":4,\"next\":null}}}}}","isHidden":false},{"input":"null\nnull","expectedOutput":"null","isHidden":false},{"input":"null\n{\"val\":0,\"next\":null}","expectedOutput":"{\"val\":0,\"next\":null}","isHidden":false},{"input":"{\"val\":-9,\"next\":{\"val\":3,\"next\":null}}\n{\"val\":5,\"next\":{\"val\":7,\"next\":null}}","expectedOutput":"{\"val\":-9,\"next\":{\"val\":3,\"next\":{\"val\":5,\"next\":{\"val\":7,\"next\":null}}}}","isHidden":true},{"input":"{\"val\":1,\"next\":null}\n{\"val\":2,\"next\":null}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","isHidden":true},{"input":"{\"val\":-100,\"next\":null}\n{\"val\":100,\"next\":null}","expectedOutput":"{\"val\":-100,\"next\":{\"val\":100,\"next\":null}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nfunction mergeTwoLists(l1, l2) {\n  if (!l1) return l2;\n  if (!l2) return l1;\n\n  let head;\n  if (l1.val <= l2.val) {\n    head = l1;\n    l1 = l1.next;\n  } else {\n    head = l2;\n    l2 = l2.next;\n  }\n\n  let current = head;\n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      current.next = l1;\n      l1 = l1.next;\n    } else {\n      current.next = l2;\n      l2 = l2.next;\n    }\n    current = current.next;\n  }\n\n  if (l1) {\n    current.next = l1;\n  } else if (l2) {\n    current.next = l2;\n  }\n\n  return head;\n}"}}}
{"leetcodeId":23,"title":"Merge k Sorted Lists","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: list[ListNode]) -> ListNode:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n\n};"},"testCases":[{"input":"[[{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}},{\"val\":1,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}},{\"val\":2,\"next\":{\"val\":6,\"next\":null}}]]","expectedOutput":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":{\"val\":6,\"next\":null}}}}}}}}","isHidden":false},{"input":"[]","expectedOutput":"null","isHidden":false},{"input":"[[]]","expectedOutput":"null","isHidden":false},{"input":"[[{\"val\":1,\"next\":null}]]","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true},{"input":"[[{\"val\":-10,\"next\":null}], [{\"val\":-5,\"next\":null}], [{\"val\":0,\"next\":null}], [{\"val\":5,\"next\":null}], [{\"val\":10,\"next\":null}]]","expectedOutput":"{\"val\":-10,\"next\":{\"val\":-5,\"next\":{\"val\":0,\"next\":{\"val\":5,\"next\":{\"val\":10,\"next\":null}}}}}","isHidden":true},{"input":"[[{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}], [{\"val\":4,\"next\":{\"val\":5,\"next\":{\"val\":6,\"next\":null}}}]]","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":{\"val\":6,\"next\":null}}}}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n// Helper function to merge two sorted linked lists\nfunction mergeTwoLists(l1, l2) {\n    if (!l1) return l2;\n    if (!l2) return l1;\n\n    let head;\n    if (l1.val <= l2.val) {\n        head = l1;\n        l1 = l1.next;\n    } else {\n        head = l2;\n        l2 = l2.next;\n    }\n\n    let current = head;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n\n    if (l1) {\n        current.next = l1;\n    } else if (l2) {\n        current.next = l2;\n    }\n\n    return head;\n}\n\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    if (!lists || lists.length === 0) {\n        return null;\n    }\n\n    // Divide and Conquer approach\n    // Merge lists in pairs until only one list remains\n    let interval = 1;\n    while (interval < lists.length) {\n        for (let i = 0; i + interval < lists.length; i += interval * 2) {\n            lists[i] = mergeTwoLists(lists[i], lists[i + interval]);\n        }\n        interval *= 2;\n    }\n\n    return lists[0];\n};"}}}
{"leetcodeId":25,"title":"Reverse Nodes in k-Group","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function(head, k) {\n    \n};\n","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n\n};\n"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}\n2","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}\n3","expectedOutput":"{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}\n1","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":null}\n1","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}\n2","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":null}}}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}\n5","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}","isHidden":true},{"input":"null\n1","expectedOutput":"null","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function(head, k) {\n    if (!head || k === 1) {\n        return head;\n    }\n\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let prevGroupEnd = dummy;\n    let current = head;\n\n    while (current) {\n        let count = 0;\n        let groupStart = current;\n        // Check if there are at least k nodes remaining\n        while (current && count < k) {\n            current = current.next;\n            count++;\n        }\n\n        if (count === k) {\n            // Reverse the k-group\n            let reversedHead = reverseList(groupStart, k);\n            \n            // Connect the previous group's end to the new head of the reversed group\n            prevGroupEnd.next = reversedHead;\n            \n            // Move prevGroupEnd to the end of the current reversed group (which was groupStart)\n            prevGroupEnd = groupStart;\n            \n            // The next group starts from 'current' (which is already k nodes ahead)\n            groupStart.next = current;\n        } else {\n            // If less than k nodes remain, link the previous group end to the current group start\n            // (which is the un-reversed tail of the original list) and break.\n            prevGroupEnd.next = groupStart;\n            break;\n        }\n    }\n\n    return dummy.next;\n};\n\n/**\n * Reverses a linked list of 'k' nodes starting from 'head'.\n * Returns the new head of the reversed segment.\n * The 'next' pointer of the original head (now tail) is not set here,\n * it will be set by the calling function.\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nfunction reverseList(head, k) {\n    let prev = null;\n    let current = head;\n    let count = 0;\n\n    while (current && count < k) {\n        let nextTemp = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextTemp;\n        count++;\n    }\n    // 'prev' is now the new head of the reversed segment\n    return prev;\n}\n"}}}
{"leetcodeId":26,"title":"Remove Duplicates from Sorted Array","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};","python":"from typing import List\n\ndef remove_duplicates(nums: List[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction removeDuplicates(nums: number[]): number {\n\n};"},"testCases":[{"input":"[1,1,2]","expectedOutput":2,"isHidden":false},{"input":"[0,0,1,1,1,2,2,3,3,4]","expectedOutput":5,"isHidden":false},{"input":"[]","expectedOutput":0,"isHidden":true},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[1,1,1,1,1]","expectedOutput":1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n\n    let i = 0; // Pointer for the unique elements\n    for (let j = 1; j < nums.length; j++) {\n        if (nums[j] !== nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n};"}}}
{"leetcodeId":32,"title":"Longest Valid Parentheses","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    \n};","python":"def longestValidParentheses(s: str) -> int:\n    pass","typescript":"function longestValidParentheses(s: string): number {\n\n};"},"testCases":[{"input":"\"(()\"","expectedOutput":2,"isHidden":false},{"input":"\")()())\"","expectedOutput":4,"isHidden":false},{"input":"\"\"","expectedOutput":0,"isHidden":false},{"input":"\"()(())\"","expectedOutput":6,"isHidden":true},{"input":"\"((()))\"","expectedOutput":6,"isHidden":true},{"input":"\")(\"","expectedOutput":0,"isHidden":true},{"input":"\"()(())\"","expectedOutput":6,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    let maxLength = 0;\n    let stack = [-1]; // Initialize stack with -1 to handle base cases\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') {\n            stack.push(i);\n        } else {\n            stack.pop();\n            if (stack.length === 0) {\n                // If stack is empty, it means current ')' doesn't have a matching '('\n                // before it, so push current index as a new base for future calculations.\n                stack.push(i);\n            } else {\n                // If stack is not empty, a valid pair is found.\n                // The length is current index minus the index of the top of the stack.\n                maxLength = Math.max(maxLength, i - stack[stack.length - 1]);\n            }\n        }\n    }\n\n    return maxLength;\n};"}}}
{"leetcodeId":28,"title":"Implement strStr()","codingData":{"starterCode":{"javascript":"/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    \n};","python":"def strStr(haystack: str, needle: str) -> int:\n    pass","typescript":"/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nfunction strStr(haystack: string, needle: string): number {\n\n};"},"testCases":[{"input":"\"hello\"\n\"ll\"","expectedOutput":2,"isHidden":false},{"input":"\"aaaaa\"\n\"bba\"","expectedOutput":-1,"isHidden":false},{"input":"\"\"\n\"\"","expectedOutput":0,"isHidden":false},{"input":"\"abc\"\n\"c\"","expectedOutput":2,"isHidden":true},{"input":"\"abc\"\n\"\"","expectedOutput":0,"isHidden":true},{"input":"\"mississippi\"\n\"issip\"","expectedOutput":4,"isHidden":true},{"input":"\"a\"\n\"a\"","expectedOutput":0,"isHidden":true},{"input":"\"a\"\n\"b\"","expectedOutput":-1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    if (needle.length === 0) {\n        return 0;\n    }\n\n    if (haystack.length < needle.length) {\n        return -1;\n    }\n\n    for (let i = 0; i <= haystack.length - needle.length; i++) {\n        let match = true;\n        for (let j = 0; j < needle.length; j++) {\n            if (haystack[i + j] !== needle[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return i;\n        }\n    }\n\n    return -1;\n};"}}}
{"leetcodeId":27,"title":"Remove Element","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    \n};","python":"def remove_element(nums: list[int], val: int) -> int:\n    \"\"\"\n    :param nums: The input array of numbers.\n    :param val: The value to remove from the array.\n    :return: The new length of the array after removing all instances of val.\n    \"\"\"\n    pass","typescript":"/**\n * @param nums The input array of numbers.\n * @param val The value to remove from the array.\n * @returns The new length of the array after removing all instances of val.\n */\nfunction removeElement(nums: number[], val: number): number {\n    \n};"},"testCases":[{"input":"[3,2,2,3]\n3","expectedOutput":2,"isHidden":false},{"input":"[0,1,2,2,3,0,4,2]\n2","expectedOutput":5,"isHidden":false},{"input":"[]\n0","expectedOutput":0,"isHidden":true},{"input":"[1]\n1","expectedOutput":0,"isHidden":true},{"input":"[1,2,3,4,5]\n6","expectedOutput":5,"isHidden":true},{"input":"[1,1,1,1,1]\n1","expectedOutput":0,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    let k = 0; // Pointer for the next position to place a non-val element\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    return k;\n};"}}}
{"leetcodeId":34,"title":"Find First and Last Position of Element in Sorted Array","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    \n};","python":"def search_range(nums: list[int], target: int) -> list[int]:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nfunction searchRange(nums: number[], target: number): number[] {\n\n};"},"testCases":[{"input":"[5,7,7,8,8,10]\n8","expectedOutput":"[3,4]","isHidden":false},{"input":"[5,7,7,8,8,10]\n6","expectedOutput":"[-1,-1]","isHidden":false},{"input":"[]\n0","expectedOutput":"[-1,-1]","isHidden":false},{"input":"[1]\n1","expectedOutput":"[0,0]","isHidden":true},{"input":"[1,2,3,4,5,6,7,8,9,10]\n5","expectedOutput":"[4,4]","isHidden":true},{"input":"[1,1,1,1,1,1,1,1,1,1]\n1","expectedOutput":"[0,9]","isHidden":true},{"input":"[1,2,3,4,5]\n6","expectedOutput":"[-1,-1]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    const findBound = (nums, target, isFirst) => {\n        let low = 0;\n        let high = nums.length - 1;\n        let result = -1;\n\n        while (low <= high) {\n            let mid = Math.floor((low + high) / 2);\n\n            if (nums[mid] === target) {\n                result = mid;\n                if (isFirst) {\n                    high = mid - 1; // Try to find an even earlier occurrence\n                } else {\n                    low = mid + 1;  // Try to find an even later occurrence\n                }\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return result;\n    };\n\n    const first = findBound(nums, target, true);\n    if (first === -1) {\n        return [-1, -1];\n    }\n\n    const last = findBound(nums, target, false);\n    return [first, last];\n};"}}}
{"leetcodeId":33,"title":"Search in Rotated Sorted Array","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};","python":"def search(nums: list[int], target: int) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nfunction search(nums: number[], target: number): number {\n\n};"},"testCases":[{"input":"[4,5,6,7,0,1,2]\n0","expectedOutput":4,"isHidden":false},{"input":"[4,5,6,7,0,1,2]\n3","expectedOutput":-1,"isHidden":false},{"input":"[1]\n0","expectedOutput":-1,"isHidden":false},{"input":"[1]\n1","expectedOutput":0,"isHidden":true},{"input":"[3,1]\n1","expectedOutput":1,"isHidden":true},{"input":"[5,1,3]\n3","expectedOutput":2,"isHidden":true},{"input":"[4,5,6,7,0,1,2]\n4","expectedOutput":0,"isHidden":true},{"input":"[4,5,6,7,0,1,2]\n2","expectedOutput":6,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        if (nums[mid] === target) {\n            return mid;\n        }\n\n        // Determine which half is sorted\n        if (nums[left] <= nums[mid]) { // Left half is sorted\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1; // Target is in the sorted left half\n            } else {\n                left = mid + 1; // Target is in the unsorted right half\n            }\n        } else { // Right half is sorted\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1; // Target is in the sorted right half\n            } else {\n                right = mid - 1; // Target is in the unsorted left half\n            }\n        }\n    }\n\n    return -1;\n};"}}}
{"leetcodeId":30,"title":"Substring with Concatenation of All Words","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    \n};","python":"from typing import List\n\ndef find_substring(s: str, words: List[str]) -> List[int]:\n    pass","typescript":"/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nfunction findSubstring(s: string, words: string[]): number[] {\n\n};"},"testCases":[{"input":"\"barfoothefoobarman\"\n[\"foo\",\"bar\"]","expectedOutput":"[0,9]","isHidden":false},{"input":"\"wordgoodgoodgoodbestword\"\n[\"word\",\"good\",\"best\",\"word\"]","expectedOutput":"[]","isHidden":false},{"input":"\"barfoofoobarthefoobarman\"\n[\"bar\",\"foo\",\"the\"]","expectedOutput":"[6,9,12]","isHidden":false},{"input":"\"\"\n[\"foo\",\"bar\"]","expectedOutput":"[]","isHidden":true},{"input":"\"wordgoodgoodgoodbestword\"\n[\"word\",\"good\",\"best\"]","expectedOutput":"[8]","isHidden":true},{"input":"\"aaaaaaaaaaaaaa\"\n[\"aa\",\"aa\"]","expectedOutput":"[0,1,2,3,4,5,6,7,8,9,10]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    if (!s || words.length === 0 || words[0].length === 0) {\n        return [];\n    }\n\n    const wordLen = words[0].length;\n    const numWords = words.length;\n    const totalLen = wordLen * numWords;\n    const result = [];\n\n    const wordCountMap = new Map();\n    for (const word of words) {\n        wordCountMap.set(word, (wordCountMap.get(word) || 0) + 1);\n    }\n\n    for (let i = 0; i <= s.length - totalLen; i++) {\n        const currentSubstring = s.substring(i, i + totalLen);\n        const currentMap = new Map();\n        let j = 0;\n        while (j < numWords) {\n            const start = j * wordLen;\n            const end = start + wordLen;\n            const word = currentSubstring.substring(start, end);\n\n            if (wordCountMap.has(word)) {\n                currentMap.set(word, (currentMap.get(word) || 0) + 1);\n                if (currentMap.get(word) > wordCountMap.get(word)) {\n                    break;\n                }\n            } else {\n                break;\n            }\n            j++;\n        }\n\n        if (j === numWords) {\n            result.push(i);\n        }\n    }\n\n    return result;\n};"}}}
{"leetcodeId":35,"title":"Search Insert Position","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n\n};","python":"def search_insert(nums: list[int], target: int) -> int:\n    pass","typescript":"/**\n * @param nums - The sorted array of distinct integers.\n * @param target - The target value to search for or insert.\n * @returns The index if the target is found, or the index where it would be inserted.\n */\nfunction searchInsert(nums: number[], target: number): number {\n\n};"},"testCases":[{"input":"[1,3,5,6]\n5","expectedOutput":2,"isHidden":false},{"input":"[1,3,5,6]\n2","expectedOutput":1,"isHidden":false},{"input":"[1,3,5,6]\n7","expectedOutput":4,"isHidden":false},{"input":"[1,3,5,6]\n0","expectedOutput":0,"isHidden":false},{"input":"[1]\n0","expectedOutput":0,"isHidden":false},{"input":"[1]\n1","expectedOutput":0,"isHidden":true},{"input":"[1,3,5,6]\n1","expectedOutput":0,"isHidden":true},{"input":"[1,3,5,6]\n6","expectedOutput":3,"isHidden":true},{"input":"[-5,-3,-1,0,2,4]\n-2","expectedOutput":3,"isHidden":true},{"input":"[-5,-3,-1,0,2,4]\n5","expectedOutput":6,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    // If the loop finishes, 'left' will be the correct insertion point.\n    // This is because 'left' always points to the first element >= target\n    // or the position where target would be inserted.\n    return left;\n};"}}}
{"leetcodeId":31,"title":"Next Permutation","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n\n};","python":"from typing import List\n\ndef next_permutation(nums: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"","typescript":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nfunction nextPermutation(nums: number[]): void {\n\n};"},"testCases":[{"input":"[1,2,3]","expectedOutput":"[1,3,2]","isHidden":false},{"input":"[3,2,1]","expectedOutput":"[1,2,3]","isHidden":false},{"input":"[1,1,5]","expectedOutput":"[1,5,1]","isHidden":false},{"input":"[1]","expectedOutput":"[1]","isHidden":false},{"input":"[1,5,1]","expectedOutput":"[5,1,1]","isHidden":true},{"input":"[2,3,1]","expectedOutput":"[3,1,2]","isHidden":true},{"input":"[1,2]","expectedOutput":"[2,1]","isHidden":true},{"input":"[2,1]","expectedOutput":"[1,2]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n    const n = nums.length;\n\n    // Find the first decreasing element from the right\n    let i = n - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n\n    if (i >= 0) {\n        // Find the smallest element to the right of nums[i] that is greater than nums[i]\n        let j = n - 1;\n        while (j >= 0 && nums[j] <= nums[i]) {\n            j--;\n        }\n        // Swap nums[i] and nums[j]\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n    }\n\n    // Reverse the subarray to the right of i\n    let left = i + 1;\n    let right = n - 1;\n    while (left < right) {\n        [nums[left], nums[right]] = [nums[right], nums[left]];\n        left++;\n        right--;\n    }\n};"}}}
{"leetcodeId":29,"title":"Divide Two Integers","codingData":{"starterCode":{"javascript":"/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\nvar divide = function(dividend, divisor) {\n    \n};","python":"def divide(dividend: int, divisor: int) -> int:\n    pass","typescript":"function divide(dividend: number, divisor: number): number {\n\n};"},"testCases":[{"input":"10\n3","expectedOutput":3,"isHidden":false},{"input":"7\n-3","expectedOutput":-2,"isHidden":false},{"input":"0\n1","expectedOutput":0,"isHidden":false},{"input":"1\n1","expectedOutput":1,"isHidden":false},{"input":"-2147483648\n-1","expectedOutput":2147483647,"isHidden":true},{"input":"2147483647\n1","expectedOutput":2147483647,"isHidden":true},{"input":"-2147483648\n1","expectedOutput":-2147483648,"isHidden":true},{"input":"-1\n-1","expectedOutput":1,"isHidden":true},{"input":"20\n2","expectedOutput":10,"isHidden":true},{"input":"-20\n2","expectedOutput":-10,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\nvar divide = function(dividend, divisor) {\n    const MAX_INT = 2147483647; // 2^31 - 1\n    const MIN_INT = -2147483648; // -2^31\n\n    // Handle overflow case: dividend = MIN_INT, divisor = -1\n    if (dividend === MIN_INT && divisor === -1) {\n        return MAX_INT;\n    }\n\n    let isNegative = (dividend < 0) !== (divisor < 0);\n\n    let absDividend = Math.abs(dividend);\n    let absDivisor = Math.abs(divisor);\n\n    let quotient = 0;\n\n    while (absDividend >= absDivisor) {\n        let tempDivisor = absDivisor;\n        let multiple = 1;\n        while (absDividend >= (tempDivisor << 1) && (tempDivisor << 1) > 0) { // (tempDivisor << 1) > 0 to prevent overflow for tempDivisor\n            tempDivisor <<= 1;\n            multiple <<= 1;\n        }\n        absDividend -= tempDivisor;\n        quotient += multiple;\n    }\n\n    if (isNegative) {\n        return -quotient;\n    } else {\n        return quotient;\n    }\n};"}}}
{"leetcodeId":38,"title":"Count and Say","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n\n};","python":"def count_and_say(n: int) -> str:\n    pass","typescript":"function countAndSay(n: number): string {\n\n};"},"testCases":[{"input":"1","expectedOutput":"1","isHidden":false},{"input":"4","expectedOutput":"1211","isHidden":false},{"input":"2","expectedOutput":"11","isHidden":true},{"input":"3","expectedOutput":"21","isHidden":true},{"input":"5","expectedOutput":"111221","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n    if (n === 1) {\n        return \"1\";\n    }\n\n    let prev = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n\n    for (let i = 0; i < prev.length; i++) {\n        if (i + 1 < prev.length && prev[i] === prev[i + 1]) {\n            count++;\n        } else {\n            result += count + prev[i];\n            count = 1;\n        }\n    }\n\n    return result;\n};"}}}
{"leetcodeId":45,"title":"Jump Game II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n\n};","python":"def jump(nums: list[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction jump(nums: number[]): number {\n\n};"},"testCases":[{"input":"[2,3,1,1,4]","expectedOutput":2,"isHidden":false},{"input":"[2,3,0,1,4]","expectedOutput":2,"isHidden":false},{"input":"[1]","expectedOutput":0,"isHidden":true},{"input":"[1,2]","expectedOutput":1,"isHidden":true},{"input":"[7,0,9,6,9,6,1,7,9,0,1,2,9,0,3]","expectedOutput":2,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    let jumps = 0;\n    let currentJumpEnd = 0;\n    let farthest = 0;\n\n    for (let i = 0; i < nums.length - 1; i++) {\n        // Update the farthest reach possible from the current position\n        farthest = Math.max(farthest, i + nums[i]);\n\n        // If we have reached the end of the current jump's range\n        if (i === currentJumpEnd) {\n            jumps++; // Increment the number of jumps\n            currentJumpEnd = farthest; // Set the new end of the jump range\n\n            // If the new currentJumpEnd is beyond or at the last index, we can stop\n            if (currentJumpEnd >= nums.length - 1) {\n                break;\n            }\n        }\n    }\n\n    return jumps;\n};"}}}
{"leetcodeId":42,"title":"Trapping Rain Water","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    \n};\n","python":"from typing import List\n\ndef trap(height: List[int]) -> int:\n    pass\n","typescript":"/**\n * @param {number[]} height\n * @return {number}\n */\nfunction trap(height: number[]): number {\n\n};\n"},"testCases":[{"input":"[0,1,0,2,1,0,1,3,2,1,2,1]","expectedOutput":6,"isHidden":false},{"input":"[4,2,0,3,2,5]","expectedOutput":9,"isHidden":false},{"input":"[]","expectedOutput":0,"isHidden":true},{"input":"[1]","expectedOutput":0,"isHidden":true},{"input":"[1,2,3,4,5]","expectedOutput":0,"isHidden":true},{"input":"[5,4,3,2,1]","expectedOutput":0,"isHidden":true},{"input":"[5,0,5]","expectedOutput":5,"isHidden":true},{"input":"[2,0,2]","expectedOutput":2,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    if (height.length === 0) {\n        return 0;\n    }\n\n    let left = 0;\n    let right = height.length - 1;\n    let leftMax = 0;\n    let rightMax = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                trappedWater += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                trappedWater += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n\n    return trappedWater;\n};\n"}}}
{"leetcodeId":43,"title":"Multiply Strings","codingData":{"starterCode":{"javascript":"/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiplyStrings = function(num1, num2) {\n    \n};","python":"def multiply_strings(num1: str, num2: str) -> str:\n    pass","typescript":"/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nfunction multiplyStrings(num1: string, num2: string): string {\n\n};"},"testCases":[{"input":"\"2\"\n\"3\"","expectedOutput":"\"6\"","isHidden":false},{"input":"\"123\"\n\"456\"","expectedOutput":"\"56088\"","isHidden":false},{"input":"\"0\"\n\"0\"","expectedOutput":"\"0\"","isHidden":true},{"input":"\"9\"\n\"9\"","expectedOutput":"\"81\"","isHidden":true},{"input":"\"123456789\"\n\"987654321\"","expectedOutput":"\"121932631112635269\"","isHidden":true},{"input":"\"1\"\n\"1\"","expectedOutput":"\"1\"","isHidden":true},{"input":"\"0\"\n\"123\"","expectedOutput":"\"0\"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiplyStrings = function(num1, num2) {\n    if (num1 === \"0\" || num2 === \"0\") {\n        return \"0\";\n    }\n\n    const m = num1.length;\n    const n = num2.length;\n    const pos = new Array(m + n).fill(0);\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            const mul = (num1.charCodeAt(i) - '0'.charCodeAt(0)) * (num2.charCodeAt(j) - '0'.charCodeAt(0));\n            const p1 = i + j;\n            const p2 = i + j + 1;\n\n            const sum = mul + pos[p2];\n\n            pos[p2] = sum % 10;\n            pos[p1] += Math.floor(sum / 10);\n        }\n    }\n\n    let result = \"\";\n    for (const digit of pos) {\n        if (!(result.length === 0 && digit === 0)) {\n            result += digit;\n        }\n    }\n\n    return result.length === 0 ? \"0\" : result;\n};"}}}
{"leetcodeId":39,"title":"Combination Sum","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    \n};","python":"from typing import List\n\ndef combination_sum(candidates: List[int], target: int) -> List[List[int]]:\n    pass","typescript":"/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nfunction combinationSum(candidates: number[], target: number): number[][] {\n\n};"},"testCases":[{"input":"[2,3,6,7]\n7","expectedOutput":"[[2,2,3],[7]]","isHidden":false},{"input":"[2,3,5]\n8","expectedOutput":"[[2,2,2,2],[2,3,3],[3,5]]","isHidden":false},{"input":"[2]\n1","expectedOutput":"[]","isHidden":false},{"input":"[1]\n1","expectedOutput":"[[1]]","isHidden":false},{"input":"[1]\n2","expectedOutput":"[[1,1]]","isHidden":false},{"input":"[7,3,2]\n18","expectedOutput":"[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]","isHidden":true},{"input":"[8,2,4]\n10","expectedOutput":"[[2,2,2,2,2],[2,2,2,4],[2,4,4],[2,8]]","isHidden":true},{"input":"[100,200]\n300","expectedOutput":"[[100,100,100],[100,200]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    const result = [];\n\n    /**\n     * @param {number} remaining - The remaining target sum.\n     * @param {number} start - The starting index in candidates to avoid duplicate combinations.\n     * @param {number[]} currentCombination - The current combination being built.\n     */\n    function backtrack(remaining, start, currentCombination) {\n        if (remaining === 0) {\n            result.push([...currentCombination]); // Found a valid combination\n            return;\n        }\n\n        if (remaining < 0) {\n            return; // Current combination sum exceeds target\n        }\n\n        for (let i = start; i < candidates.length; i++) {\n            const candidate = candidates[i];\n            currentCombination.push(candidate);\n            // Recursively call with the same 'i' because we can reuse the same candidate\n            backtrack(remaining - candidate, i, currentCombination);\n            currentCombination.pop(); // Backtrack: remove the last added candidate\n        }\n    }\n\n    // Start the backtracking process\n    backtrack(target, 0, []);\n\n    return result;\n};"}}}
{"leetcodeId":41,"title":"First Missing Positive","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n\n};","python":"def firstMissingPositive(nums: list[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction firstMissingPositive(nums: number[]): number {\n\n};"},"testCases":[{"input":"[1,2,0]","expectedOutput":3,"isHidden":false},{"input":"[3,4,-1,1]","expectedOutput":2,"isHidden":false},{"input":"[7,8,9,11,12]","expectedOutput":1,"isHidden":false},{"input":"[1]","expectedOutput":2,"isHidden":true},{"input":"[2]","expectedOutput":1,"isHidden":true},{"input":"[]","expectedOutput":1,"isHidden":true},{"input":"[1,2,3,4,5]","expectedOutput":6,"isHidden":true},{"input":"[0,-1,-2]","expectedOutput":1,"isHidden":true},{"input":"[100, 200, 300]","expectedOutput":1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n    const n = nums.length;\n\n    // Step 1: Replace non-positive numbers and numbers greater than n with 0\n    // We'll use 0 as a marker for numbers we don't care about or have already processed.\n    for (let i = 0; i < n; i++) {\n        if (nums[i] <= 0 || nums[i] > n) {\n            nums[i] = 0;\n        }\n    }\n\n    // Step 2: Use the array itself as a hash map.\n    // Mark numbers present by negating the value at the corresponding index.\n    // If nums[i] is k, then we mark index k-1.\n    // We use Math.abs(nums[i]) to handle cases where a number has already been marked negative.\n    for (let i = 0; i < n; i++) {\n        let val = Math.abs(nums[i]);\n        if (val >= 1 && val <= n) {\n            // If nums[val - 1] is 0, it means it was originally a non-positive or out-of-range number.\n            // We mark it with a special negative value to distinguish it from numbers that were originally positive\n            // and then negated. For example, - (n + 1) is a safe choice as it's outside the range [-n, -1].\n            if (nums[val - 1] === 0) {\n                nums[val - 1] = -(n + 1);\n            } else if (nums[val - 1] > 0) {\n                // If it's positive, negate it to mark its presence.\n                nums[val - 1] = -nums[val - 1];\n            }\n            // If nums[val - 1] is already negative, it means the number has already been seen.\n            // No need to do anything.\n        }\n    }\n\n    // Step 3: Find the first index that is not marked (i.e., still positive or 0).\n    // The index + 1 will be the first missing positive integer.\n    for (let i = 0; i < n; i++) {\n        if (nums[i] >= 0) { // Check for non-negative (original positive or original 0)\n            return i + 1;\n        }\n    }\n\n    // If all numbers from 1 to n are present, then the first missing positive is n + 1.\n    return n + 1;\n};"}}}
{"leetcodeId":40,"title":"Combination Sum II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};\n","python":"from typing import List\n\n\ndef combination_sum2(candidates: List[int], target: int) -> List[List[int]]:\n    pass\n","typescript":"/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nfunction combinationSum2(candidates: number[], target: number): number[][] {\n\n};\n"},"testCases":[{"input":"[10,1,2,7,6,1,5]\n8","expectedOutput":"[[1,1,6],[1,2,5],[1,7],[2,6]]","isHidden":false},{"input":"[2,5,2,1,2]\n5","expectedOutput":"[[1,2,2],[5]]","isHidden":false},{"input":"[1,1,1,1,1]\n3","expectedOutput":"[[1,1,1]]","isHidden":true},{"input":"[1]\n1","expectedOutput":"[[1]]","isHidden":true},{"input":"[1,2,3]\n7","expectedOutput":"[]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    const result = [];\n    // Sort candidates to handle duplicates and prune branches efficiently\n    candidates.sort((a, b) => a - b);\n\n    function backtrack(combination, remaining, start) {\n        if (remaining === 0) {\n            result.push([...combination]);\n            return;\n        }\n        if (remaining < 0) {\n            return;\n        }\n\n        for (let i = start; i < candidates.length; i++) {\n            // Skip duplicates\n            if (i > start && candidates[i] === candidates[i - 1]) {\n                continue;\n            }\n\n            const currentNum = candidates[i];\n            combination.push(currentNum);\n            backtrack(combination, remaining - currentNum, i + 1); // Use i + 1 because each number can be used once\n            combination.pop();\n        }\n    }\n\n    backtrack([], target, 0);\n    return result;\n};\n"}}}
{"leetcodeId":36,"title":"Valid Sudoku","codingData":{"starterCode":{"javascript":"/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n    \n};\n","python":"from typing import List\n\ndef is_valid_sudoku(board: List[List[str]]) -> bool:\n    pass\n","typescript":"/**\n * @param {character[][]} board\n * @return {boolean}\n */\nfunction isValidSudoku(board: string[][]): boolean {\n\n};\n"},"testCases":[{"input":"[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]","expectedOutput":true,"isHidden":false},{"input":"[\n  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]","expectedOutput":false,"isHidden":false},{"input":"[\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n]","expectedOutput":true,"isHidden":true},{"input":"[\n  [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],\n  [\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\"],\n  [\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],\n  [\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\"],\n  [\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\"],\n  [\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\"],\n  [\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"],\n  [\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"],\n  [\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"]\n]","expectedOutput":false,"isHidden":true},{"input":"[\n  [\"1\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"]\n]","expectedOutput":true,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n    const N = 9;\n\n    // Use sets to check for duplicates in rows, columns, and 3x3 sub-boxes\n    const rows = Array.from({ length: N }, () => new Set());\n    const cols = Array.from({ length: N }, () => new Set());\n    const boxes = Array.from({ length: N }, () => new Set());\n\n    for (let r = 0; r < N; r++) {\n        for (let c = 0; c < N; c++) {\n            const val = board[r][c];\n\n            // Skip empty cells\n            if (val === '.') {\n                continue;\n            }\n\n            // Check row\n            if (rows[r].has(val)) {\n                return false;\n            }\n            rows[r].add(val);\n\n            // Check column\n            if (cols[c].has(val)) {\n                return false;\n            }\n            cols[c].add(val);\n\n            // Check 3x3 sub-box\n            // Determine which box index this cell belongs to\n            // boxIndex = (row / 3) * 3 + (col / 3)\n            const boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3);\n            if (boxes[boxIndex].has(val)) {\n                return false;\n            }\n            boxes[boxIndex].add(val);\n        }\n    }\n\n    return true;\n};\n"}}}
{"leetcodeId":37,"title":"Sudoku Solver","codingData":{"starterCode":{"javascript":"/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solveSudoku = function(board) {\n    \n};\n","python":"from typing import List\n\ndef solveSudoku(board: List[List[str]]) -> None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    pass\n","typescript":"/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nfunction solveSudoku(board: string[][]): void {\n\n};\n"},"testCases":[{"input":"[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]","expectedOutput":"[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]","isHidden":false},{"input":"[[\".\",\".\",\"9\",\"7\",\"4\",\"8\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"1\",\".\",\"9\",\".\",\".\",\".\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\"2\",\"4\",\".\"],[\".\",\"6\",\"4\",\".\",\"1\",\".\",\"5\",\"9\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\"2\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\"2\",\"7\",\"5\",\"9\",\".\",\".\"]]","expectedOutput":"[[\"1\",\"3\",\"9\",\"7\",\"4\",\"8\",\"6\",\"5\",\"2\"],[\"7\",\"4\",\"6\",\"5\",\"2\",\"1\",\"9\",\"3\",\"8\"],[\"8\",\"2\",\"5\",\"1\",\"3\",\"9\",\"7\",\"6\",\"4\"],[\"3\",\"5\",\"7\",\"6\",\"8\",\"2\",\"2\",\"4\",\"1\"],[\"2\",\"6\",\"4\",\"3\",\"1\",\"7\",\"5\",\"9\",\"8\"],[\"9\",\"8\",\"1\",\"4\",\"5\",\"6\",\"3\",\"2\",\"7\"],[\"4\",\"1\",\"2\",\"8\",\"9\",\"3\",\"6\",\"7\",\"5\"],[\"5\",\"7\",\"3\",\"9\",\"6\",\"4\",\"8\",\"1\",\"2\"],[\"6\",\"9\",\"8\",\"2\",\"7\",\"5\",\"1\",\"4\",\"3\"]]","isHidden":true},{"input":"[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]","expectedOutput":"[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],[\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\"],[\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"],[\"2\",\"3\",\"1\",\"5\",\"6\",\"4\",\"8\",\"9\",\"7\"],[\"5\",\"6\",\"4\",\"8\",\"9\",\"7\",\"2\",\"3\",\"1\"],[\"8\",\"9\",\"7\",\"2\",\"3\",\"1\",\"5\",\"6\",\"4\"],[\"3\",\"1\",\"2\",\"6\",\"4\",\"5\",\"9\",\"7\",\"8\"],[\"6\",\"4\",\"5\",\"9\",\"7\",\"8\",\"3\",\"1\",\"2\"],[\"9\",\"7\",\"8\",\"3\",\"1\",\"2\",\"6\",\"4\",\"5\"]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solveSudoku = function(board) {\n    const N = 9;\n\n    function isValid(row, col, char) {\n        // Check row\n        for (let c = 0; c < N; c++) {\n            if (board[row][c] === char) {\n                return false;\n            }\n        }\n\n        // Check column\n        for (let r = 0; r < N; r++) {\n            if (board[r][col] === char) {\n                return false;\n            }\n        }\n\n        // Check 3x3 subgrid\n        const startRow = Math.floor(row / 3) * 3;\n        const startCol = Math.floor(col / 3) * 3;\n        for (let r = 0; r < 3; r++) {\n            for (let c = 0; c < 3; c++) {\n                if (board[startRow + r][startCol + c] === char) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function backtrack() {\n        for (let r = 0; r < N; r++) {\n            for (let c = 0; c < N; c++) {\n                if (board[r][c] === '.') {\n                    for (let num = 1; num <= 9; num++) {\n                        const charNum = String(num);\n                        if (isValid(r, c, charNum)) {\n                            board[r][c] = charNum;\n                            if (backtrack()) {\n                                return true;\n                            }\n                            board[r][c] = '.'; // Backtrack\n                        }\n                    }\n                    return false; // No valid number for this cell\n                }\n            }\n        }\n        return true; // All cells filled\n    }\n\n    backtrack();\n};\n"}}}
{"leetcodeId":55,"title":"Jump Game","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n\n};","python":"from typing import List\n\ndef can_jump(nums: List[int]) -> bool:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {boolean}\n */\nfunction canJump(nums: number[]): boolean {\n\n};"},"testCases":[{"input":"[2,3,1,1,4]","expectedOutput":true,"isHidden":false},{"input":"[3,2,1,0,4]","expectedOutput":false,"isHidden":false},{"input":"[0]","expectedOutput":true,"isHidden":true},{"input":"[0,1]","expectedOutput":false,"isHidden":true},{"input":"[1,0,1]","expectedOutput":false,"isHidden":true},{"input":"[1]","expectedOutput":true,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    let lastGoodIndex = nums.length - 1;\n\n    for (let i = nums.length - 2; i >= 0; i--) {\n        if (i + nums[i] >= lastGoodIndex) {\n            lastGoodIndex = i;\n        }\n    }\n\n    return lastGoodIndex === 0;\n};"}}}
{"leetcodeId":53,"title":"Maximum Subarray","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    \n};","python":"from typing import List\n\ndef max_sub_array(nums: List[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction maxSubArray(nums: number[]): number {\n\n};"},"testCases":[{"input":"[-2,1,-3,4,-1,2,1,-5,4]","expectedOutput":6,"isHidden":false},{"input":"[1]","expectedOutput":1,"isHidden":false},{"input":"[5,4,-1,7,8]","expectedOutput":23,"isHidden":false},{"input":"[-1]","expectedOutput":-1,"isHidden":true},{"input":"[-2,-1]","expectedOutput":-1,"isHidden":true},{"input":"[1,2,3,4,5]","expectedOutput":15,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    let currentMax = nums[0];\n    let globalMax = nums[0];\n\n    for (let i = 1; i < nums.length; i++) {\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\n        globalMax = Math.max(globalMax, currentMax);\n    }\n\n    return globalMax;\n};"}}}
{"leetcodeId":52,"title":"N-Queens II","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    \n};\n","python":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \n","typescript":"function totalNQueens(n: number): number {\n\n};\n"},"testCases":[{"input":"4","expectedOutput":2,"isHidden":false},{"input":"1","expectedOutput":1,"isHidden":false},{"input":"2","expectedOutput":0,"isHidden":true},{"input":"3","expectedOutput":0,"isHidden":true},{"input":"8","expectedOutput":92,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    let count = 0;\n    const cols = new Set();\n    const diag1 = new Set(); // r + c\n    const diag2 = new Set(); // r - c\n\n    function backtrack(r) {\n        if (r === n) {\n            count++;\n            return;\n        }\n\n        for (let c = 0; c < n; c++) {\n            if (!cols.has(c) && !diag1.has(r + c) && !diag2.has(r - c)) {\n                cols.add(c);\n                diag1.add(r + c);\n                diag2.add(r - c);\n\n                backtrack(r + 1);\n\n                cols.delete(c);\n                diag1.delete(r + c);\n                diag2.delete(r - c);\n            }\n        }\n    }\n\n    backtrack(0);\n    return count;\n};\n"}}}
{"leetcodeId":54,"title":"Spiral Matrix","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function(matrix) {\n\n};","python":"from typing import List\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    pass","typescript":"/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nfunction spiralOrder(matrix: number[][]): number[] {\n\n};"},"testCases":[{"input":"[[1,2,3],[4,5,6],[7,8,9]]","expectedOutput":"[1,2,3,6,9,8,7,4,5]","isHidden":false},{"input":"[[1,2,3,4],[5,6,7,8],[9,10,11,12]]","expectedOutput":"[1,2,3,4,8,12,11,10,9,5,6,7]","isHidden":false},{"input":"[[1]]","expectedOutput":"[1]","isHidden":true},{"input":"[[1,2],[3,4]]","expectedOutput":"[1,2,4,3]","isHidden":true},{"input":"[[1],[2],[3]]","expectedOutput":"[1,2,3]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function(matrix) {\n    const result = [];\n    if (!matrix || matrix.length === 0) {\n        return result;\n    }\n\n    let top = 0;\n    let bottom = matrix.length - 1;\n    let left = 0;\n    let right = matrix[0].length - 1;\n\n    while (top <= bottom && left <= right) {\n        // Traverse right\n        for (let i = left; i <= right; i++) {\n            result.push(matrix[top][i]);\n        }\n        top++;\n\n        // Traverse down\n        for (let i = top; i <= bottom; i++) {\n            result.push(matrix[i][right]);\n        }\n        right--;\n\n        // Traverse left (if there's still a row to traverse)\n        if (top <= bottom) {\n            for (let i = right; i >= left; i--) {\n                result.push(matrix[bottom][i]);\n            }\n            bottom--;\n        }\n\n        // Traverse up (if there's still a column to traverse)\n        if (left <= right) {\n            for (let i = bottom; i >= top; i--) {\n                result.push(matrix[i][left]);\n            }\n            left++;\n        }\n    }\n\n    return result;\n};"}}}
{"leetcodeId":50,"title":"Pow(x, n)","codingData":{"starterCode":{"javascript":"/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nvar myPow = function(x, n) {\n    \n};\n","python":"class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \n","typescript":"/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nfunction myPow(x: number, n: number): number {\n\n};\n"},"testCases":[{"input":"2.00000\n10","expectedOutput":1024,"isHidden":false},{"input":"2.10000\n3","expectedOutput":9.261,"isHidden":false},{"input":"2.00000\n-2","expectedOutput":0.25,"isHidden":false},{"input":"0.00001\n2147483647","expectedOutput":0,"isHidden":true},{"input":"1.00000\n-2147483648","expectedOutput":1,"isHidden":true},{"input":"-1.00000\n2147483647","expectedOutput":-1,"isHidden":true},{"input":"2.00000\n0","expectedOutput":1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nvar myPow = function(x, n) {\n    if (n === 0) {\n        return 1;\n    }\n    \n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    \n    let result = 1;\n    while (n > 0) {\n        if (n % 2 === 1) {\n            result *= x;\n        }\n        x *= x;\n        n = Math.floor(n / 2);\n    }\n    \n    return result;\n};\n"}}}
{"leetcodeId":46,"title":"Permutations","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    \n};","python":"from typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nfunction permute(nums: number[]): number[][] {\n\n};"},"testCases":[{"input":"[1,2,3]","expectedOutput":"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]","isHidden":false},{"input":"[0,1]","expectedOutput":"[[0,1],[1,0]]","isHidden":false},{"input":"[1]","expectedOutput":"[[1]]","isHidden":false},{"input":"[5,4,6,2]","expectedOutput":"[[5,4,6,2],[5,4,2,6],[5,6,4,2],[5,6,2,4],[5,2,4,6],[5,2,6,4],[4,5,6,2],[4,5,2,6],[4,6,5,2],[4,6,2,5],[4,2,5,6],[4,2,6,5],[6,5,4,2],[6,5,2,4],[6,4,5,2],[6,4,2,5],[6,2,5,4],[6,2,4,5],[2,5,4,6],[2,5,6,4],[2,4,5,6],[2,4,6,5],[2,6,5,4],[2,6,4,5]]","isHidden":true},{"input":"[-10]","expectedOutput":"[[-10]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    const result = [];\n    const n = nums.length;\n\n    function backtrack(currentPermutation, usedIndices) {\n        if (currentPermutation.length === n) {\n            result.push([...currentPermutation]);\n            return;\n        }\n\n        for (let i = 0; i < n; i++) {\n            if (!usedIndices[i]) {\n                currentPermutation.push(nums[i]);\n                usedIndices[i] = true;\n                backtrack(currentPermutation, usedIndices);\n                usedIndices[i] = false;\n                currentPermutation.pop();\n            }\n        }\n    }\n\n    backtrack([], new Array(n).fill(false));\n    return result;\n};"}}}
{"leetcodeId":48,"title":"Rotate Image","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function(matrix) {\n    \n};","python":"from typing import List\n\ndef rotate(matrix: List[List[int]]) -> None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    pass","typescript":"/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nfunction rotate(matrix: number[][]): void {\n\n};"},"testCases":[{"input":"[[1,2,3],[4,5,6],[7,8,9]]","expectedOutput":"[[7,4,1],[8,5,2],[9,6,3]]","isHidden":false},{"input":"[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]","expectedOutput":"[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]","isHidden":false},{"input":"[[1]]","expectedOutput":"[[1]]","isHidden":false},{"input":"[[1,2],[3,4]]","expectedOutput":"[[3,1],[4,2]]","isHidden":false},{"input":"[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]","expectedOutput":"[[21,16,11,6,1],[22,17,12,7,2],[23,18,13,8,3],[24,19,14,9,4],[25,20,15,10,5]]","isHidden":true},{"input":"[[1000]]","expectedOutput":"[[1000]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function(matrix) {\n    const n = matrix.length;\n\n    // Step 1: Transpose the matrix\n    for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n\n    // Step 2: Reverse each row\n    for (let i = 0; i < n; i++) {\n        matrix[i].reverse();\n    }\n};"}}}
{"leetcodeId":49,"title":"Group Anagrams","codingData":{"starterCode":{"javascript":"/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n\n};\n","python":"from typing import List\n\ndef group_anagrams(strs: List[str]) -> List[List[str]]:\n    pass\n","typescript":"/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nfunction groupAnagrams(strs: string[]): string[][] {\n\n};\n"},"testCases":[{"input":"[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]","expectedOutput":"[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]","isHidden":false},{"input":"[\"\"]","expectedOutput":"[[\"\"]]","isHidden":false},{"input":"[\"a\"]","expectedOutput":"[[\"a\"]]","isHidden":false},{"input":"[\"top\",\"pot\",\"opt\"]","expectedOutput":"[[\"opt\",\"pot\",\"top\"]]","isHidden":true},{"input":"[\"listen\",\"silent\",\"enlist\",\"hello\",\"world\"]","expectedOutput":"[[\"hello\"],[\"world\"],[\"enlist\",\"listen\",\"silent\"]]","isHidden":true},{"input":"[\"\",\"\",\"a\",\"b\"]","expectedOutput":"[[\"\"],[\"\"],[\"a\"],[\"b\"]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    const anagramGroups = new Map();\n\n    for (const str of strs) {\n        // Sort the string to create a canonical key for anagrams\n        const sortedStr = str.split('').sort().join('');\n\n        if (anagramGroups.has(sortedStr)) {\n            anagramGroups.get(sortedStr).push(str);\n        } else {\n            anagramGroups.set(sortedStr, [str]);\n        }\n    }\n\n    // Sort each group for consistent output (not strictly required by problem, but good for testing)\n    const result = Array.from(anagramGroups.values());\n    result.forEach(group => group.sort());\n\n    // Sort the outer array of groups based on the first element of each group\n    // This ensures consistent output order for the groups themselves\n    result.sort((a, b) => a[0].localeCompare(b[0]));\n\n    return result;\n};\n"}}}
{"leetcodeId":47,"title":"Permutations II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    \n};","python":"from typing import List\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    pass","typescript":"function permuteUnique(nums: number[]): number[][] {\n\n};"},"testCases":[{"input":"[1,1,2]","expectedOutput":"[[1,1,2],[1,2,1],[2,1,1]]","isHidden":false},{"input":"[1,2,3]","expectedOutput":"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]","isHidden":false},{"input":"[1]","expectedOutput":"[[1]]","isHidden":true},{"input":"[2,2,1,1]","expectedOutput":"[[1,1,2,2],[1,2,1,2],[1,2,2,1],[2,1,1,2],[2,1,2,1],[2,2,1,1]]","isHidden":true},{"input":"[-1,0,1]","expectedOutput":"[[-1,0,1],[-1,1,0],[0,-1,1],[0,1,-1],[1,-1,0],[1,0,-1]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    const result = [];\n    const n = nums.length;\n    // Sort nums to handle duplicates easily\n    nums.sort((a, b) => a - b);\n    const used = new Array(n).fill(false);\n\n    function backtrack(currentPermutation) {\n        if (currentPermutation.length === n) {\n            result.push([...currentPermutation]);\n            return;\n        }\n\n        for (let i = 0; i < n; i++) {\n            // Skip if element is already used\n            if (used[i]) {\n                continue;\n            }\n            // Skip duplicates: if current element is same as previous AND previous was not used\n            // This condition ensures that for duplicate elements, we only pick the first one\n            // in a sequence if the previous one (which is identical) was not picked.\n            // If nums[i-1] was used, it means we are building a permutation where nums[i-1] is at an earlier position,\n            // and it's fine to use nums[i] as a distinct element at the current position.\n            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {\n                continue;\n            }\n\n            used[i] = true;\n            currentPermutation.push(nums[i]);\n            backtrack(currentPermutation);\n            currentPermutation.pop();\n            used[i] = false;\n        }\n    }\n\n    backtrack([]);\n    return result;\n};"}}}
{"leetcodeId":51,"title":"N-Queens","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    \n};","python":"from typing import List\n\ndef solveNQueens(n: int) -> List[List[str]]:\n    pass","typescript":"/**\n * @param {number} n\n * @return {string[][]}\n */\nfunction solveNQueens(n: number): string[][] {\n\n};"},"testCases":[{"input":"4","expectedOutput":"[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]","isHidden":false},{"input":"1","expectedOutput":"[[\"Q\"]]","isHidden":false},{"input":"2","expectedOutput":"[]","isHidden":true},{"input":"3","expectedOutput":"[]","isHidden":true},{"input":"5","expectedOutput":"[[\"Q....\",\"..Q..\",\"....Q\",\".Q...\",\"...Q.\"],[\"Q....\",\"...Q.\",\".Q...\",\"....Q\",\"..Q..\"],[\".Q...\",\"...Q.\",\"Q....\",\"..Q..\",\"....Q\"],[\".Q...\",\"....Q\",\"..Q..\",\"Q....\",\"...Q.\"],[\"..Q..\",\"Q....\",\"...Q.\",\".Q...\",\"....Q\"],[\"..Q..\",\"....Q\",\".Q...\",\"...Q.\",\"Q....\"],[\"...Q.\",\"Q....\",\"..Q..\",\"....Q\",\".Q...\"],[\"...Q.\",\".Q...\",\"....Q\",\"..Q..\",\"Q....\"],[\"....Q\",\".Q...\",\"...Q.\",\"Q....\",\"..Q..\"],[\"....Q\",\"..Q..\",\"Q....\",\"...Q.\",\".Q...\"]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    const result = [];\n    const board = Array(n).fill(null).map(() => Array(n).fill('.'));\n\n    // Sets to keep track of attacked columns, positive diagonals (r+c), and negative diagonals (r-c)\n    const cols = new Set();\n    const posDiag = new Set(); // r + c\n    const negDiag = new Set(); // r - c\n\n    function backtrack(r) {\n        if (r === n) {\n            // All queens placed successfully, add current board to results\n            result.push(board.map(row => row.join('')));\n            return;\n        }\n\n        for (let c = 0; c < n; c++) {\n            if (cols.has(c) || posDiag.has(r + c) || negDiag.has(r - c)) {\n                // This position is attacked, skip it\n                continue;\n            }\n\n            // Place queen\n            board[r][c] = 'Q';\n            cols.add(c);\n            posDiag.add(r + c);\n            negDiag.add(r - c);\n\n            // Recurse to the next row\n            backtrack(r + 1);\n\n            // Backtrack: remove queen and clear sets\n            board[r][c] = '.';\n            cols.delete(c);\n            posDiag.delete(r + c);\n            negDiag.delete(r - c);\n        }\n    }\n\n    backtrack(0);\n    return result;\n};"}}}
{"leetcodeId":58,"title":"Length of Last Word","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n\n};\n","python":"def length_of_last_word(s: str) -> int:\n    pass\n","typescript":"function lengthOfLastWord(s: string): number {\n\n};\n"},"testCases":[{"input":"\"Hello World\"","expectedOutput":5,"isHidden":false},{"input":"\"   fly me   to   the moon  \"","expectedOutput":4,"isHidden":false},{"input":"\"luffy is still joyboy\"","expectedOutput":6,"isHidden":false},{"input":"\"a\"","expectedOutput":1,"isHidden":true},{"input":"\" \"","expectedOutput":0,"isHidden":true},{"input":"\"       \"","expectedOutput":0,"isHidden":true},{"input":"\"HelloWorld\"","expectedOutput":10,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n    let length = 0;\n    let i = s.length - 1;\n\n    // Skip trailing spaces\n    while (i >= 0 && s[i] === ' ') {\n        i--;\n    }\n\n    // Count characters of the last word\n    while (i >= 0 && s[i] !== ' ') {\n        length++;\n        i--;\n    }\n\n    return length;\n};\n"}}}
{"leetcodeId":60,"title":"Permutation Sequence","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n    \n};","python":"def getPermutation(n: int, k: int) -> str:\n    pass","typescript":"function getPermutation(n: number, k: number): string {\n\n};"},"testCases":[{"input":"3\n3","expectedOutput":"213","isHidden":false},{"input":"4\n9","expectedOutput":"2314","isHidden":false},{"input":"3\n1","expectedOutput":"123","isHidden":false},{"input":"1\n1","expectedOutput":"1","isHidden":true},{"input":"2\n1","expectedOutput":"12","isHidden":true},{"input":"2\n2","expectedOutput":"21","isHidden":true},{"input":"9\n362880","expectedOutput":"987654321","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n    let factorials = [1];\n    let numbers = [];\n    for (let i = 1; i <= n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n        numbers.push(i);\n    }\n\n    k--; // Adjust k to be 0-indexed\n    let result = [];\n\n    for (let i = n; i >= 1; i--) {\n        let fact = factorials[i - 1];\n        let index = Math.floor(k / fact);\n        result.push(numbers[index]);\n        numbers.splice(index, 1);\n        k %= fact;\n    }\n\n    return result.join('');\n};"}}}
{"leetcodeId":59,"title":"Spiral Matrix II","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {number[][]}\n */\nvar generateMatrix = function(n) {\n    \n};\n","python":"def generateMatrix(n: int) -> list[list[int]]:\n    pass\n","typescript":"/**\n * @param {number} n\n * @return {number[][]}\n */\nfunction generateMatrix(n: number): number[][] {\n\n};\n"},"testCases":[{"input":"3","expectedOutput":"[[1,2,3],[8,9,4],[7,6,5]]","isHidden":false},{"input":"1","expectedOutput":"[[1]]","isHidden":false},{"input":"2","expectedOutput":"[[1,2],[4,3]]","isHidden":true},{"input":"4","expectedOutput":"[[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {number[][]}\n */\nvar generateMatrix = function(n) {\n    const matrix = Array(n).fill(0).map(() => Array(n).fill(0));\n\n    let num = 1;\n    let top = 0;\n    let bottom = n - 1;\n    let left = 0;\n    let right = n - 1;\n\n    while (top <= bottom && left <= right) {\n        // Traverse right\n        for (let i = left; i <= right; i++) {\n            matrix[top][i] = num++;\n        }\n        top++;\n\n        // Traverse down\n        for (let i = top; i <= bottom; i++) {\n            matrix[i][right] = num++;\n        }\n        right--;\n\n        // Traverse left\n        if (top <= bottom) {\n            for (let i = right; i >= left; i--) {\n                matrix[bottom][i] = num++;\n            }\n            bottom--;\n        }\n\n        // Traverse up\n        if (left <= right) {\n            for (let i = bottom; i >= top; i--) {\n                matrix[i][left] = num++;\n            }\n            left++;\n        }\n    }\n\n    return matrix;\n};\n"}}}
{"leetcodeId":56,"title":"Merge Intervals","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n\n};","python":"from typing import List\n\ndef merge(intervals: List[List[int]]) -> List[List[int]]:\n    pass","typescript":"/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nfunction merge(intervals: number[][]): number[][] {\n\n};"},"testCases":[{"input":"[[1,3],[2,6],[8,10],[15,18]]","expectedOutput":"[[1,6],[8,10],[15,18]]","isHidden":false},{"input":"[[1,4],[4,5]]","expectedOutput":"[[1,5]]","isHidden":false},{"input":"[[1,4],[0,4]]","expectedOutput":"[[0,4]]","isHidden":true},{"input":"[[1,4],[0,0]]","expectedOutput":"[[0,0],[1,4]]","isHidden":true},{"input":"[[1,4],[0,1]]","expectedOutput":"[[0,4]]","isHidden":true},{"input":"[[1,4],[2,3]]","expectedOutput":"[[1,4]]","isHidden":true},{"input":"[[1,3]]","expectedOutput":"[[1,3]]","isHidden":true},{"input":"[[2,3],[4,5],[6,7],[8,9],[1,10]]","expectedOutput":"[[1,10]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n    if (intervals.length === 0) {\n        return [];\n    }\n\n    // Sort intervals by their start times\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    const merged = [];\n    for (let i = 0; i < intervals.length; i++) {\n        const currentInterval = intervals[i];\n        // If the merged list is empty or the current interval does not overlap with the previous merged interval\n        if (merged.length === 0 || currentInterval[0] > merged[merged.length - 1][1]) {\n            merged.push(currentInterval);\n        } else {\n            // There is an overlap, so merge the current and previous intervals\n            merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], currentInterval[1]);\n        }\n    }\n\n    return merged;\n};"}}}
{"leetcodeId":64,"title":"Minimum Path Sum","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function(grid) {\n\n};\n","python":"def min_path_sum(grid: list[list[int]]) -> int:\n    pass\n","typescript":"/**\n * @param grid {number[][]}\n * @return {number}\n */\nfunction minPathSum(grid: number[][]): number {\n\n};\n"},"testCases":[{"input":"[[1,3,1],[1,5,1],[4,2,1]]","expectedOutput":7,"isHidden":false},{"input":"[[1,2,3],[4,5,6]]","expectedOutput":12,"isHidden":false},{"input":"[[1]]","expectedOutput":1,"isHidden":true},{"input":"[[0]]","expectedOutput":0,"isHidden":true},{"input":"[[1,2],[1,1]]","expectedOutput":3,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n\n    // Create a DP table of the same size as the grid\n    // dp[i][j] will store the minimum path sum to reach (i, j)\n    const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n\n    // Initialize the DP table\n    // The first cell is just the value in the grid\n    dp[0][0] = grid[0][0];\n\n    // Initialize the first row\n    // To reach any cell in the first row, you can only come from the left\n    for (let j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n\n    // Initialize the first column\n    // To reach any cell in the first column, you can only come from above\n    for (let i = 1; i < m; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n\n    // Fill the rest of the DP table\n    // To reach dp[i][j], you can either come from dp[i-1][j] (down) or dp[i][j-1] (right)\n    // Choose the path that gives the minimum sum\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n\n    // The minimum path sum to reach the bottom-right corner is dp[m-1][n-1]\n    return dp[m - 1][n - 1];\n};\n"}}}
{"leetcodeId":57,"title":"Insert Interval","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};","python":"from typing import List\n\ndef insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    pass","typescript":"/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\n    \n};"},"testCases":[{"input":"[[1,3],[6,9]]\n[2,5]","expectedOutput":"[[1,5],[6,9]]","isHidden":false},{"input":"[[1,2],[3,5],[6,7],[8,10],[12,16]]\n[4,8]","expectedOutput":"[[1,2],[3,10],[12,16]]","isHidden":false},{"input":"[]\n[5,7]","expectedOutput":"[[5,7]]","isHidden":false},{"input":"[[1,5]]\n[2,3]","expectedOutput":"[[1,5]]","isHidden":false},{"input":"[[1,5]]\n[2,7]","expectedOutput":"[[1,7]]","isHidden":false},{"input":"[[1,3],[6,9]]\n[10,12]","expectedOutput":"[[1,3],[6,9],[10,12]]","isHidden":true},{"input":"[[1,3],[6,9]]\n[0,0]","expectedOutput":"[[0,0],[1,3],[6,9]]","isHidden":true},{"input":"[[1,5]]\n[0,0]","expectedOutput":"[[0,0],[1,5]]","isHidden":true},{"input":"[[1,5]]\n[0,6]","expectedOutput":"[[0,6]]","isHidden":true},{"input":"[[1,5]]\n[6,8]","expectedOutput":"[[1,5],[6,8]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    const result = [];\n    let i = 0;\n    const n = intervals.length;\n\n    // Add all intervals that come before newInterval and don't overlap\n    while (i < n && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    // Merge overlapping intervals\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.push(newInterval);\n\n    // Add all intervals that come after newInterval and don't overlap\n    while (i < n) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    return result;\n};"}}}
{"leetcodeId":62,"title":"Unique Paths","codingData":{"starterCode":{"javascript":"/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n\n};","python":"def unique_paths(m: int, n: int) -> int:\n    pass","typescript":"/**\n * @param m {number}\n * @param n {number}\n * @return {number}\n */\nfunction uniquePaths(m: number, n: number): number {\n\n};"},"testCases":[{"input":"3\n7","expectedOutput":28,"isHidden":false},{"input":"3\n2","expectedOutput":3,"isHidden":false},{"input":"7\n3","expectedOutput":28,"isHidden":false},{"input":"3\n3","expectedOutput":6,"isHidden":false},{"input":"1\n1","expectedOutput":1,"isHidden":true},{"input":"1\n100","expectedOutput":1,"isHidden":true},{"input":"100\n1","expectedOutput":1,"isHidden":true},{"input":"2\n2","expectedOutput":2,"isHidden":true},{"input":"10\n10","expectedOutput":48620,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    // Create a 2D array (grid) to store the number of unique paths\n    // dp[i][j] will store the number of unique paths to reach cell (i, j)\n    const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n\n    // Initialize the first row and first column\n    // There's only one way to reach any cell in the first row (by moving right)\n    // There's only one way to reach any cell in the first column (by moving down)\n    for (let i = 0; i < m; i++) {\n        dp[i][0] = 1;\n    }\n    for (let j = 0; j < n; j++) {\n        dp[0][j] = 1;\n    }\n\n    // Fill the rest of the grid\n    // For any cell (i, j), the number of unique paths to reach it\n    // is the sum of unique paths to reach the cell directly above it (i-1, j)\n    // and the cell directly to its left (i, j-1).\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    // The bottom-right cell contains the total number of unique paths\n    return dp[m - 1][n - 1];\n};"}}}
{"leetcodeId":63,"title":"Unique Paths II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n\n};","python":"def unique_paths_with_obstacles(obstacle_grid: list[list[int]]) -> int:\n    pass","typescript":"/**\n * @param obstacleGrid {number[][]}\n * @return {number}\n */\nfunction uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n\n};"},"testCases":[{"input":"[[0,0,0],[0,1,0],[0,0,0]]","expectedOutput":2,"isHidden":false},{"input":"[[0,1],[0,0]]","expectedOutput":1,"isHidden":false},{"input":"[[0]]","expectedOutput":1,"isHidden":true},{"input":"[[1]]","expectedOutput":0,"isHidden":true},{"input":"[[0,0],[0,0]]","expectedOutput":2,"isHidden":true},{"input":"[[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,1,0],[0,0,0,0]]","expectedOutput":7,"isHidden":true},{"input":"[[1,0]]","expectedOutput":0,"isHidden":true},{"input":"[[0,1]]","expectedOutput":0,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n    const m = obstacleGrid.length;\n    const n = obstacleGrid[0].length;\n\n    // If the starting cell has an obstacle, there are no paths.\n    if (obstacleGrid[0][0] === 1) {\n        return 0;\n    }\n\n    // Create a DP table initialized with zeros\n    const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n\n    // Initialize the starting point\n    dp[0][0] = 1;\n\n    // Fill the first row\n    for (let j = 1; j < n; j++) {\n        if (obstacleGrid[0][j] === 0 && dp[0][j - 1] === 1) {\n            dp[0][j] = 1;\n        }\n    }\n\n    // Fill the first column\n    for (let i = 1; i < m; i++) {\n        if (obstacleGrid[i][0] === 0 && dp[i - 1][0] === 1) {\n            dp[i][0] = 1;\n        }\n    }\n\n    // Fill the rest of the DP table\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            if (obstacleGrid[i][j] === 0) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    return dp[m - 1][n - 1];\n};"}}}
{"leetcodeId":61,"title":"Rotate List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\n};"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}\n2","expectedOutput":"{\"val\":4,\"next\":{\"val\":5,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":0,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":null}}}\n4","expectedOutput":"{\"val\":2,\"next\":{\"val\":0,\"next\":{\"val\":1,\"next\":null}}}","isHidden":false},{"input":"null\n0","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"next\":null}\n1","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}\n2","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}\n3","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":null}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}\n2000000000","expectedOutput":"{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":1,\"next\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || k === 0) {\n        return head;\n    }\n\n    let length = 1;\n    let tail = head;\n    while (tail.next) {\n        tail = tail.next;\n        length++;\n    }\n\n    // Connect the last node to the head to form a circle\n    tail.next = head;\n\n    // Calculate the actual number of rotations needed\n    // k % length gives the effective rotations. We need to find the new head\n    // which is (length - (k % length)) steps from the original head.\n    // Or, equivalently, the new tail is (k % length) steps from the original tail.\n    // The new head will be the node after the new tail.\n    const rotations = k % length;\n    const stepsToNewTail = length - rotations - 1; // -1 because we want the node *before* the new head\n\n    let newTail = head;\n    for (let i = 0; i < stepsToNewTail; i++) {\n        newTail = newTail.next;\n    }\n\n    const newHead = newTail.next;\n    newTail.next = null; // Break the circle\n\n    return newHead;\n};"}}}
{"leetcodeId":65,"title":"Valid Number","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function(s) {\n    \n};\n","python":"class Solution:\n    def isNumber(self, s: str) -> bool:\n        pass\n","typescript":"/**\n * @param {string} s\n * @return {boolean}\n */\nfunction isNumber(s: string): boolean {\n\n};\n"},"testCases":[{"input":"\"0\"","expectedOutput":true,"isHidden":false},{"input":"\"e\"","expectedOutput":false,"isHidden":false},{"input":"\".\"","expectedOutput":false,"isHidden":false},{"input":"\".1\"","expectedOutput":true,"isHidden":false},{"input":"\"2\"","expectedOutput":true,"isHidden":true},{"input":"\"0089\"","expectedOutput":true,"isHidden":true},{"input":"\"-0.1\"","expectedOutput":true,"isHidden":true},{"input":"\"+3.14\"","expectedOutput":true,"isHidden":true},{"input":"\"4.\"","expectedOutput":true,"isHidden":true},{"input":"\"-0.9\"","expectedOutput":true,"isHidden":true},{"input":"\"2e10\"","expectedOutput":true,"isHidden":true},{"input":"\"-90E3\"","expectedOutput":true,"isHidden":true},{"input":"\"3e+7\"","expectedOutput":true,"isHidden":true},{"input":"\"+6e-1\"","expectedOutput":true,"isHidden":true},{"input":"\"53.5e93\"","expectedOutput":true,"isHidden":true},{"input":"\"-123.456e789\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"","expectedOutput":false,"isHidden":true},{"input":"\"1a\"","expectedOutput":false,"isHidden":true},{"input":"\"1e\"","expectedOutput":false,"isHidden":true},{"input":"\"e3\"","expectedOutput":false,"isHidden":true},{"input":"\"99e2.5\"","expectedOutput":false,"isHidden":true},{"input":"\"--6\"","expectedOutput":false,"isHidden":true},{"input":"\"-+3\"","expectedOutput":false,"isHidden":true},{"input":"\"95a54e53\"","expectedOutput":false,"isHidden":true},{"input":"\"+\"","expectedOutput":false,"isHidden":true},{"input":"\"-\"","expectedOutput":false,"isHidden":true},{"input":"\"e.\"","expectedOutput":false,"isHidden":true},{"input":"\".e1\"","expectedOutput":false,"isHidden":true},{"input":"\"-.e1\"","expectedOutput":false,"isHidden":true},{"input":"\"4e+\"","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function(s) {\n    let i = 0;\n    let n = s.length;\n\n    // Skip leading whitespace\n    while (i < n && s[i] === ' ') {\n        i++;\n    }\n\n    // Check for sign\n    if (i < n && (s[i] === '+' || s[i] === '-')) {\n        i++;\n    }\n\n    let hasDigits = false;\n    let hasDot = false;\n\n    // Check for integer part or decimal part before 'e'\n    while (i < n && s[i] >= '0' && s[i] <= '9') {\n        hasDigits = true;\n        i++;\n    }\n\n    if (i < n && s[i] === '.') {\n        hasDot = true;\n        i++;\n        while (i < n && s[i] >= '0' && s[i] <= '9') {\n            hasDigits = true;\n            i++;\n        }\n    }\n\n    // If no digits found before 'e' or after dot, it's invalid\n    if (!hasDigits) {\n        return false;\n    }\n\n    // Check for 'e' or 'E' and exponent part\n    if (i < n && (s[i] === 'e' || s[i] === 'E')) {\n        i++;\n        let hasExpDigits = false;\n\n        // Check for sign in exponent\n        if (i < n && (s[i] === '+' || s[i] === '-')) {\n            i++;\n        }\n\n        while (i < n && s[i] >= '0' && s[i] <= '9') {\n            hasExpDigits = true;\n            i++;\n        }\n\n        // Exponent must have digits\n        if (!hasExpDigits) {\n            return false;\n        }\n    }\n\n    // Skip trailing whitespace\n    while (i < n && s[i] === ' ') {\n        i++;\n    }\n\n    // If we've processed the entire string, it's valid\n    return i === n;\n};\n"}}}
{"leetcodeId":70,"title":"Climbing Stairs","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    \n};","python":"def climbStairs(n: int) -> int:\n    pass","typescript":"function climbStairs(n: number): number {\n\n};"},"testCases":[{"input":"2","expectedOutput":2,"isHidden":false},{"input":"3","expectedOutput":3,"isHidden":false},{"input":"1","expectedOutput":1,"isHidden":true},{"input":"4","expectedOutput":5,"isHidden":true},{"input":"45","expectedOutput":1134903170,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    if (n <= 2) {\n        return n;\n    }\n\n    let dp = new Array(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[n];\n};\n"}}}
{"leetcodeId":69,"title":"Sqrt(x)","codingData":{"starterCode":{"javascript":"/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    \n};\n","python":"def my_sqrt(x: int) -> int:\n    pass\n","typescript":"/**\n * @param {number} x\n * @return {number}\n */\nfunction mySqrt(x: number): number {\n\n};\n"},"testCases":[{"input":"4","expectedOutput":2,"isHidden":false},{"input":"8","expectedOutput":2,"isHidden":false},{"input":"0","expectedOutput":0,"isHidden":true},{"input":"1","expectedOutput":1,"isHidden":true},{"input":"2147395599","expectedOutput":46340,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    if (x < 2) {\n        return x;\n    }\n\n    let left = 1;\n    let right = x;\n    let ans = 0;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (mid * mid === x) {\n            return mid;\n        } else if (mid * mid < x) {\n            ans = mid; // mid could be the answer\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n};\n"}}}
{"leetcodeId":66,"title":"Plus One","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n\n};","python":"def plus_one(digits: list[int]) -> list[int]:\n    pass","typescript":"/**\n * @param digits {number[]}\n * @return {number[]}\n */\nfunction plusOne(digits: number[]): number {\n\n};"},"testCases":[{"input":"[1,2,3]","expectedOutput":"[1,2,4]","isHidden":false},{"input":"[4,3,2,1]","expectedOutput":"[4,3,2,2]","isHidden":false},{"input":"[0]","expectedOutput":"[1]","isHidden":false},{"input":"[9]","expectedOutput":"[1,0]","isHidden":true},{"input":"[9,9]","expectedOutput":"[1,0,0]","isHidden":true},{"input":"[6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]","expectedOutput":"[6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,4]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n    const n = digits.length;\n    for (let i = n - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        } else {\n            digits[i] = 0;\n        }\n    }\n    // If we reach here, it means all digits were 9 (e.g., [9,9,9])\n    // We need to prepend a 1 and append all the zeros.\n    digits.unshift(1);\n    return digits;\n};"}}}
{"leetcodeId":67,"title":"Add Binary","codingData":{"starterCode":{"javascript":"/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addBinary = function(a, b) {\n    \n};","python":"def add_binary(a: str, b: str) -> str:\n    pass","typescript":"function addBinary(a: string, b: string): string {\n\n};"},"testCases":[{"input":"\"11\"\n\"1\"","expectedOutput":"\"100\"","isHidden":false},{"input":"\"1010\"\n\"1011\"","expectedOutput":"\"10101\"","isHidden":false},{"input":"\"0\"\n\"0\"","expectedOutput":"\"0\"","isHidden":true},{"input":"\"1\"\n\"0\"","expectedOutput":"\"1\"","isHidden":true},{"input":"\"1111\"\n\"1111\"","expectedOutput":"\"11110\"","isHidden":true},{"input":"\"1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n\"1\"","expectedOutput":"\"1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addBinary = function(a, b) {\n    let i = a.length - 1;\n    let j = b.length - 1;\n    let carry = 0;\n    let result = [];\n\n    while (i >= 0 || j >= 0 || carry > 0) {\n        let sum = carry;\n        if (i >= 0) {\n            sum += parseInt(a[i]);\n            i--;\n        }\n        if (j >= 0) {\n            sum += parseInt(b[j]);\n            j--;\n        }\n\n        result.unshift(sum % 2);\n        carry = Math.floor(sum / 2);\n    }\n\n    return result.join('');\n};"}}}
{"leetcodeId":74,"title":"Search a 2D Matrix","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function(matrix, target) {\n    \n};","python":"def searchMatrix(matrix: list[list[int]], target: int) -> bool:\n    pass","typescript":"/**\n * @param matrix {number[][]}\n * @param target {number}\n * @return {boolean}\n */\nfunction searchMatrix(matrix: number[][], target: number): boolean {\n\n};"},"testCases":[{"input":"[[1,3,5,7],[10,11,16,20],[23,30,34,60]]\n3","expectedOutput":"true","isHidden":false},{"input":"[[1,3,5,7],[10,11,16,20],[23,30,34,60]]\n13","expectedOutput":"false","isHidden":false},{"input":"[[1]]\n1","expectedOutput":"true","isHidden":true},{"input":"[[1,3]]\n3","expectedOutput":"true","isHidden":true},{"input":"[[1,3,5,7],[10,11,16,20],[23,30,34,60]]\n60","expectedOutput":"true","isHidden":true},{"input":"[[1,3,5,7],[10,11,16,20],[23,30,34,60]]\n0","expectedOutput":"false","isHidden":true},{"input":"[[1,3,5,7],[10,11,16,20],[23,30,34,60]]\n61","expectedOutput":"false","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function(matrix, target) {\n    if (!matrix || matrix.length === 0 || matrix[0].length === 0) {\n        return false;\n    }\n\n    const m = matrix.length;\n    const n = matrix[0].length;\n\n    let low = 0;\n    let high = m * n - 1;\n\n    while (low <= high) {\n        let mid = Math.floor((low + high) / 2);\n        let row = Math.floor(mid / n);\n        let col = mid % n;\n\n        if (matrix[row][col] === target) {\n            return true;\n        } else if (matrix[row][col] < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    return false;\n};"}}}
{"leetcodeId":72,"title":"Edit Distance","codingData":{"starterCode":{"javascript":"/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};","python":"def min_distance(word1: str, word2: str) -> int:\n    pass","typescript":"function minDistance(word1: string, word2: string): number {\n\n};"},"testCases":[{"input":"\"horse\"\n\"ros\"","expectedOutput":3,"isHidden":false},{"input":"\"intention\"\n\"execution\"","expectedOutput":5,"isHidden":false},{"input":"\"\"\n\"\"","expectedOutput":0,"isHidden":true},{"input":"\"a\"\n\"\"","expectedOutput":1,"isHidden":true},{"input":"\"\"\n\"a\"","expectedOutput":1,"isHidden":true},{"input":"\"abc\"\n\"abc\"","expectedOutput":0,"isHidden":true},{"input":"\"kitten\"\n\"sitting\"","expectedOutput":3,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n\n    // dp[i][j] will be the minimum operations required to convert\n    // word1[0...i-1] to word2[0...j-1]\n    const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));\n\n    // Initialize dp array\n    // If word1 is empty, we need to insert all characters of word2\n    for (let j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    // If word2 is empty, we need to delete all characters of word1\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n\n    // Fill the dp table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1]; // Characters match, no operation needed\n            } else {\n                dp[i][j] = 1 + Math.min(\n                    dp[i - 1][j],     // Delete from word1\n                    dp[i][j - 1],     // Insert into word1 (equivalent to deleting from word2)\n                    dp[i - 1][j - 1]  // Replace character\n                );\n            }\n        }\n    }\n\n    return dp[m][n];\n};"}}}
{"leetcodeId":75,"title":"Sort Colors","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function(nums) {\n\n};","python":"from typing import List\n\ndef sort_colors(nums: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nfunction sortColors(nums: number[]): void {\n\n};"},"testCases":[{"input":"[2,0,2,1,1,0]","expectedOutput":"[0,0,1,1,2,2]","isHidden":false},{"input":"[2,0,1]","expectedOutput":"[0,1,2]","isHidden":false},{"input":"[0]","expectedOutput":"[0]","isHidden":false},{"input":"[1]","expectedOutput":"[1]","isHidden":false},{"input":"[0,0,0]","expectedOutput":"[0,0,0]","isHidden":true},{"input":"[2,2,2]","expectedOutput":"[2,2,2]","isHidden":true},{"input":"[1,0,2]","expectedOutput":"[0,1,2]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function(nums) {\n    let low = 0; // Pointer for 0s\n    let mid = 0; // Pointer for 1s (current element)\n    let high = nums.length - 1; // Pointer for 2s\n\n    while (mid <= high) {\n        if (nums[mid] === 0) {\n            // If current element is 0, swap with element at low pointer\n            // and increment both low and mid pointers.\n            [nums[low], nums[mid]] = [nums[mid], nums[low]];\n            low++;\n            mid++;\n        } else if (nums[mid] === 1) {\n            // If current element is 1, it's already in its correct place (relative to 0s and 2s)\n            // Just increment mid pointer.\n            mid++;\n        } else { // nums[mid] === 2\n            // If current element is 2, swap with element at high pointer.\n            // Decrement high pointer, but do NOT increment mid pointer.\n            // The swapped element at mid could be 0, 1, or 2, so we need to re-evaluate it.\n            [nums[high], nums[mid]] = [nums[mid], nums[high]];\n            high--;\n        }\n    }\n};"}}}
{"leetcodeId":73,"title":"Set Matrix Zeroes","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function(matrix) {\n\n};","python":"def setZeroes(matrix: list[list[int]]) -> None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    pass","typescript":"/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nfunction setZeroes(matrix: number[][]): void {\n\n};"},"testCases":[{"input":"[[1,1,1],[1,0,1],[1,1,1]]","expectedOutput":"[[1,0,1],[0,0,0],[1,0,1]]","isHidden":false},{"input":"[[0,1,2,0],[3,4,5,2],[1,3,1,5]]","expectedOutput":"[[0,0,0,0],[0,4,5,0],[0,3,1,0]]","isHidden":false},{"input":"[[1]]","expectedOutput":"[[1]]","isHidden":true},{"input":"[[0]]","expectedOutput":"[[0]]","isHidden":true},{"input":"[[1,2,3,4],[5,0,7,8],[0,10,11,12],[13,14,15,0]]","expectedOutput":"[[0,0,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n\n    let firstRowHasZero = false;\n    let firstColHasZero = false;\n\n    // Check if first row has any zero\n    for (let j = 0; j < n; j++) {\n        if (matrix[0][j] === 0) {\n            firstRowHasZero = true;\n            break;\n        }\n    }\n\n    // Check if first column has any zero\n    for (let i = 0; i < m; i++) {\n        if (matrix[i][0] === 0) {\n            firstColHasZero = true;\n            break;\n        }\n    }\n\n    // Use first row and first column as markers\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            if (matrix[i][j] === 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    // Set zeroes based on markers in first row/column\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    // Set first row to zero if it originally had a zero\n    if (firstRowHasZero) {\n        for (let j = 0; j < n; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n\n    // Set first column to zero if it originally had a zero\n    if (firstColHasZero) {\n        for (let i = 0; i < m; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n};"}}}
{"leetcodeId":68,"title":"Text Justification","codingData":{"starterCode":{"javascript":"/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    \n};\n","python":"from typing import List\n\ndef full_justify(words: List[str], max_width: int) -> List[str]:\n    pass\n","typescript":"/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nfunction fullJustify(words: string[], maxWidth: number): string[] {\n\n};\n"},"testCases":[{"input":"[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n16","expectedOutput":["This    is    an","example  of text","justification.  "],"isHidden":false},{"input":"[\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n16","expectedOutput":["What   must   be","acknowledgment  ","shall be        "],"isHidden":false},{"input":"[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n20","expectedOutput":["Science  is  what we","understand      well","enough to explain to","a  computer.  Art is","everything  else  we","do                  "],"isHidden":false},{"input":"[\"a\"]\n1","expectedOutput":["a"],"isHidden":true},{"input":"[\"a\",\"b\",\"c\",\"d\",\"e\"]\n3","expectedOutput":["a b","c d","e  "],"isHidden":true},{"input":"[\"Listen\",\"to\",\"many,\",\"speak\",\"to\",\"a\",\"few.\"]\n6","expectedOutput":["Listen","to    ","many, ","speak ","to a  ","few.  "],"isHidden":true},{"input":"[\"fully\",\"justified\",\"text\"]\n10","expectedOutput":["fully     ","justified ","text      "],"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    const result = [];\n    let i = 0;\n    const n = words.length;\n\n    while (i < n) {\n        let currentLineWords = [];\n        let currentLineLength = 0;\n        let j = i;\n\n        // Greedily pack words into the current line\n        while (j < n && (currentLineLength + words[j].length + currentLineWords.length) <= maxWidth) {\n            currentLineWords.push(words[j]);\n            currentLineLength += words[j].length;\n            j++;\n        }\n\n        let line = \"\";\n        const numWordsInLine = currentLineWords.length;\n        const totalSpacesNeeded = maxWidth - currentLineLength;\n\n        // Check if it's the last line or if there's only one word in the line\n        if (j === n || numWordsInLine === 1) {\n            // Left justify\n            line = currentLineWords.join(' ');\n            line += ' '.repeat(maxWidth - line.length);\n        } else {\n            // Fully justify\n            const numGaps = numWordsInLine - 1;\n            const baseSpaces = Math.floor(totalSpacesNeeded / numGaps);\n            let extraSpaces = totalSpacesNeeded % numGaps;\n\n            for (let k = 0; k < numWordsInLine; k++) {\n                line += currentLineWords[k];\n                if (k < numGaps) {\n                    line += ' '.repeat(baseSpaces);\n                    if (extraSpaces > 0) {\n                        line += ' ';\n                        extraSpaces--;\n                    }\n                }\n            }\n        }\n        result.push(line);\n        i = j;\n    }\n\n    return result;\n};\n"}}}
{"leetcodeId":71,"title":"Simplify Path","codingData":{"starterCode":{"javascript":"/**\n * @param {string} path\n * @return {string}\n */\nvar simplifyPath = function(path) {\n    \n};\n","python":"class Solution:\n    def simplifyPath(self, path: str) -> str:\n        pass\n","typescript":"/**\n * @param {string} path\n * @return {string}\n */\nfunction simplifyPath(path: string): string {\n\n};\n"},"testCases":[{"input":"\"/home/\"","expectedOutput":"\"/home\"","isHidden":false},{"input":"\"/../\"","expectedOutput":"\"/\"","isHidden":false},{"input":"\"/home//foo/\"","expectedOutput":"\"/home/foo\"","isHidden":false},{"input":"\"/a/./b/../../c/\"","expectedOutput":"\"/c\"","isHidden":false},{"input":"\"/a/../../b/../c//.//\"","expectedOutput":"\"/c\"","isHidden":true},{"input":"\"/a/./b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../"}]}}
{"leetcodeId":78,"title":"Subsets","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    \n};","python":"from typing import List\n\ndef subsets(nums: List[int]) -> List[List[int]]:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nfunction subsets(nums: number[]): number[][] {\n\n};"},"testCases":[{"input":"[1,2,3]","expectedOutput":"[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]","isHidden":false},{"input":"[0]","expectedOutput":"[[],[0]]","isHidden":false},{"input":"[1]","expectedOutput":"[[],[1]]","isHidden":true},{"input":"[-1,0,1]","expectedOutput":"[[],[-1],[0],[-1,0],[1],[-1,1],[0,1],[-1,0,1]]","isHidden":true},{"input":"[10,20]","expectedOutput":"[[],[10],[20],[10,20]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    const result = [];\n    const n = nums.length;\n\n    // Iterate from 0 to 2^n - 1\n    for (let i = 0; i < (1 << n); i++) {\n        const currentSubset = [];\n        for (let j = 0; j < n; j++) {\n            // Check if the j-th bit of i is set\n            if ((i >> j) & 1) {\n                currentSubset.push(nums[j]);\n            }\n        }\n        result.push(currentSubset);\n    }\n\n    return result;\n};"}}}
{"leetcodeId":84,"title":"Largest Rectangle in Histogram","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} heights\n * @return {number}\n */\nvar largestRectangleArea = function(heights) {\n    \n};","python":"from typing import List\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} heights\n * @return {number}\n */\nfunction largestRectangleArea(heights: number[]): number {\n\n};"},"testCases":[{"input":"[2,1,5,6,2,3]","expectedOutput":10,"isHidden":false},{"input":"[2,4]","expectedOutput":4,"isHidden":false},{"input":"[0]","expectedOutput":0,"isHidden":true},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[1,1,1,1,1]","expectedOutput":5,"isHidden":true},{"input":"[6,5,4,3,2,1]","expectedOutput":12,"isHidden":true},{"input":"[1,2,3,4,5,6]","expectedOutput":12,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} heights\n * @return {number}\n */\nvar largestRectangleArea = function(heights) {\n    let maxArea = 0;\n    const stack = []; // Stores indices\n\n    for (let i = 0; i <= heights.length; i++) {\n        // When i reaches heights.length, we consider a bar of height 0 to pop all remaining elements from the stack\n        const currentHeight = (i === heights.length) ? 0 : heights[i];\n\n        while (stack.length > 0 && currentHeight < heights[stack[stack.length - 1]]) {\n            const h = heights[stack.pop()];\n            const w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        stack.push(i);\n    }\n\n    return maxArea;\n};"}}}
{"leetcodeId":80,"title":"Remove Duplicates from Sorted Array II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n\n};","python":"from typing import List\n\ndef remove_duplicates(nums: List[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction removeDuplicates(nums: number[]): number {\n\n};"},"testCases":[{"input":"[1,1,1,2,2,3]","expectedOutput":5,"isHidden":false},{"input":"[0,0,1,1,1,1,2,3,3]","expectedOutput":7,"isHidden":false},{"input":"[1,1,1,1,1]","expectedOutput":2,"isHidden":true},{"input":"[1,2,3,4,5]","expectedOutput":5,"isHidden":true},{"input":"[1,1]","expectedOutput":2,"isHidden":true},{"input":"[]","expectedOutput":0,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if (nums.length <= 2) {\n        return nums.length;\n    }\n\n    let k = 2; // k is the pointer for the next position to write a non-duplicate element\n\n    // Iterate from the third element\n    for (let i = 2; i < nums.length; i++) {\n        // If the current element is different from the element at k-2 (which is the second-to-last unique element),\n        // then it's a new unique element or a second occurrence of the previous unique element.\n        // We can safely place it at position k.\n        if (nums[i] !== nums[k - 2]) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n\n    return k;\n};"}}}
{"leetcodeId":77,"title":"Combinations","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    \n};","python":"from typing import List\n\ndef combine(n: int, k: int) -> List[List[int]]:\n    pass","typescript":"function combine(n: number, k: number): number[][] {\n\n};"},"testCases":[{"input":"4\n2","expectedOutput":"[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]","isHidden":false},{"input":"1\n1","expectedOutput":"[[1]]","isHidden":false},{"input":"3\n1","expectedOutput":"[[1],[2],[3]]","isHidden":true},{"input":"5\n3","expectedOutput":"[[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,4,5]]","isHidden":true},{"input":"20\n1","expectedOutput":"[[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    const result = [];\n    const currentCombination = [];\n\n    function backtrack(start) {\n        // Base case: if the current combination has k elements, add it to the result\n        if (currentCombination.length === k) {\n            result.push([...currentCombination]);\n            return;\n        }\n\n        // Optimization: if remaining elements are not enough to form a combination of size k\n        // n - start + 1 is the number of elements from 'start' to 'n'\n        // k - currentCombination.length is the number of elements still needed\n        if (k - currentCombination.length > n - start + 1) {\n            return;\n        }\n\n        // Recursive step: iterate from 'start' to 'n'\n        for (let i = start; i <= n; i++) {\n            currentCombination.push(i);\n            backtrack(i + 1); // Recurse with the next number\n            currentCombination.pop(); // Backtrack: remove the last added number\n        }\n    }\n\n    backtrack(1);\n    return result;\n};"}}}
{"leetcodeId":79,"title":"Word Search","codingData":{"starterCode":{"javascript":"/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n    \n};","python":"from typing import List\n\ndef exist(board: List[List[str]], word: str) -> bool:\n    pass","typescript":"function exist(board: string[][], word: string): boolean {\n\n};"},"testCases":[{"input":"[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCCED\"","expectedOutput":"true","isHidden":false},{"input":"[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"SEE\"","expectedOutput":"true","isHidden":false},{"input":"[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCB\"","expectedOutput":"false","isHidden":false},{"input":"[[\"A\",\"B\"],[\"C\",\"D\"]]\n\"ABCD\"","expectedOutput":"false","isHidden":true},{"input":"[[\"A\"]]\n\"A\"","expectedOutput":"true","isHidden":true},{"input":"[[\"a\",\"b\"],[\"c\",\"d\"]]\n\"acdb\"","expectedOutput":"true","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(row, col, index) {\n        // If we have found all characters in the word\n        if (index === word.length) {\n            return true;\n        }\n\n        // Check boundary conditions and if current cell matches the character in word\n        if (row < 0 || row >= m || col < 0 || col >= n || board[row][col] !== word[index]) {\n            return false;\n        }\n\n        // Mark the current cell as visited by changing its value\n        const originalChar = board[row][col];\n        board[row][col] = '#'; // Use a special character to mark as visited\n\n        // Explore all 4 possible directions\n        const found = dfs(row + 1, col, index + 1) ||\n                      dfs(row - 1, col, index + 1) ||\n                      dfs(row, col + 1, index + 1) ||\n                      dfs(row, col - 1, index + 1);\n\n        // Backtrack: restore the original character\n        board[row][col] = originalChar;\n\n        return found;\n    }\n\n    // Iterate through each cell in the board to start the DFS\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (board[i][j] === word[0]) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};"}}}
{"leetcodeId":76,"title":"Minimum Window Substring","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    \n};","python":"def min_window(s: str, t: str) -> str:\n    pass","typescript":"function minWindow(s: string, t: string): string {\n\n};"},"testCases":[{"input":"\"ADOBECODEBANC\"\n\"ABC\"","expectedOutput":"\"BANC\"","isHidden":false},{"input":"\"a\"\n\"a\"","expectedOutput":"\"a\"","isHidden":false},{"input":"\"a\"\n\"aa\"","expectedOutput":"\"\"","isHidden":true},{"input":"\"ADOBECODEBANC\"\n\"ABCC\"","expectedOutput":"\"CODEBANC\"","isHidden":true},{"input":"\"ADOBECODEBANC\"\n\"A\"","expectedOutput":"\"A\"","isHidden":true},{"input":"\"ADOBECODEBANC\"\n\"Z\"","expectedOutput":"\"\"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    if (t.length === 0) {\n        return \"\";\n    }\n\n    const tMap = {};\n    for (let char of t) {\n        tMap[char] = (tMap[char] || 0) + 1;\n    }\n\n    let windowStart = 0;\n    let matched = 0;\n    let minLength = Infinity;\n    let substrStart = 0;\n\n    for (let windowEnd = 0; windowEnd < s.length; windowEnd++) {\n        let rightChar = s[windowEnd];\n        if (rightChar in tMap) {\n            tMap[rightChar]--;\n            if (tMap[rightChar] >= 0) { // Character needed and still available\n                matched++;\n            }\n        }\n\n        while (matched === t.length) {\n            // Shrink the window\n            if (windowEnd - windowStart + 1 < minLength) {\n                minLength = windowEnd - windowStart + 1;\n                substrStart = windowStart;\n            }\n\n            let leftChar = s[windowStart];\n            windowStart++;\n            if (leftChar in tMap) {\n                if (tMap[leftChar] === 0) { // Character was needed and now we're losing one\n                    matched--;\n                }\n                tMap[leftChar]++;\n            }\n        }\n    }\n\n    if (minLength === Infinity) {\n        return \"\";\n    }\n\n    return s.substring(substrStart, substrStart + minLength);\n};"}}}
{"leetcodeId":83,"title":"Remove Duplicates from Sorted List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction deleteDuplicates(head) {\n  // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode | null} head\n * @return {ListNode | null}\n */\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":null}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":3,\"next\":null}}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"next\":null}","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":1,\"next\":null}}}","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction deleteDuplicates(head) {\n  if (!head) {\n    return head;\n  }\n\n  let current = head;\n  while (current && current.next) {\n    if (current.val === current.next.val) {\n      current.next = current.next.next;\n    } else {\n      current = current.next;\n    }\n  }\n\n  return head;\n}"}}}
{"leetcodeId":81,"title":"Search in Rotated Sorted Array II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nvar search = function(nums, target) {\n    \n};","python":"def search(nums: list[int], target: int) -> bool:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nfunction search(nums: number[], target: number): boolean {\n\n};"},"testCases":[{"input":"[2,5,6,0,0,1,2]\n0","expectedOutput":"true","isHidden":false},{"input":"[2,5,6,0,0,1,2]\n3","expectedOutput":"false","isHidden":false},{"input":"[1,0,1,1,1]\n0","expectedOutput":"true","isHidden":true},{"input":"[1,1,1,1,1]\n1","expectedOutput":"true","isHidden":true},{"input":"[1,1,1,1,1]\n2","expectedOutput":"false","isHidden":true},{"input":"[1]\n1","expectedOutput":"true","isHidden":true},{"input":"[1]\n0","expectedOutput":"false","isHidden":true},{"input":"[4,5,6,7,0,1,2]\n0","expectedOutput":"true","isHidden":true},{"input":"[4,5,6,7,0,1,2]\n3","expectedOutput":"false","isHidden":true},{"input":"[1,2,3,4,5]\n3","expectedOutput":"true","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nvar search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        if (nums[mid] === target) {\n            return true;\n        }\n\n        // Handle duplicates: if nums[left], nums[mid], and nums[right] are all the same,\n        // we can't determine which side is sorted. So, we shrink the search space.\n        if (nums[left] === nums[mid] && nums[mid] === nums[right]) {\n            left++;\n            right--;\n            continue;\n        }\n\n        // Determine which half is sorted\n        if (nums[left] <= nums[mid]) { // Left half is sorted\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else { // Right half is sorted\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return false;\n};"}}}
{"leetcodeId":85,"title":"Maximal Rectangle","codingData":{"starterCode":{"javascript":"/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalRectangle = function(matrix) {\n    \n};\n","python":"from typing import List\n\ndef maximal_rectangle(matrix: List[List[str]]) -> int:\n    pass\n","typescript":"/**\n * @param {character[][]} matrix\n * @return {number}\n */\nfunction maximalRectangle(matrix: string[][]): number {\n\n};\n"},"testCases":[{"input":"[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]","expectedOutput":6,"isHidden":false},{"input":"[]","expectedOutput":0,"isHidden":false},{"input":"[[\"0\"]]","expectedOutput":0,"isHidden":false},{"input":"[[\"1\"]]","expectedOutput":1,"isHidden":false},{"input":"[[\"0\",\"0\"]]","expectedOutput":0,"isHidden":false},{"input":"[[\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\"]]","expectedOutput":9,"isHidden":true},{"input":"[[\"0\",\"1\"],[\"1\",\"0\"]]","expectedOutput":1,"isHidden":true},{"input":"[[\"1\",\"1\",\"0\",\"1\"],[\"1\",\"1\",\"0\",\"1\"],[\"1\",\"1\",\"1\",\"1\"]]","expectedOutput":6,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalRectangle = function(matrix) {\n    if (!matrix || matrix.length === 0 || matrix[0].length === 0) {\n        return 0;\n    }\n\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    const heights = new Array(cols).fill(0);\n    let maxArea = 0;\n\n    // Helper function to calculate largest rectangle in a histogram\n    const largestRectangleArea = (h) => {\n        let stack = []; // Stores indices\n        let maxA = 0;\n        for (let i = 0; i <= h.length; i++) {\n            // Use 0 as a sentinel value at the end to pop all remaining bars\n            while (stack.length > 0 && (i === h.length || h[stack[stack.length - 1]] >= h[i])) {\n                const height = h[stack.pop()];\n                const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n                maxA = Math.max(maxA, height * width);\n            }\n            stack.push(i);\n        }\n        return maxA;\n    };\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (matrix[i][j] === '1') {\n                heights[j]++;\n            } else {\n                heights[j] = 0;\n            }\n        }\n        maxArea = Math.max(maxArea, largestRectangleArea(heights));\n    }\n\n    return maxArea;\n};\n"}}}
{"leetcodeId":82,"title":"Remove Duplicates from Sorted List II","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function(head) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n\n};"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":5,\"next\":null}}}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}}}","expectedOutput":"{\"val\":2,\"next\":{\"val\":3,\"next\":null}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":null}}","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":2,\"next\":null}}}}","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":3,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":4,\"next\":null}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function(head) {\n    if (!head) {\n        return null;\n    }\n\n    let dummy = new ListNode(0, head);\n    let prev = dummy;\n    let current = head;\n\n    while (current) {\n        // Check if current node is a duplicate\n        if (current.next && current.val === current.next.val) {\n            // Skip all nodes with the same value\n            while (current.next && current.val === current.next.val) {\n                current = current.next;\n            }\n            // Link prev to the node after the duplicates\n            prev.next = current.next;\n        } else {\n            // No duplicate, move prev forward\n            prev = current;\n        }\n        // Move current forward\n        current = current.next;\n    }\n\n    return dummy.next;\n};"}}}
{"leetcodeId":89,"title":"Gray Code","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function(n) {\n    \n};","python":"def grayCode(n: int) -> list[int]:\n    pass","typescript":"/**\n * @param {number} n\n * @return {number[]}\n */\nfunction grayCode(n: number): number[] {\n\n};"},"testCases":[{"input":"2","expectedOutput":"[0,1,3,2]","isHidden":false},{"input":"1","expectedOutput":"[0,1]","isHidden":false},{"input":"3","expectedOutput":"[0,1,3,2,6,7,5,4]","isHidden":true},{"input":"4","expectedOutput":"[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function(n) {\n    if (n === 0) {\n        return [0];\n    }\n\n    let result = [0, 1];\n\n    for (let i = 2; i <= n; i++) {\n        const len = result.length;\n        const mask = 1 << (i - 1);\n        for (let j = len - 1; j >= 0; j--) {\n            result.push(result[j] | mask);\n        }\n    }\n\n    return result;\n};"}}}
{"leetcodeId":90,"title":"Subsets II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    \n};","python":"from typing import List\n\ndef subsetsWithDup(nums: List[int]) -> List[List[int]]:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nfunction subsetsWithDup(nums: number[]): number[][] {\n\n};"},"testCases":[{"input":"[1,2,2]","expectedOutput":"[[],[1],[1,2],[1,2,2],[2],[2,2]]","isHidden":false},{"input":"[0]","expectedOutput":"[[],[0]]","isHidden":false},{"input":"[1,1]","expectedOutput":"[[],[1],[1,1]]","isHidden":true},{"input":"[4,4,4,1,4]","expectedOutput":"[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]","isHidden":true},{"input":"[]","expectedOutput":"[[]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    const currentSubset = [];\n\n    function backtrack(start) {\n        result.push([...currentSubset]);\n\n        for (let i = start; i < nums.length; i++) {\n            // Skip duplicates\n            if (i > start && nums[i] === nums[i - 1]) {\n                continue;\n            }\n\n            currentSubset.push(nums[i]);\n            backtrack(i + 1);\n            currentSubset.pop();\n        }\n    }\n\n    backtrack(0);\n    return result;\n};"}}}
{"leetcodeId":91,"title":"Decode Ways","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    \n};","python":"class Solution:\n    def numDecodings(self, s: str) -> int:\n        pass","typescript":"function numDecodings(s: string): number {\n\n};"},"testCases":[{"input":"\"12\"","expectedOutput":2,"isHidden":false},{"input":"\"226\"","expectedOutput":3,"isHidden":false},{"input":"\"0\"","expectedOutput":0,"isHidden":false},{"input":"\"06\"","expectedOutput":0,"isHidden":false},{"input":"\"10\"","expectedOutput":1,"isHidden":true},{"input":"\"2101\"","expectedOutput":1,"isHidden":true},{"input":"\"111111111111111111111111111111111111111111111\"","expectedOutput":1836311903,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    if (s[0] === '0') {\n        return 0;\n    }\n\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.substring(i - 1, i));\n        const twoDigits = parseInt(s.substring(i - 2, i));\n\n        // Check for single digit decoding\n        if (oneDigit >= 1 && oneDigit <= 9) {\n            dp[i] += dp[i - 1];\n        }\n\n        // Check for two digit decoding\n        if (twoDigits >= 10 && twoDigits <= 26) {\n            dp[i] += dp[i - 2];\n        }\n    }\n\n    return dp[n];\n};"}}}
{"leetcodeId":88,"title":"Merge Sorted Array","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n\n};\n","python":"def merge(nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n    \"\"\"\n    Do not return anything, modify nums1 in-place instead.\n    \"\"\"\n    pass\n","typescript":"/**\n * @param nums1\n * @param m\n * @param nums2\n * @param n\n * @return void Do not return anything, modify nums1 in-place instead.\n */\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\n\n};\n"},"testCases":[{"input":"[1,2,3,0,0,0]\n3\n[2,5,6]\n3","expectedOutput":"[1,2,2,3,5,6]","isHidden":false},{"input":"[1]\n1\n[]\n0","expectedOutput":"[1]","isHidden":false},{"input":"[0]\n0\n[1]\n1","expectedOutput":"[1]","isHidden":true},{"input":"[4,5,6,0,0,0]\n3\n[1,2,3]\n3","expectedOutput":"[1,2,3,4,5,6]","isHidden":true},{"input":"[1,2,3,4,5,6]\n6\n[]\n0","expectedOutput":"[1,2,3,4,5,6]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    let p1 = m - 1; // Pointer for nums1's actual elements\n    let p2 = n - 1; // Pointer for nums2\n    let p = m + n - 1; // Pointer for the end of nums1 (where merged elements will go)\n\n    // While there are elements to consider in nums2\n    while (p2 >= 0) {\n        // If there are still elements in nums1 and the current element in nums1\n        // is greater than or equal to the current element in nums2\n        if (p1 >= 0 && nums1[p1] >= nums2[p2]) {\n            nums1[p] = nums1[p1]; // Place nums1's element at the current position\n            p1--; // Move nums1's pointer back\n        } else {\n            // Otherwise, nums2's element is larger or nums1 is exhausted\n            nums1[p] = nums2[p2]; // Place nums2's element at the current position\n            p2--; // Move nums2's pointer back\n        }\n        p--; // Move the merged array pointer back\n    }\n};\n"}}}
{"leetcodeId":95,"title":"Unique Binary Search Trees II","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nfunction generateTrees(n) {\n    // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef generate_trees(n: int) -> List[Optional[TreeNode]]:\n    # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val)\n        this.left = (left===undefined ? null : left)\n        this.right = (right===undefined ? null : right)\n    }\n}\n\nfunction generateTrees(n: number): Array<TreeNode | null> {\n    // Your code here\n}"},"testCases":[{"input":"3","expectedOutput":"[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]","isHidden":false},{"input":"1","expectedOutput":"[[1]]","isHidden":false},{"input":"2","expectedOutput":"[[1,null,2],[2,1,null]]","isHidden":true},{"input":"0","expectedOutput":"[]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nfunction generateTrees(n) {\n    if (n === 0) {\n        return [];\n    }\n\n    function generate(start, end) {\n        const result = [];\n        if (start > end) {\n            result.push(null);\n            return result;\n        }\n\n        for (let i = start; i <= end; i++) {\n            const leftSubtrees = generate(start, i - 1);\n            const rightSubtrees = generate(i + 1, end);\n\n            for (const left of leftSubtrees) {\n                for (const right of rightSubtrees) {\n                    const root = new TreeNode(i, left, right);\n                    result.push(root);\n                }\n            }\n        }\n        return result;\n    }\n\n    return generate(1, n);\n}\n\n// Helper TreeNode class for local testing (LeetCode provides its own)\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n}"}}}
{"leetcodeId":93,"title":"Restore IP Addresses","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    \n};\n","python":"def restoreIpAddresses(s: str) -> list[str]:\n    pass\n","typescript":"/**\n * @param {string} s\n * @return {string[]}\n */\nfunction restoreIpAddresses(s: string): string[] {\n\n};\n"},"testCases":[{"input":"\"25525511135\"","expectedOutput":"[\"255.255.11.135\",\"255.255.111.35\"]","isHidden":false},{"input":"\"0000\"","expectedOutput":"[\"0.0.0.0\"]","isHidden":false},{"input":"\"1111\"","expectedOutput":"[\"1.1.1.1\"]","isHidden":false},{"input":"\"010010\"","expectedOutput":"[\"0.10.0.10\",\"0.100.1.0\"]","isHidden":false},{"input":"\"101023\"","expectedOutput":"[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]","isHidden":false},{"input":"\"1\"","expectedOutput":"[]","isHidden":true},{"input":"\"12345\"","expectedOutput":"[\"1.2.3.45\",\"1.2.34.5\",\"1.23.4.5\",\"12.3.4.5\"]","isHidden":true},{"input":"\"000\"","expectedOutput":"[]","isHidden":true},{"input":"\"255255255255\"","expectedOutput":"[\"255.255.255.255\"]","isHidden":true},{"input":"\"19216811\"","expectedOutput":"[\"19.216.8.11\",\"192.16.8.11\",\"192.168.1.1\"]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    const result = [];\n\n    function isValidPart(part) {\n        if (part.length === 0 || part.length > 3) {\n            return false;\n        }\n        if (part.length > 1 && part[0] === '0') {\n            return false;\n        }\n        const num = parseInt(part, 10);\n        return num >= 0 && num <= 255;\n    }\n\n    function backtrack(index, currentIpParts) {\n        if (currentIpParts.length === 4) {\n            if (index === s.length) {\n                result.push(currentIpParts.join('.'));\n            }\n            return;\n        }\n\n        for (let i = 1; i <= 3; i++) {\n            if (index + i > s.length) {\n                break;\n            }\n            const part = s.substring(index, index + i);\n            if (isValidPart(part)) {\n                currentIpParts.push(part);\n                backtrack(index + i, currentIpParts);\n                currentIpParts.pop(); // Backtrack\n            }\n        }\n    }\n\n    backtrack(0, []);\n    return result;\n};\n"}}}
{"leetcodeId":86,"title":"Partition List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nfunction partition(head, x) {\n  // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\ninterface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\n/**\n * @param head {ListNode | null}\n * @param x {number}\n * @return {ListNode | null}\n */\nfunction partition(head: ListNode | null, x: number): ListNode | null {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":5,\"next\":{\"val\":2,\"next\":null}}}}}}}\n3","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":2,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":5,\"next\":null}}}}}}}","isHidden":false},{"input":"{\"val\":2,\"next\":{\"val\":1,\"next\":null}}\n2","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","isHidden":false},{"input":"null\n0","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":null}}\n0","expectedOutput":"{\"val\":1,\"next\":{\"val\":1,\"next\":null}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}\n4","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}","isHidden":true},{"input":"{\"val\":5,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":null}}}}}\n3","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":5,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":null}}}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nfunction partition(head, x) {\n  let lessHead = new ListNode(0);\n  let greaterEqualHead = new ListNode(0);\n  let less = lessHead;\n  let greaterEqual = greaterEqualHead;\n\n  let current = head;\n  while (current !== null) {\n    if (current.val < x) {\n      less.next = current;\n      less = less.next;\n    } else {\n      greaterEqual.next = current;\n      greaterEqual = greaterEqual.next;\n    }\n    current = current.next;\n  }\n\n  greaterEqual.next = null; // Important: terminate the greaterEqual list\n  less.next = greaterEqualHead.next;\n\n  return lessHead.next;\n}"}}}
{"leetcodeId":94,"title":"Binary Tree Inorder Traversal","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nfunction inorderTraversal(root: TreeNode | null): number[] {\n\n};"},"testCases":[{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"right\":null,\"left\":null},\"right\":null}}","expectedOutput":"[1,3,2]","isHidden":false},{"input":"null","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"[1]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"[2,1]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":"[1,2]","isHidden":false},{"input":"{\"val\":5,\"left\":{\"val\":3,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":7,\"left\":{\"val\":6,\"left\":null,\"right\":null},\"right\":{\"val\":8,\"left\":null,\"right\":null}}}","expectedOutput":"[2,3,4,5,6,7,8]","isHidden":true},{"input":"{\"val\":100,\"left\":{\"val\":-50,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"[-50,100]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    const result = [];\n    const stack = [];\n    let current = root;\n\n    while (current !== null || stack.length > 0) {\n        // Reach the leftmost node of the current node\n        while (current !== null) {\n            stack.push(current);\n            current = current.left;\n        }\n\n        // Current must be null at this point, meaning we've gone as far left as possible\n        current = stack.pop();\n        result.push(current.val);\n\n        // Traverse right subtree\n        current = current.right;\n    }\n\n    return result;\n};"}}}
{"leetcodeId":87,"title":"Scramble String","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar isScramble = function(s1, s2) {\n    \n};\n","python":"class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        pass\n","typescript":"function isScramble(s1: string, s2: string): boolean {\n\n};\n"},"testCases":[{"input":"\"great\"\n\"rgeat\"","expectedOutput":true,"isHidden":false},{"input":"\"abcde\"\n\"caebd\"","expectedOutput":false,"isHidden":false},{"input":"\"a\"\n\"a\"","expectedOutput":true,"isHidden":false},{"input":"\"ab\"\n\"ba\"","expectedOutput":true,"isHidden":true},{"input":"\"ab\"\n\"ab\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"bca\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"acb\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"cab\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"bac\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"cba\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"xya\"","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar isScramble = function(s1, s2) {\n    if (s1.length !== s2.length) {\n        return false;\n    }\n    if (s1 === s2) {\n        return true;\n    }\n\n    const n = s1.length;\n\n    // Check if s1 and s2 have the same characters with the same counts\n    // This is an optimization to prune impossible cases early\n    const charCount = new Array(26).fill(0);\n    for (let i = 0; i < n; i++) {\n        charCount[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        charCount[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;\n    }\n    for (let i = 0; i < 26; i++) {\n        if (charCount[i] !== 0) {\n            return false;\n        }\n    }\n\n    // Dynamic Programming with memoization\n    // dp[len][i][j] will store whether s1[i...i+len-1] is a scramble of s2[j...j+len-1]\n    // Initialize with undefined to distinguish from false\n    const memo = new Map();\n\n    function solve(subS1, subS2) {\n        if (subS1 === subS2) {\n            return true;\n        }\n        if (subS1.length === 1) {\n            return false;\n        }\n\n        const key = subS1 + '#' + subS2;\n        if (memo.has(key)) {\n            return memo.get(key);\n        }\n\n        const len = subS1.length;\n\n        // Check character counts for current substrings as well\n        const currentCounts = new Array(26).fill(0);\n        for (let i = 0; i < len; i++) {\n            currentCounts[subS1.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n            currentCounts[subS2.charCodeAt(i) - 'a'.charCodeAt(0)]--;\n        }\n        for (let i = 0; i < 26; i++) {\n            if (currentCounts[i] !== 0) {\n                memo.set(key, false);\n                return false;\n            }\n        }\n\n        for (let i = 1; i < len; i++) { // i is the split point\n            // Case 1: No swap\n            // s1 = s1[0...i-1] + s1[i...len-1]\n            // s2 = s2[0...i-1] + s2[i...len-1]\n            if (solve(subS1.substring(0, i), subS2.substring(0, i)) &&\n                solve(subS1.substring(i), subS2.substring(i))) {\n                memo.set(key, true);\n                return true;\n            }\n\n            // Case 2: Swap\n            // s1 = s1[0...i-1] + s1[i...len-1]\n            // s2 = s2[len-i...len-1] + s2[0...len-i-1]\n            if (solve(subS1.substring(0, i), subS2.substring(len - i)) &&\n                solve(subS1.substring(i), subS2.substring(0, len - i))) {\n                memo.set(key, true);\n                return true;\n            }\n        }\n\n        memo.set(key, false);\n        return false;\n    }\n\n    return solve(s1, s2);\n};\n"}}}
{"leetcodeId":92,"title":"Reverse Linked List II","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nvar reverseBetween = function(head, left, right) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nfunction reverseBetween(head: ListNode | null, left: number, right: number): ListNode | null {\n\n};"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}\n2\n4","expectedOutput":"{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":5,\"next\":null}\n1\n1","expectedOutput":"{\"val\":5,\"next\":null}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}\n1\n5","expectedOutput":"{\"val\":5,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":null}}}}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}\n1\n2","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":3,\"next\":null}}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}\n2\n3","expectedOutput":"{\"val\":1,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nvar reverseBetween = function(head, left, right) {\n    if (!head || left === right) {\n        return head;\n    }\n\n    // Create a dummy node to handle cases where the head is reversed\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n\n    // Move 'prev' to the node just before the 'left' position\n    for (let i = 0; i < left - 1; i++) {\n        prev = prev.next;\n    }\n\n    // 'current' will be the first node of the sublist to be reversed\n    // 'tail' will be the last node of the sublist to be reversed (after reversal, it will be the first)\n    let current = prev.next;\n    let tail = current;\n    let nextNode = null;\n\n    // Reverse the sublist from 'left' to 'right'\n    // This is a standard linked list reversal, but we only do it for (right - left + 1) nodes\n    let reversedHead = null;\n    for (let i = 0; i < right - left + 1; i++) {\n        nextNode = current.next;\n        current.next = reversedHead;\n        reversedHead = current;\n        current = nextNode;\n    }\n\n    // Connect the parts:\n    // 1. The node before the reversed sublist points to the new head of the reversed sublist\n    prev.next = reversedHead;\n    // 2. The original 'tail' (which is now the end of the reversed sublist) points to the node after the reversed sublist\n    tail.next = current;\n\n    return dummy.next;\n};"}}}
{"leetcodeId":96,"title":"Unique Binary Search Trees","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n    \n};","python":"def numTrees(n: int) -> int:\n    pass","typescript":"function numTrees(n: number): number {\n\n};"},"testCases":[{"input":"3","expectedOutput":5,"isHidden":false},{"input":"1","expectedOutput":1,"isHidden":false},{"input":"2","expectedOutput":2,"isHidden":true},{"input":"4","expectedOutput":14,"isHidden":true},{"input":"19","expectedOutput":1767263190,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n    // dp[i] will store the number of unique BSTs for i nodes.\n    // Initialize dp array with size n + 1 and fill with 0s.\n    const dp = new Array(n + 1).fill(0);\n\n    // Base cases:\n    // There is 1 way to form an empty BST (0 nodes).\n    dp[0] = 1;\n    // There is 1 way to form a BST with 1 node.\n    dp[1] = 1;\n\n    // Fill dp array for i from 2 to n\n    for (let i = 2; i <= n; i++) {\n        // To calculate dp[i], we consider each number j from 1 to i as the root.\n        // If j is the root, then there are j-1 nodes in the left subtree\n        // and i-j nodes in the right subtree.\n        // The number of unique BSTs with j as root is dp[j-1] * dp[i-j].\n        // Sum these up for all possible roots j.\n        for (let j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n\n    // The result is the number of unique BSTs for n nodes.\n    return dp[n];\n};"}}}
{"leetcodeId":103,"title":"Binary Tree Zigzag Level Order Traversal","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction zigzagLevelOrder(root) {\n  // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import deque\n\ndef zigzag_level_order(root: TreeNode) -> list[list[int]]:\n    # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction zigzagLevelOrder(root: TreeNode | null): number[][] {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":3,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":"[[3],[20,9],[15,7]]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"[[1]]","isHidden":false},{"input":"null","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null}}}","expectedOutput":"[[1],[3,2],[4,5]]","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":3,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":null}}","expectedOutput":"[[1],[3,2],[4,5]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction zigzagLevelOrder(root) {\n    if (!root) {\n        return [];\n    }\n\n    const result = [];\n    const queue = [root];\n    let leftToRight = true;\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n\n            if (leftToRight) {\n                currentLevel.push(node.val);\n            } else {\n                currentLevel.unshift(node.val);\n            }\n\n            if (node.left) {\n                queue.push(node.left);\n            }\n            if (node.right) {\n                queue.push(node.right);\n            }\n        }\n        result.push(currentLevel);\n        leftToRight = !leftToRight;\n    }\n\n    return result;\n}"}}}
{"leetcodeId":104,"title":"Maximum Depth of Binary Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nfunction maxDepth(root) {\n  // Implement your solution here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Implement your solution here\n        pass","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param root: TreeNode | null\n * @return number\n */\nfunction maxDepth(root: TreeNode | null): number {\n  // Implement your solution here\n}"},"testCases":[{"input":"{\"val\":3,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":3,"isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":2,"isHidden":false},{"input":"null","expectedOutput":0,"isHidden":false},{"input":"{\"val\":0,\"left\":null,\"right\":null}","expectedOutput":1,"isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":{\"val\":4,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":null},\"right\":null}","expectedOutput":5,"isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null}}}}}","expectedOutput":5,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nfunction maxDepth(root) {\n  if (!root) {\n    return 0;\n  }\n\n  const leftDepth = maxDepth(root.left);\n  const rightDepth = maxDepth(root.right);\n\n  return Math.max(leftDepth, rightDepth) + 1;\n}"}}}
{"leetcodeId":101,"title":"Symmetric Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSymmetric(root: TreeNode | null): boolean {\n\n};"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}","expectedOutput":"true","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":null}}}","expectedOutput":"false","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"true","isHidden":true},{"input":"null","expectedOutput":"true","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"false","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null},\"right\":{\"val\":2,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":null}}}","expectedOutput":"true","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function(root) {\n    if (!root) {\n        return true;\n    }\n\n    function isMirror(node1, node2) {\n        // If both nodes are null, they are symmetric\n        if (!node1 && !node2) {\n            return true;\n        }\n        // If one of the nodes is null or their values are different, they are not symmetric\n        if (!node1 || !node2 || node1.val !== node2.val) {\n            return false;\n        }\n\n        // Recursively check if the left subtree of node1 is a mirror of the right subtree of node2,\n        // AND the right subtree of node1 is a mirror of the left subtree of node2.\n        return isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\n    }\n\n    // The tree is symmetric if its left and right subtrees are mirrors of each other.\n    return isMirror(root.left, root.right);\n};"}}}
{"leetcodeId":100,"title":"Same Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nfunction isSameTree(p, q) {\n    // Implement your solution here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        # Implement your solution here\n        pass","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param p {TreeNode | null}\n * @param q {TreeNode | null}\n * @return {boolean}\n */\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    // Implement your solution here\n}"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}\n{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}","expectedOutput":true,"isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":false,"isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":1,\"left\":null,\"right\":null}}\n{\"val\":1,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":false,"isHidden":false},{"input":"null\nnull","expectedOutput":true,"isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null}\nnull","expectedOutput":false,"isHidden":true},{"input":"null\n{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":false,"isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null},\"right\":null}\n{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null},\"right\":null}","expectedOutput":true,"isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}\n{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nfunction isSameTree(p, q) {\n    // If both are null, they are the same\n    if (!p && !q) {\n        return true;\n    }\n    // If one is null and the other is not, they are different\n    if (!p || !q) {\n        return false;\n    }\n    // If their values are different, they are different\n    if (p.val !== q.val) {\n        return false;\n    }\n    // Recursively check left and right subtrees\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}"}}}
{"leetcodeId":98,"title":"Validate Binary Search Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    \n};\n","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        \n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode | null} root\n * @return {boolean}\n */\nfunction isValidBST(root: TreeNode | null): boolean {\n\n};\n"},"testCases":[{"input":"{\"val\":2,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}","expectedOutput":true,"isHidden":false},{"input":"{\"val\":5,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":6,\"left\":null,\"right\":null}}}","expectedOutput":false,"isHidden":false},{"input":"null","expectedOutput":true,"isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":true,"isHidden":true},{"input":"{\"val\":2147483647,\"left\":null,\"right\":null}","expectedOutput":true,"isHidden":true},{"input":"{\"val\":-2147483648,\"left\":null,\"right\":null}","expectedOutput":true,"isHidden":true},{"input":"{\"val\":5,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":6,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":false,"isHidden":true},{"input":"{\"val\":3,\"left\":{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}},\"right\":{\"val\":5,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":6,\"left\":null,\"right\":null}}}","expectedOutput":true,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    function validate(node, min, max) {\n        if (!node) {\n            return true;\n        }\n\n        if ((min !== null && node.val <= min) || (max !== null && node.val >= max)) {\n            return false;\n        }\n\n        return validate(node.left, min, node.val) && validate(node.right, node.val, max);\n    }\n\n    return validate(root, null, null);\n};\n"}}}
{"leetcodeId":102,"title":"Binary Tree Level Order Traversal","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction levelOrder(root) {\n    // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import deque\n\ndef level_order(root: TreeNode) -> list[list[int]]:\n    # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode | null} root\n * @return {number[][]}\n */\nfunction levelOrder(root: TreeNode | null): number[][] {\n    // Your code here\n}"},"testCases":[{"input":"{\"val\":3,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":"[[3],[9,20],[15,7]]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"[[1]]","isHidden":false},{"input":"null","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null}}}","expectedOutput":"[[1],[2,3],[4,5]]","isHidden":true},{"input":"{\"val\":10,\"left\":{\"val\":5,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}},\"right\":{\"val\":15,\"left\":null,\"right\":{\"val\":18,\"left\":null,\"right\":null}}}","expectedOutput":"[[10],[5,15],[3,7,18]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction levelOrder(root) {\n    if (!root) {\n        return [];\n    }\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevelNodes = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            currentLevelNodes.push(node.val);\n\n            if (node.left) {\n                queue.push(node.left);\n            }\n            if (node.right) {\n                queue.push(node.right);\n            }\n        }\n        result.push(currentLevelNodes);\n    }\n\n    return result;\n}"}}}
{"leetcodeId":105,"title":"Construct Binary Tree from Preorder and Inorder Traversal","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nfunction buildTree(preorder, inorder) {\n  // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n    # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val)\n        this.left = (left===undefined ? null : left)\n        this.right = (right===undefined ? null : right)\n    }\n}\n\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n    // Your code here\n}"},"testCases":[{"input":"[3,9,20,15,7]\n[9,3,15,20,7]","expectedOutput":[3,9,20,null,null,15,7],"isHidden":false},{"input":"[-1]\n[-1]","expectedOutput":[-1],"isHidden":false},{"input":"[1,2,3]\n[3,2,1]","expectedOutput":[1,2,null,null,3],"isHidden":true},{"input":"[1,2,3]\n[1,2,3]","expectedOutput":[1,null,2,null,null,null,3],"isHidden":true},{"input":"[1]\n[1]","expectedOutput":[1],"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nfunction buildTree(preorder, inorder) {\n    if (!preorder.length || !inorder.length) {\n        return null;\n    }\n\n    const rootVal = preorder[0];\n    const root = new TreeNode(rootVal);\n    const mid = inorder.indexOf(rootVal);\n\n    root.left = buildTree(\n        preorder.slice(1, mid + 1),\n        inorder.slice(0, mid)\n    );\n    root.right = buildTree(\n        preorder.slice(mid + 1),\n        inorder.slice(mid + 1)\n    );\n\n    return root;\n}"}}}
{"leetcodeId":99,"title":"Recover Binary Search Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar recoverTree = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {void}\n */\nfunction recoverTree(root: TreeNode | null): void {\n\n};"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":3,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}},\"right\":null}","expectedOutput":"{\"val\":3,\"left\":{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}},\"right\":null}","isHidden":false},{"input":"{\"val\":3,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}}","expectedOutput":"{\"val\":2,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}","isHidden":false},{"input":"{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":1,\"left\":null,\"right\":null}}","expectedOutput":"{\"val\":2,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}","isHidden":true},{"input":"{\"val\":0,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null}","isHidden":true},{"input":"{\"val\":10,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":{\"val\":15,\"left\":{\"val\":13,\"left\":null,\"right\":null},\"right\":{\"val\":12,\"left\":null,\"right\":null}}}","expectedOutput":"{\"val\":10,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":{\"val\":15,\"left\":{\"val\":12,\"left\":null,\"right\":null},\"right\":{\"val\":13,\"left\":null,\"right\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar recoverTree = function(root) {\n    let first = null;\n    let second = null;\n    let prev = null;\n\n    function inorder(node) {\n        if (!node) {\n            return;\n        }\n\n        inorder(node.left);\n\n        if (prev && node.val < prev.val) {\n            if (!first) {\n                first = prev;\n            }\n            second = node;\n        }\n        prev = node;\n\n        inorder(node.right);\n    }\n\n    inorder(root);\n\n    // Swap the values of the two misplaced nodes\n    if (first && second) {\n        const temp = first.val;\n        first.val = second.val;\n        second.val = temp;\n    }\n};"}}}
{"leetcodeId":97,"title":"Interleaving String","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s1\n * @param {string} s2\n * @param {string} s3\n * @return {boolean}\n */\nvar isInterleave = function(s1, s2, s3) {\n    \n};","python":"def isInterleave(s1: str, s2: str, s3: str) -> bool:\n    pass","typescript":"function isInterleave(s1: string, s2: string, s3: string): boolean {\n\n};"},"testCases":[{"input":"\"aabcc\"\n\"dbbca\"\n\"aadbbcbcac\"","expectedOutput":"true","isHidden":false},{"input":"\"aabcc\"\n\"dbbca\"\n\"aadbbbaccc\"","expectedOutput":"false","isHidden":false},{"input":"\"\"\n\"\"\n\"\"","expectedOutput":"true","isHidden":false},{"input":"\"a\"\n\"b\"\n\"ab\"","expectedOutput":"true","isHidden":true},{"input":"\"a\"\n\"b\"\n\"ba\"","expectedOutput":"true","isHidden":true},{"input":"\"a\"\n\"b\"\n\"ac\"","expectedOutput":"false","isHidden":true},{"input":"\"abc\"\n\"def\"\n\"adbecf\"","expectedOutput":"true","isHidden":true},{"input":"\"abc\"\n\"def\"\n\"abdecf\"","expectedOutput":"true","isHidden":true},{"input":"\"abc\"\n\"def\"\n\"adcbef\"","expectedOutput":"false","isHidden":true},{"input":"\"\"\n\"a\"\n\"a\"","expectedOutput":"true","isHidden":true},{"input":"\"a\"\n\"\"\n\"a\"","expectedOutput":"true","isHidden":true},{"input":"\"a\"\n\"\"\n\"b\"","expectedOutput":"false","isHidden":true},{"input":"\"aa\"\n\"ab\"\n\"abaa\"","expectedOutput":"false","isHidden":true},{"input":"\"aa\"\n\"ab\"\n\"aaba\"","expectedOutput":"true","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s1\n * @param {string} s2\n * @param {string} s3\n * @return {boolean}\n */\nvar isInterleave = function(s1, s2, s3) {\n    const n1 = s1.length;\n    const n2 = s2.length;\n    const n3 = s3.length;\n\n    if (n1 + n2 !== n3) {\n        return false;\n    }\n\n    // dp[i][j] will be true if s3[0...i+j-1] is an interleaving of s1[0...i-1] and s2[0...j-1]\n    // dp array size (n1 + 1) x (n2 + 1)\n    const dp = Array(n1 + 1).fill(false).map(() => Array(n2 + 1).fill(false));\n\n    // Base case: empty s1, empty s2, empty s3\n    dp[0][0] = true;\n\n    // Fill first row (s1 is empty)\n    for (let j = 1; j <= n2; j++) {\n        dp[0][j] = dp[0][j - 1] && (s2[j - 1] === s3[j - 1]);\n    }\n\n    // Fill first column (s2 is empty)\n    for (let i = 1; i <= n1; i++) {\n        dp[i][0] = dp[i - 1][0] && (s1[i - 1] === s3[i - 1]);\n    }\n\n    // Fill the rest of the DP table\n    for (let i = 1; i <= n1; i++) {\n        for (let j = 1; j <= n2; j++) {\n            // Check if s3[i+j-1] matches s1[i-1] AND s3[0...i+j-2] is an interleaving of s1[0...i-2] and s2[0...j-1]\n            const fromS1 = dp[i - 1][j] && (s1[i - 1] === s3[i + j - 1]);\n            // Check if s3[i+j-1] matches s2[j-1] AND s3[0...i+j-2] is an interleaving of s1[0...i-1] and s2[0...j-2]\n            const fromS2 = dp[i][j - 1] && (s2[j - 1] === s3[i + j - 1]);\n            \n            dp[i][j] = fromS1 || fromS2;\n        }\n    }\n\n    return dp[n1][n2];\n};"}}}
{"leetcodeId":112,"title":"Path Sum","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function(root, targetSum) {\n    \n};\n","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        \n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction hasPathSum(root: TreeNode | null, targetSum: number): boolean {\n\n};\n"},"testCases":[{"input":"{\"val\":5,\"left\":{\"val\":4,\"left\":{\"val\":11,\"left\":{\"val\":7,\"left\":null,\"right\":null},\"right\":{\"val\":2,\"left\":null,\"right\":null}},\"right\":null},\"right\":{\"val\":8,\"left\":{\"val\":13,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":1,\"left\":null,\"right\":null}}}}\n22","expectedOutput":"true","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}\n5","expectedOutput":"false","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}\n0","expectedOutput":"false","isHidden":false},{"input":"null\n0","expectedOutput":"false","isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null}\n1","expectedOutput":"true","isHidden":true},{"input":"{\"val\":-2,\"left\":null,\"right\":{\"val\":-3,\"left\":null,\"right\":null}}\n-5","expectedOutput":"true","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function(root, targetSum) {\n    if (!root) {\n        return false;\n    }\n\n    // If it's a leaf node, check if the current sum equals targetSum\n    if (!root.left && !root.right) {\n        return targetSum === root.val;\n    }\n\n    // Recursively check left and right subtrees\n    // Subtract current node's value from targetSum for the next level\n    const remainingSum = targetSum - root.val;\n    \n    return hasPathSum(root.left, remainingSum) || hasPathSum(root.right, remainingSum);\n};\n"}}}
{"leetcodeId":111,"title":"Minimum Depth of Binary Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function(root) {\n    \n};\n","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        \n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction minDepth(root: TreeNode | null): number {\n\n};\n"},"testCases":[{"input":"{\"val\":3,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":2,"isHidden":false},{"input":"{\"val\":2,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}}","expectedOutput":5,"isHidden":false},{"input":"null","expectedOutput":0,"isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":1,"isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null},\"right\":null}","expectedOutput":3,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n\n    // If only one child exists, we must go down that path\n    // because the other path doesn't lead to a leaf.\n    // A leaf is a node with NO children.\n    if (!root.left) {\n        return 1 + minDepth(root.right);\n    }\n    if (!root.right) {\n        return 1 + minDepth(root.left);\n    }\n\n    // If both children exist, take the minimum of the two paths\n    return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n};\n"}}}
{"leetcodeId":110,"title":"Balanced Binary Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isBalanced = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nfunction isBalanced(root: TreeNode | null): boolean {\n\n};"},"testCases":[{"input":"{\"val\":3,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":true,"isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":2,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":4,\"left\":null,\"right\":null}}}}","expectedOutput":false,"isHidden":false},{"input":"null","expectedOutput":true,"isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":true,"isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":true,"isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null},\"right\":null}","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isBalanced = function(root) {\n    function checkHeight(node) {\n        if (!node) {\n            return 0;\n        }\n\n        let leftHeight = checkHeight(node.left);\n        if (leftHeight === -1) {\n            return -1;\n        }\n\n        let rightHeight = checkHeight(node.right);\n        if (rightHeight === -1) {\n            return -1;\n        }\n\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        }\n\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    return checkHeight(root) !== -1;\n};"}}}
{"leetcodeId":113,"title":"Path Sum II","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number[][]}\n */\nfunction pathSum(root, targetSum) {\n    // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef path_sum(root: TreeNode, target_sum: int) -> list[list[int]]:\n    # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pathSum(root: TreeNode | null, targetSum: number): number[][] {\n    // Your code here\n}"},"testCases":[{"input":"{\"val\":5,\"left\":{\"val\":4,\"left\":{\"val\":11,\"left\":{\"val\":7,\"left\":null,\"right\":null},\"right\":{\"val\":2,\"left\":null,\"right\":null}},\"right\":null},\"right\":{\"val\":8,\"left\":{\"val\":13,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":{\"val\":1,\"left\":null,\"right\":null}}}}\n22","expectedOutput":"[[5,4,11,2],[5,8,4,5]]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}\n5","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}\n0","expectedOutput":"[]","isHidden":false},{"input":"null\n0","expectedOutput":"[]","isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null}\n1","expectedOutput":"[[1]]","isHidden":true},{"input":"{\"val\":-2,\"left\":null,\"right\":{\"val\":-3,\"left\":null,\"right\":null}}\n-5","expectedOutput":"[[-2,-3]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number[][]}\n */\nfunction pathSum(root, targetSum) {\n    const result = [];\n\n    function dfs(node, currentPath, currentSum) {\n        if (!node) {\n            return;\n        }\n\n        currentPath.push(node.val);\n        currentSum += node.val;\n\n        // Check if it's a leaf node\n        if (!node.left && !node.right) {\n            if (currentSum === targetSum) {\n                result.push([...currentPath]); // Add a copy of the path\n            }\n        }\n\n        // Recurse on left and right children\n        dfs(node.left, currentPath, currentSum);\n        dfs(node.right, currentPath, currentSum);\n\n        // Backtrack: remove the current node from the path\n        currentPath.pop();\n    }\n\n    dfs(root, [], 0);\n    return result;\n}"}}}
{"leetcodeId":115,"title":"Distinct Subsequences","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    \n};\n","python":"def numDistinct(s: str, t: str) -> int:\n    pass\n","typescript":"function numDistinct(s: string, t: string): number {\n\n};\n"},"testCases":[{"input":"\"rabbbit\"\n\"rabbit\"","expectedOutput":3,"isHidden":false},{"input":"\"babgbag\"\n\"bag\"","expectedOutput":5,"isHidden":false},{"input":"\"\"\n\"\"","expectedOutput":1,"isHidden":true},{"input":"\"a\"\n\"\"","expectedOutput":1,"isHidden":true},{"input":"\"\"\n\"a\"","expectedOutput":0,"isHidden":true},{"input":"\"abc\"\n\"abc\"","expectedOutput":1,"isHidden":true},{"input":"\"aaaaa\"\n\"aa\"","expectedOutput":10,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    const n = s.length;\n    const m = t.length;\n\n    // dp[i][j] represents the number of distinct subsequences of s[0...i-1] which equals t[0...j-1]\n    // dp array size will be (n+1) x (m+1)\n    const dp = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));\n\n    // Base case: An empty string t is a subsequence of any string s in 1 way (by deleting all characters of s).\n    // So, dp[i][0] = 1 for all i >= 0.\n    for (let i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n    }\n\n    // If s is empty but t is not, then dp[0][j] = 0 for j > 0. This is already handled by initialization to 0.\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            // If the characters s[i-1] and t[j-1] match\n            if (s[i - 1] === t[j - 1]) {\n                // We have two options:\n                // 1. Use s[i-1] to match t[j-1]: In this case, we need to find the number of distinct subsequences\n                //    of s[0...i-2] that equal t[0...j-2]. This is dp[i-1][j-1].\n                // 2. Don't use s[i-1] to match t[j-1]: In this case, we need to find the number of distinct subsequences\n                //    of s[0...i-2] that equal t[0...j-1]. This is dp[i-1][j].\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                // If the characters do not match, we must not use s[i-1] to match t[j-1].\n                // So, we need to find the number of distinct subsequences of s[0...i-2] that equal t[0...j-1].\n                // This is dp[i-1][j].\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[n][m];\n};\n"}}}
{"leetcodeId":114,"title":"Flatten Binary Tree to Linked List","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar flatten = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nfunction flatten(root: TreeNode | null): void {\n\n};"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}","expectedOutput":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":false},{"input":"{\"val\":0,\"left\":null,\"right\":null}","expectedOutput":"{\"val\":0,\"left\":null,\"right\":null}","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar flatten = function(root) {\n    if (!root) {\n        return;\n    }\n\n    let current = root;\n\n    while (current) {\n        if (current.left) {\n            // Find the rightmost node in the left subtree\n            let rightmost = current.left;\n            while (rightmost.right) {\n                rightmost = rightmost.right;\n            }\n\n            // Attach the current right subtree to the rightmost node of the left subtree\n            rightmost.right = current.right;\n\n            // Move the left subtree to the right of the current node\n            current.right = current.left;\n\n            // Set the left child to null\n            current.left = null;\n        }\n        // Move to the next node in the flattened list (which is now current.right)\n        current = current.right;\n    }\n};"}}}
{"leetcodeId":107,"title":"Binary Tree Level Order Traversal II","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrderBottom = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction levelOrderBottom(root: TreeNode | null): number[][] {\n\n};"},"testCases":[{"input":"{\"val\":3,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":"[[15,7],[9,20],[3]]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"[[1]]","isHidden":false},{"input":"null","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null}}}","expectedOutput":"[[4,5],[2,3],[1]]","isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":"[[2],[1]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrderBottom = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            currentLevel.push(node.val);\n\n            if (node.left) {\n                queue.push(node.left);\n            }\n            if (node.right) {\n                queue.push(node.right);\n            }\n        }\n        result.unshift(currentLevel); // Add to the beginning for bottom-up\n    }\n\n    return result;\n};"}}}
{"leetcodeId":108,"title":"Convert Sorted Array to Binary Search Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nfunction sortedArrayToBST(nums) {\n  // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: list[int]) -> \"TreeNode\":\n        # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n  // Your code here\n}"},"testCases":[{"input":"[-10,-3,0,5,9]","expectedOutput":{"val":0,"left":{"val":-3,"left":{"val":-10,"left":null,"right":null},"right":null},"right":{"val":9,"left":{"val":5,"left":null,"right":null},"right":null}},"isHidden":false},{"input":"[1,3]","expectedOutput":{"val":3,"left":{"val":1,"left":null,"right":null},"right":null},"isHidden":false},{"input":"[]","expectedOutput":null,"isHidden":true},{"input":"[0]","expectedOutput":{"val":0,"left":null,"right":null},"isHidden":true},{"input":"[1,2,3,4,5,6,7]","expectedOutput":{"val":4,"left":{"val":2,"left":{"val":1,"left":null,"right":null},"right":{"val":3,"left":null,"right":null}},"right":{"val":6,"left":{"val":5,"left":null,"right":null},"right":{"val":7,"left":null,"right":null}}},"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nfunction sortedArrayToBST(nums) {\n    if (!nums || nums.length === 0) {\n        return null;\n    }\n\n    function buildBST(left, right) {\n        if (left > right) {\n            return null;\n        }\n\n        const mid = Math.floor((left + right) / 2);\n        const root = new TreeNode(nums[mid]);\n\n        root.left = buildBST(left, mid - 1);\n        root.right = buildBST(mid + 1, right);\n\n        return root;\n    }\n\n    return buildBST(0, nums.length - 1);\n}\n\n// Helper TreeNode class for local testing (LeetCode provides this)\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n}"}}}
{"leetcodeId":106,"title":"Construct Binary Tree from Inorder and Postorder Traversal","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nfunction buildTree(inorder, postorder) {\n  // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n    # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val)\n        this.left = (left===undefined ? null : left)\n        this.right = (right===undefined ? null : right)\n    }\n}\n\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nfunction buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n    // Your code here\n}"},"testCases":[{"input":"[9,3,15,20,7]\n[9,15,7,20,3]","expectedOutput":"{\"val\":3,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","isHidden":false},{"input":"[-1]\n[-1]","expectedOutput":"{\"val\":-1,\"left\":null,\"right\":null}","isHidden":false},{"input":"[1,2]\n[2,1]","expectedOutput":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","isHidden":true},{"input":"[2,1]\n[2,1]","expectedOutput":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","isHidden":true},{"input":"[1,2,3,4,5,6,7]\n[1,3,2,5,7,6,4]","expectedOutput":"{\"val\":4,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}},\"right\":{\"val\":6,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nfunction buildTree(inorder, postorder) {\n    if (!inorder.length || !postorder.length) {\n        return null;\n    }\n\n    const rootVal = postorder[postorder.length - 1];\n    const root = new TreeNode(rootVal);\n\n    const rootIndexInInorder = inorder.indexOf(rootVal);\n\n    const leftInorder = inorder.slice(0, rootIndexInInorder);\n    const rightInorder = inorder.slice(rootIndexInInorder + 1);\n\n    const leftPostorder = postorder.slice(0, leftInorder.length);\n    const rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\n\n    root.left = buildTree(leftInorder, leftPostorder);\n    root.right = buildTree(rightInorder, rightPostorder);\n\n    return root;\n}"}}}
{"leetcodeId":109,"title":"Convert Sorted List to Binary Search Tree","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nfunction sortedListToBST(head) {\n  // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":-10,\"next\":{\"val\":-3,\"next\":{\"val\":0,\"next\":{\"val\":5,\"next\":{\"val\":9,\"next\":null}}}}}","expectedOutput":"{\"val\":0,\"left\":{\"val\":-3,\"left\":{\"val\":-10,\"left\":null,\"right\":null},\"right\":null},\"right\":{\"val\":9,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":null}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":false},{"input":"{\"val\":0,\"next\":null}","expectedOutput":"{\"val\":0,\"left\":null,\"right\":null}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":3,\"next\":null}}","expectedOutput":"{\"val\":3,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":null}","isHidden":false},{"input":"{\"val\":-1,\"next\":null}","expectedOutput":"{\"val\":-1,\"left\":null,\"right\":null}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","expectedOutput":"{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":null},\"right\":{\"val\":5,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":null}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nfunction sortedListToBST(head) {\n    if (!head) {\n        return null;\n    }\n\n    // Helper function to find the middle of a linked list segment\n    function findMiddle(start, end) {\n        let slow = start;\n        let fast = start;\n        let prev = null;\n\n        while (fast !== end && fast.next !== end) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return [prev, slow]; // prev is node before middle, slow is middle\n    }\n\n    // Recursive helper function to build the BST\n    function buildBST(start, end) {\n        if (start === end) {\n            return null;\n        }\n\n        const [prev, middle] = findMiddle(start, end);\n\n        const root = new TreeNode(middle.val);\n\n        // If prev is null, it means middle is the start, so left subtree is from start to middle\n        // Otherwise, left subtree is from start to prev.next (which is middle)\n        root.left = buildBST(start, middle);\n\n        root.right = buildBST(middle.next, end);\n\n        return root;\n    }\n\n    return buildBST(head, null);\n}"}}}
{"leetcodeId":121,"title":"Best Time to Buy and Sell Stock","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n\n};","python":"def max_profit(prices: list[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} prices\n * @return {number}\n */\nfunction maxProfit(prices: number[]): number {\n\n};"},"testCases":[{"input":"[7,1,5,3,6,4]","expectedOutput":5,"isHidden":false},{"input":"[7,6,4,3,1]","expectedOutput":0,"isHidden":false},{"input":"[1,2]","expectedOutput":1,"isHidden":true},{"input":"[2,1]","expectedOutput":0,"isHidden":true},{"input":"[1]","expectedOutput":0,"isHidden":true},{"input":"[2,4,1]","expectedOutput":2,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let minPrice = Infinity;\n    let maxProfit = 0;\n\n    for (let i = 0; i < prices.length; i++) {\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } else if (prices[i] - minPrice > maxProfit) {\n            maxProfit = prices[i] - minPrice;\n        }\n    }\n\n    return maxProfit;\n};"}}}
{"leetcodeId":122,"title":"Best Time to Buy and Sell Stock II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};","python":"class Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        pass","typescript":"function maxProfit(prices: number[]): number {\n\n};"},"testCases":[{"input":"[7,1,5,3,6,4]","expectedOutput":7,"isHidden":false},{"input":"[1,2,3,4,5]","expectedOutput":4,"isHidden":false},{"input":"[7,6,4,3,1]","expectedOutput":0,"isHidden":false},{"input":"[1]","expectedOutput":0,"isHidden":true},{"input":"[1,2]","expectedOutput":1,"isHidden":true},{"input":"[2,1]","expectedOutput":0,"isHidden":true},{"input":"[0,0,0,0,0]","expectedOutput":0,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let totalProfit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            totalProfit += prices[i] - prices[i - 1];\n        }\n    }\n    return totalProfit;\n};"}}}
{"leetcodeId":125,"title":"Valid Palindrome","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function(s) {\n    \n};\n","python":"def isPalindrome(s: str) -> bool:\n    pass\n","typescript":"function isPalindrome(s: string): boolean {\n\n};\n"},"testCases":[{"input":"\"A man, a plan, a canal: Panama\"","expectedOutput":true,"isHidden":false},{"input":"\"race a car\"","expectedOutput":false,"isHidden":false},{"input":"\" \"","expectedOutput":true,"isHidden":true},{"input":"\"a.\"","expectedOutput":true,"isHidden":true},{"input":"\"0P\"","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function(s) {\n    let left = 0;\n    let right = s.length - 1;\n\n    while (left < right) {\n        // Move left pointer past non-alphanumeric characters\n        while (left < right && !isAlphaNumeric(s[left])) {\n            left++;\n        }\n        // Move right pointer past non-alphanumeric characters\n        while (left < right && !isAlphaNumeric(s[right])) {\n            right--;\n        }\n\n        // Compare characters (case-insensitive)\n        if (left < right && s[left].toLowerCase() !== s[right].toLowerCase()) {\n            return false;\n        }\n\n        left++;\n        right--;\n    }\n\n    return true;\n};\n\nfunction isAlphaNumeric(char) {\n    const code = char.charCodeAt(0);\n    return (\n        (code >= 48 && code <= 57) || // numeric (0-9)\n        (code >= 65 && code <= 90) || // upper alpha (A-Z)\n        (code >= 97 && code <= 122)   // lower alpha (a-z)\n    );\n}\n"}}}
{"leetcodeId":120,"title":"Triangle","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n\n};","python":"from typing import List\n\n\ndef minimum_total(triangle: List[List[int]]) -> int:\n    pass","typescript":"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nfunction minimumTotal(triangle: number[][]): number {\n\n};"},"testCases":[{"input":"[[2],[3,4],[6,5,7],[4,1,8,3]]","expectedOutput":11,"isHidden":false},{"input":"[[-10]]","expectedOutput":-10,"isHidden":false},{"input":"[[1],[2,3]]","expectedOutput":3,"isHidden":true},{"input":"[[1],[10,10],[1,1,1]]","expectedOutput":3,"isHidden":true},{"input":"[[1],[10,2],[1,1,100]]","expectedOutput":4,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n    const n = triangle.length;\n    if (n === 0) {\n        return 0;\n    }\n\n    // Start from the second to last row and move upwards\n    // Modify the triangle in-place or use a DP array of size n\n    // For O(n) space, we can use a single array representing the current row's minimums\n    // Let's use the O(n) space approach by modifying the last row as our DP array\n\n    // Initialize dp with the last row of the triangle\n    let dp = [...triangle[n - 1]];\n\n    // Iterate from the second to last row up to the first row\n    for (let r = n - 2; r >= 0; r--) {\n        // For each element in the current row 'r'\n        for (let c = 0; c <= r; c++) {\n            // The minimum path sum from this element is its value\n            // plus the minimum of the two adjacent elements in the row below (which are in dp)\n            dp[c] = triangle[r][c] + Math.min(dp[c], dp[c + 1]);\n        }\n    }\n\n    // The minimum total path sum will be at the first element of the dp array\n    // after processing all rows up to the top.\n    return dp[0];\n};"}}}
{"leetcodeId":123,"title":"Best Time to Buy and Sell Stock III","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};","python":"class Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        pass","typescript":"function maxProfit(prices: number[]): number {\n\n};"},"testCases":[{"input":"[3,3,5,0,0,3,1,4]","expectedOutput":6,"isHidden":false},{"input":"[1,2,3,4,5]","expectedOutput":4,"isHidden":false},{"input":"[7,6,4,3,1]","expectedOutput":0,"isHidden":false},{"input":"[1]","expectedOutput":0,"isHidden":false},{"input":"[2,1,4,5,2,2,3,1]","expectedOutput":4,"isHidden":true},{"input":"[8,6,4,3,3,2,3,5,8,3,8,2,6]","expectedOutput":10,"isHidden":true},{"input":"[1,2,4,2,5,7,2,4,9,0]","expectedOutput":13,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let buy1 = Infinity;\n    let profit1 = 0;\n    let buy2 = Infinity;\n    let profit2 = 0;\n\n    for (let price of prices) {\n        // First transaction\n        // buy1: minimum price to buy the first stock\n        buy1 = Math.min(buy1, price);\n        // profit1: maximum profit after selling the first stock\n        profit1 = Math.max(profit1, price - buy1);\n\n        // Second transaction\n        // buy2: minimum price to buy the second stock, considering profit from first transaction\n        // We want to maximize (price - buy2) which is equivalent to minimizing buy2\n        // buy2 = price - profit1 (effectively, the cost of buying the second stock is reduced by profit1)\n        buy2 = Math.min(buy2, price - profit1);\n        // profit2: maximum profit after selling the second stock\n        profit2 = Math.max(profit2, price - buy2);\n    }\n\n    return profit2;\n};"}}}
{"leetcodeId":119,"title":"Pascal's Triangle II","codingData":{"starterCode":{"javascript":"/**\n * @param {number} rowIndex\n * @return {number[]}\n */\nvar getRow = function(rowIndex) {\n    \n};","python":"from typing import List\n\ndef get_row(rowIndex: int) -> List[int]:\n    pass","typescript":"function getRow(rowIndex: number): number[] {\n\n};"},"testCases":[{"input":"3","expectedOutput":"[1,3,3,1]","isHidden":false},{"input":"0","expectedOutput":"[1]","isHidden":false},{"input":"1","expectedOutput":"[1,1]","isHidden":false},{"input":"2","expectedOutput":"[1,2,1]","isHidden":true},{"input":"5","expectedOutput":"[1,5,10,10,5,1]","isHidden":true},{"input":"33","expectedOutput":"[1,33,528,5456,40920,278256,1699110,9657700,49957220,233360620,999600000,3919999999,14137200000,46800000000,141372000000,391999999999,999600000000,2333606200000,4995722000000,9657700000000,16991100000000,27825600000000,40920000000000,54560000000000,52800000000000,33000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} rowIndex\n * @return {number[]}\n */\nvar getRow = function(rowIndex) {\n    let row = new Array(rowIndex + 1).fill(0);\n    row[0] = 1;\n\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i; j >= 1; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n\n    return row;\n};"}}}
{"leetcodeId":116,"title":"Populating Next Right Pointers in Each Node","codingData":{"starterCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, left, right, next) {\n *    this.val = val === undefined ? null : val;\n *    this.left = left === undefined ? null : left;\n *    this.right = right === undefined ? null : right;\n *    this.next = next === undefined ? null : next;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {Node}\n */\nvar connect = function(root) {\n    \n};\n","python":"# Definition for a Node.\n# class Node:\n#     def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n#         self.next = next\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        ","typescript":"/**\n * Definition for a Node.\n * class Node {\n *     val: number\n *     left: Node | null\n *     right: Node | null\n *     next: Node | null\n *     constructor(val?: number, left?: Node, right?: Node, next?: Node) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\ninterface Node { \n  val: number;\n  left: Node | null;\n  right: Node | null;\n  next: Node | null;\n}\n\nfunction connect(root: Node | null): Node | null {\n\n};\n"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":null},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"right\":{\"val\":3,\"left\":{\"val\":6,\"left\":null,\"right\":null,\"next\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null}","expectedOutput":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":null},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":6,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"next\":{\"val\":3,\"left\":{\"val\":6,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":{\"val\":6,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null,\"next\":null}","expectedOutput":"{\"val\":1,\"left\":null,\"right\":null,\"next\":null}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, left, right, next) {\n *    this.val = val === undefined ? null : val;\n *    this.left = left === undefined ? null : left;\n *    this.right = right === undefined ? null : right;\n *    this.next = next === undefined ? null : next;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {Node}\n */\nvar connect = function(root) {\n    if (!root) {\n        return null;\n    }\n\n    let leftmost = root;\n\n    while (leftmost.left) {\n        let current = leftmost;\n        while (current) {\n            // Connect left child to right child\n            current.left.next = current.right;\n\n            // Connect right child to the left child of the next node (if it exists)\n            if (current.next) {\n                current.right.next = current.next.left;\n            }\n            current = current.next;\n        }\n        leftmost = leftmost.left;\n    }\n\n    return root;\n};\n"}}}
{"leetcodeId":117,"title":"Populating Next Right Pointers in Each Node II","codingData":{"starterCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, left, right, next) {\n *    this.val = val === undefined ? null : val;\n *    this.left = left === undefined ? null : left;\n *    this.right = right === undefined ? null : right;\n *    this.next = next === undefined ? null : next;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {Node}\n */\nvar connect = function(root) {\n    \n};\n","python":"# Definition for a Node.\n# class Node:\n#     def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n#         self.next = next\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        \n","typescript":"/**\n * Definition for a Node.\n * class Node {\n *     val: number\n *     left: Node | null\n *     right: Node | null\n *     next: Node | null\n *     constructor(val?: number, left?: Node, right?: Node, next?: Node) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\ninterface Node { \n  val: number;\n  left: Node | null;\n  right: Node | null;\n  next: Node | null;\n}\n\nfunction connect(root: Node | null): Node | null {\n\n};\n"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":null},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null}","expectedOutput":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":null},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":null},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null,\"next\":null}","expectedOutput":"{\"val\":1,\"left\":null,\"right\":null,\"next\":null}","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null,\"next\":null},\"right\":null,\"next\":null}","expectedOutput":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null,\"next\":null},\"right\":null,\"next\":null}","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":null},\"right\":null,\"next\":null},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null}","expectedOutput":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":null},\"right\":null,\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, left, right, next) {\n *    this.val = val === undefined ? null : val;\n *    this.left = left === undefined ? null : left;\n *    this.right = right === undefined ? null : right;\n *    this.next = next === undefined ? null : next;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {Node}\n */\nvar connect = function(root) {\n    if (!root) {\n        return root;\n    }\n\n    let leftmost = root;\n\n    while (leftmost) {\n        let current = leftmost;\n        let prev = null;\n        let nextLeftmost = null;\n\n        while (current) {\n            // Process left child\n            if (current.left) {\n                if (prev) {\n                    prev.next = current.left;\n                }\n                if (!nextLeftmost) {\n                    nextLeftmost = current.left;\n                }\n                prev = current.left;\n            }\n\n            // Process right child\n            if (current.right) {\n                if (prev) {\n                    prev.next = current.right;\n                }\n                if (!nextLeftmost) {\n                    nextLeftmost = current.right;\n                }\n                prev = current.right;\n            }\n\n            current = current.next;\n        }\n        leftmost = nextLeftmost;\n    }\n\n    return root;\n};\n"}}}
{"leetcodeId":124,"title":"Binary Tree Maximum Path Sum","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    \n};\n","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxPathSum(root: TreeNode | null): number {\n\n};\n"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}","expectedOutput":6,"isHidden":false},{"input":"{\"val\":-10,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":20,\"left\":{\"val\":15,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":42,"isHidden":false},{"input":"{\"val\":-3,\"left\":null,\"right\":null}","expectedOutput":-3,"isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":-2,\"left\":{\"val\":1,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}},\"right\":{\"val\":-3,\"left\":{\"val\":-2,\"left\":null,\"right\":null},\"right\":null}}","expectedOutput":3,"isHidden":true},{"input":"{\"val\":5,\"left\":{\"val\":4,\"left\":{\"val\":11,\"left\":{\"val\":7,\"left\":null,\"right\":null},\"right\":{\"val\":2,\"left\":null,\"right\":null}},\"right\":null},\"right\":{\"val\":8,\"left\":{\"val\":13,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":1,\"left\":null,\"right\":null}}}}","expectedOutput":48,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    let maxSum = -Infinity;\n\n    /**\n     * Helper function to perform DFS and calculate max path sum ending at current node.\n     * @param {TreeNode} node The current node.\n     * @returns {number} The maximum path sum starting from `node` and going downwards (either left or right branch).\n     */\n    function dfs(node) {\n        if (!node) {\n            return 0;\n        }\n\n        // Recursively get the maximum path sum from the left and right children.\n        // We take 0 if the sum is negative, as we don't want to include negative paths.\n        let leftGain = Math.max(0, dfs(node.left));\n        let rightGain = Math.max(0, dfs(node.right));\n\n        // Calculate the path sum that *includes* the current node as the peak of a V-shape path.\n        // This path can go from left child -> current node -> right child.\n        // This value is a candidate for the global maximum path sum.\n        let currentPathSum = node.val + leftGain + rightGain;\n\n        // Update the global maximum path sum if the current path sum is greater.\n        maxSum = Math.max(maxSum, currentPathSum);\n\n        // Return the maximum path sum that can be extended upwards from the current node.\n        // This path must be a straight line (current node + one of its children's max gain).\n        return node.val + Math.max(leftGain, rightGain);\n    }\n\n    dfs(root);\n    return maxSum;\n};\n"}}}
{"leetcodeId":118,"title":"Pascal's Triangle","codingData":{"starterCode":{"javascript":"/**\n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function(numRows) {\n    \n};","python":"def generate(numRows: int) -> list[list[int]]:\n    pass","typescript":"/**\n * @param numRows\n * @return\n */\nfunction generate(numRows: number): number[][] {\n\n};"},"testCases":[{"input":"5","expectedOutput":"[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]","isHidden":false},{"input":"1","expectedOutput":"[[1]]","isHidden":false},{"input":"2","expectedOutput":"[[1],[1,1]]","isHidden":true},{"input":"3","expectedOutput":"[[1],[1,1],[1,2,1]]","isHidden":true},{"input":"30","expectedOutput":"[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,190680,293930,352716,352716,293930,190680,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,99688,230230,445740,735471,1144066,1352078,1352078,1144066,735471,445740,230230,99688,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,309400,610610,1081575,1771000,2496144,2704156,2496144,1771000,1081575,610610,309400,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,403700,817190,1490110,2496144,3764376,4457400,4807000,4457400,3764376,2496144,1490110,817190,403700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,531173,1104000,2042975,3473736,5311735,7054320,8436285,8436285,7054320,5311735,3473736,2042975,1104000,531173,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,690690,1458600,2740575,4807000,7726160,11100570,13884150,16130075,16130075,13884150,11100570,7726160,4807000,2740575,1458600,690690,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,380870,906192,1961256,3767400,6760390,11370000,16940000,22222222,25292525,27041560,27041560,25292525,22222222,16940000,11370000,6760390,3767400,1961256,906192,380870,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,480700,1184040,2641000,5200300,9586000,16796000,25945945,37000000,47502000,54627300,58000000,58000000,54627300,47502000,37000000,25945945,16796000,9586000,5200300,2641000,1184040,480700,118755,23751,3654,406,29,1],[1,30,435,4060,27405,142506,593775,1493000,3461040,7000000,13123110,23535820,37442160,55000000,73000000,90000000,100000000,100000000,90000000,73000000,55000000,37442160,23535820,13123110,7000000,3461040,1493000,593775,142506,27405,4060,435,30,1]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function(numRows) {\n    const triangle = [];\n\n    if (numRows === 0) {\n        return triangle;\n    }\n\n    // First row is always [1]\n    triangle.push([1]);\n\n    for (let i = 1; i < numRows; i++) {\n        const prevRow = triangle[i - 1];\n        const currentRow = [1]; // Each row starts with 1\n\n        for (let j = 1; j < i; j++) {\n            // Each element is the sum of the two elements directly above it\n            currentRow.push(prevRow[j - 1] + prevRow[j]);\n        }\n\n        currentRow.push(1); // Each row ends with 1\n        triangle.push(currentRow);\n    }\n\n    return triangle;\n};"}}}
{"leetcodeId":128,"title":"Longest Consecutive Sequence","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function(nums) {\n    \n};\n","python":"def longest_consecutive(nums: list[int]) -> int:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction longestConsecutive(nums: number[]): number {\n\n};\n"},"testCases":[{"input":"[100,4,200,1,3,2]","expectedOutput":4,"isHidden":false},{"input":"[0,3,7,2,5,8,4,6,0,1]","expectedOutput":9,"isHidden":false},{"input":"[]","expectedOutput":0,"isHidden":true},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[9,1,4,7,3,-1,0,5,8,-1,6]","expectedOutput":10,"isHidden":true},{"input":"[0, -1]","expectedOutput":2,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n\n    const numSet = new Set(nums);\n    let maxLength = 0;\n\n    for (const num of numSet) {\n        // Check if the current number is the start of a sequence\n        // i.e., num - 1 is not in the set\n        if (!numSet.has(num - 1)) {\n            let currentNum = num;\n            let currentLength = 1;\n\n            // While the next number in sequence exists, continue counting\n            while (numSet.has(currentNum + 1)) {\n                currentNum++;\n                currentLength++;\n            }\n\n            maxLength = Math.max(maxLength, currentLength);\n        }\n    }\n\n    return maxLength;\n};\n"}}}
{"leetcodeId":131,"title":"Palindrome Partitioning","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {string[][]}\n */\nvar partition = function(s) {\n    \n};\n","python":"def partition(s: str) -> list[list[str]]:\n    pass\n","typescript":"function partition(s: string): string[][] {\n\n};\n"},"testCases":[{"input":"\"aab\"","expectedOutput":"[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]","isHidden":false},{"input":"\"a\"","expectedOutput":"[[\"a\"]]","isHidden":false},{"input":"\"racecar\"","expectedOutput":"[[\"r\",\"a\",\"c\",\"e\",\"c\",\"a\",\"r\"],[\"r\",\"a\",\"cec\",\"a\",\"r\"],[\"r\",\"aceca\",\"r\"],[\"racecar\"]]","isHidden":true},{"input":"\"aaaa\"","expectedOutput":"[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]","isHidden":true},{"input":"\"abacaba\"","expectedOutput":"[[\"a\",\"b\",\"a\",\"c\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"c\",\"aba\"],[\"a\",\"b\",\"aca\",\"b\",\"a\"],[\"a\",\"b\",\"acaba\"],[\"a\",\"bacab\",\"a\"],[\"a\",\"bacaba\"],[\"aba\",\"c\",\"a\",\"b\",\"a\"],[\"aba\",\"c\",\"aba\"],[\"abacaba\"]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {string[][]}\n */\nvar partition = function(s) {\n    const result = [];\n    const currentPartition = [];\n\n    function isPalindrome(str) {\n        let left = 0;\n        let right = str.length - 1;\n        while (left < right) {\n            if (str[left] !== str[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    function backtrack(start) {\n        if (start === s.length) {\n            result.push([...currentPartition]);\n            return;\n        }\n\n        for (let i = start; i < s.length; i++) {\n            const substring = s.substring(start, i + 1);\n            if (isPalindrome(substring)) {\n                currentPartition.push(substring);\n                backtrack(i + 1);\n                currentPartition.pop();\n            }\n        }\n    }\n\n    backtrack(0);\n    return result;\n};\n"}}}
{"leetcodeId":133,"title":"Clone Graph","codingData":{"starterCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, neighbors) {\n *    this.val = val === undefined ? 0 : val;\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nvar cloneGraph = function(node) {\n    \n};","python":"# Definition for a Node.\n# class Node:\n#     def __init__(self, val = 0, neighbors = None):\n#         self.val = val\n#         self.neighbors = neighbors if neighbors is not None else []\n\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        ","typescript":"/**\n * Definition for a Node.\n * class Node {\n *     val: number\n *     neighbors: Node[]\n *     constructor(val?: number, neighbors?: Node[]) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.neighbors = (neighbors===undefined ? [] : neighbors)\n *     }\n * }\n */\n\nfunction cloneGraph(node: Node | null): Node | null {\n\n};"},"testCases":[{"input":"[[2,4],[1,3],[2,4],[1,3]]","expectedOutput":"[[2,4],[1,3],[2,4],[1,3]]","isHidden":false},{"input":"[[]]","expectedOutput":"[[]]","isHidden":false},{"input":"[]","expectedOutput":"[]","isHidden":false},{"input":"[[2],[1]]","expectedOutput":"[[2],[1]]","isHidden":false},{"input":"[[2,3],[1,4],[1,4],[2,3]]","expectedOutput":"[[2,3],[1,4],[1,4],[2,3]]","isHidden":true},{"input":"[[2],[3],[4],[1]]","expectedOutput":"[[2],[3],[4],[1]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, neighbors) {\n *    this.val = val === undefined ? 0 : val;\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nvar cloneGraph = function(node) {\n    if (!node) {\n        return null;\n    }\n\n    const visited = new Map();\n\n    function dfs(originalNode) {\n        if (visited.has(originalNode.val)) {\n            return visited.get(originalNode.val);\n        }\n\n        const clonedNode = new Node(originalNode.val);\n        visited.set(originalNode.val, clonedNode);\n\n        clonedNode.neighbors = originalNode.neighbors.map(neighbor => dfs(neighbor));\n\n        return clonedNode;\n    }\n\n    return dfs(node);\n};"}}}
{"leetcodeId":132,"title":"Palindrome Partitioning II","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar minCut = function(s) {\n    \n};","python":"def min_cut(s: str) -> int:\n    pass","typescript":"function minCut(s: string): number {\n\n};"},"testCases":[{"input":"\"aab\"","expectedOutput":1,"isHidden":false},{"input":"\"a\"","expectedOutput":0,"isHidden":false},{"input":"\"ab\"","expectedOutput":1,"isHidden":false},{"input":"\"racecar\"","expectedOutput":0,"isHidden":true},{"input":"\"abccba\"","expectedOutput":0,"isHidden":true},{"input":"\"abcbaabcba\"","expectedOutput":0,"isHidden":true},{"input":"\"abcde\"","expectedOutput":4,"isHidden":true},{"input":"\"aaaaa\"","expectedOutput":0,"isHidden":true},{"input":"\"topcoderopen\"","expectedOutput":11,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar minCut = function(s) {\n    const n = s.length;\n\n    // dp_isPalindrome[i][j] will be true if s[i...j] is a palindrome\n    const dp_isPalindrome = Array(n).fill(0).map(() => Array(n).fill(false));\n\n    // dp_minCuts[i] will store the minimum cuts needed for s[0...i]\n    const dp_minCuts = Array(n).fill(0);\n\n    // Precompute all palindrome substrings\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i; j < n; j++) {\n            if (s[i] === s[j] && (j - i <= 2 || dp_isPalindrome[i + 1][j - 1])) {\n                dp_isPalindrome[i][j] = true;\n            }\n        }\n    }\n\n    // Fill dp_minCuts array\n    for (let i = 0; i < n; i++) {\n        if (dp_isPalindrome[0][i]) {\n            dp_minCuts[i] = 0; // s[0...i] is a palindrome, no cuts needed\n        } else {\n            dp_minCuts[i] = i; // Max possible cuts (each char is a palindrome)\n            for (let j = 0; j < i; j++) {\n                if (dp_isPalindrome[j + 1][i]) {\n                    // If s[j+1...i] is a palindrome, we can make a cut after s[j]\n                    // and add 1 to the min cuts for s[0...j]\n                    dp_minCuts[i] = Math.min(dp_minCuts[i], dp_minCuts[j] + 1);\n                }\n            }\n        }\n    }\n\n    return dp_minCuts[n - 1];\n};"}}}
{"leetcodeId":127,"title":"Word Ladder","codingData":{"starterCode":{"javascript":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    \n};\n","python":"from collections import deque\n\ndef ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int:\n    pass\n","typescript":"/**\n * @param beginWord\n * @param endWord\n * @param wordList\n */\nfunction ladderLength(beginWord: string, endWord: string, wordList: string[]): number {\n\n};\n"},"testCases":[{"input":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]","expectedOutput":5,"isHidden":false},{"input":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]","expectedOutput":0,"isHidden":false},{"input":"\"a\"\n\"c\"\n[\"a\",\"b\",\"c\"]","expectedOutput":2,"isHidden":true},{"input":"\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]","expectedOutput":3,"isHidden":true},{"input":"\"red\"\n\"tax\"\n[\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"den\",\"rex\",\"pee\"]","expectedOutput":4,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) {\n        return 0;\n    }\n\n    let queue = [[beginWord, 1]];\n    wordSet.delete(beginWord);\n\n    while (queue.length > 0) {\n        const [currentWord, level] = queue.shift();\n\n        if (currentWord === endWord) {\n            return level;\n        }\n\n        for (let i = 0; i < currentWord.length; i++) {\n            for (let charCode = 97; charCode <= 122; charCode++) { // 'a' to 'z'\n                const char = String.fromCharCode(charCode);\n                const nextWord = currentWord.substring(0, i) + char + currentWord.substring(i + 1);\n\n                if (wordSet.has(nextWord)) {\n                    wordSet.delete(nextWord);\n                    queue.push([nextWord, level + 1]);\n                }\n            }\n        }\n    }\n\n    return 0;\n};\n"}}}
{"leetcodeId":135,"title":"Candy","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} ratings\n * @return {number}\n */\nvar candy = function(ratings) {\n    \n};\n","python":"def candy(ratings: list[int]) -> int:\n    pass\n","typescript":"/**\n * @param {number[]} ratings\n * @return {number}\n */\nfunction candy(ratings: number[]): number {\n\n};\n"},"testCases":[{"input":"[1,0,2]","expectedOutput":5,"isHidden":false},{"input":"[1,2,2]","expectedOutput":4,"isHidden":false},{"input":"[1,2,87,87,87,2,1]","expectedOutput":13,"isHidden":true},{"input":"[1,3,2,2,1]","expectedOutput":7,"isHidden":true},{"input":"[0]","expectedOutput":1,"isHidden":true},{"input":"[1,2,3,4,5]","expectedOutput":15,"isHidden":true},{"input":"[5,4,3,2,1]","expectedOutput":15,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} ratings\n * @return {number}\n */\nvar candy = function(ratings) {\n    const n = ratings.length;\n    if (n === 0) {\n        return 0;\n    }\n\n    const candies = new Array(n).fill(1);\n\n    // Left to right pass\n    // If current child has higher rating than left neighbor, give more candy\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) {\n            candies[i] = candies[i - 1] + 1;\n        }\n    }\n\n    // Right to left pass\n    // If current child has higher rating than right neighbor, and current candy count\n    // is not already greater, update it.\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) {\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n        }\n    }\n\n    // Sum up all candies\n    let totalCandies = 0;\n    for (let i = 0; i < n; i++) {\n        totalCandies += candies[i];\n    }\n\n    return totalCandies;\n};\n"}}}
{"leetcodeId":129,"title":"Sum Root to Leaf Numbers","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    \n};\n","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nfunction sumNumbers(root: TreeNode | null): number {\n\n};\n"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}","expectedOutput":25,"isHidden":false},{"input":"{\"val\":4,\"left\":{\"val\":9,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":{\"val\":1,\"left\":null,\"right\":null}},\"right\":{\"val\":0,\"left\":null,\"right\":null}}","expectedOutput":1026,"isHidden":false},{"input":"{\"val\":0,\"left\":null,\"right\":null}","expectedOutput":0,"isHidden":true},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":1,"isHidden":true},{"input":"{\"val\":9,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":9,\"left\":null,\"right\":null}}","expectedOutput":198,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    let totalSum = 0;\n\n    function dfs(node, currentNumber) {\n        if (!node) {\n            return;\n        }\n\n        currentNumber = currentNumber * 10 + node.val;\n\n        // If it's a leaf node, add the current number to totalSum\n        if (!node.left && !node.right) {\n            totalSum += currentNumber;\n            return;\n        }\n\n        // Recurse for left and right children\n        dfs(node.left, currentNumber);\n        dfs(node.right, currentNumber);\n    }\n\n    dfs(root, 0);\n    return totalSum;\n};\n"}}}
{"leetcodeId":134,"title":"Gas Station","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nvar canCompleteCircuit = function(gas, cost) {\n    \n};","python":"from typing import List\n\ndef can_complete_circuit(gas: List[int], cost: List[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nfunction canCompleteCircuit(gas: number[], cost: number[]): number {\n\n};"},"testCases":[{"input":"[1,2,3,4,5]\n[3,4,5,1,2]","expectedOutput":3,"isHidden":false},{"input":"[2,3,4]\n[3,4,3]","expectedOutput":-1,"isHidden":false},{"input":"[5,1,2,3,4]\n[4,4,1,5,1]","expectedOutput":4,"isHidden":true},{"input":"[3,3,4]\n[3,4,4]","expectedOutput":-1,"isHidden":true},{"input":"[0]\n[0]","expectedOutput":0,"isHidden":true},{"input":"[5]\n[4]","expectedOutput":0,"isHidden":true},{"input":"[4]\n[5]","expectedOutput":-1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nvar canCompleteCircuit = function(gas, cost) {\n    let totalGas = 0;\n    let currentGas = 0;\n    let startStation = 0;\n\n    for (let i = 0; i < gas.length; i++) {\n        const netGas = gas[i] - cost[i];\n        totalGas += netGas;\n        currentGas += netGas;\n\n        // If currentGas becomes negative, it means we cannot reach station i+1 from startStation.\n        // So, we reset startStation to i+1 and reset currentGas.\n        if (currentGas < 0) {\n            startStation = i + 1;\n            currentGas = 0;\n        }\n    }\n\n    // If totalGas is negative, it means it's impossible to complete the circuit.\n    // Otherwise, startStation holds the unique starting point.\n    return totalGas >= 0 ? startStation : -1;\n};"}}}
{"leetcodeId":126,"title":"Word Ladder II","codingData":{"starterCode":{"javascript":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, wordList) {\n    \n};","python":"from typing import List\n\ndef find_ladders(begin_word: str, end_word: str, word_list: List[str]) -> List[List[str]]:\n    pass","typescript":"/**\n * @param beginWord\n * @param endWord\n * @param wordList\n * @return {string[][]}\n */\nfunction findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {\n\n};"},"testCases":[{"input":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]","expectedOutput":"[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]","isHidden":false},{"input":"\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]","expectedOutput":"[]","isHidden":false},{"input":"\"a\"\n\"c\"\n[\"a\",\"b\",\"c\"]","expectedOutput":"[[\"a\",\"c\"]]","isHidden":true},{"input":"\"red\"\n\"tax\"\n[\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"den\",\"rex\",\"pee\"]","expectedOutput":"[[\"red\",\"ted\",\"tex\",\"tax\"],[\"red\",\"ted\",\"tad\",\"tax\"]]","isHidden":true},{"input":"\"red\"\n\"tax\"\n[\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"den\",\"rex\",\"pee\",\"ret\",\"rat\",\"rot\"]","expectedOutput":"[[\"red\",\"ted\",\"tex\",\"tax\"],[\"red\",\"ted\",\"tad\",\"tax\"],[\"red\",\"ret\",\"tex\",\"tax\"],[\"red\",\"ret\",\"rat\",\"tax\"],[\"red\",\"rot\",\"rat\",\"tax\"]]","isHidden":true}],"solutionCode":{"javascript":"var findLadders = function(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) {\n        return [];\n    }\n\n    let queue = [];\n    queue.push([beginWord]);\n\n    let results = [];\n    let visited = new Set();\n    visited.add(beginWord);\n\n    let found = false;\n    let levelWords = new Set(); // Words visited in the current level\n\n    while (queue.length > 0 && !found) {\n        let levelSize = queue.length;\n        let nextLevelVisited = new Set(); // Words to add to visited for the next level\n\n        for (let i = 0; i < levelSize; i++) {\n            let path = queue.shift();\n            let lastWord = path[path.length - 1];\n\n            if (lastWord === endWord) {\n                results.push(path);\n                found = true;\n            }\n\n            for (let j = 0; j < lastWord.length; j++) {\n                let charArray = lastWord.split('');\n                for (let charCode = 97; charCode <= 122; charCode++) { // 'a' to 'z'\n                    let char = String.fromCharCode(charCode);\n                    charArray[j] = char;\n                    let nextWord = charArray.join('');\n\n                    if (wordSet.has(nextWord) && !visited.has(nextWord)) {\n                        let newPath = [...path, nextWord];\n                        queue.push(newPath);\n                        nextLevelVisited.add(nextWord);\n                    }\n                }\n            }\n        }\n        // Add all words visited in this level to the global visited set\n        // This ensures we only explore shortest paths. If a word is reached\n        // at a later level, it's not a shortest path.\n        for (let word of nextLevelVisited) {\n            visited.add(word);\n        }\n    }\n\n    return results;\n};"}}}
{"leetcodeId":130,"title":"Surrounded Regions","codingData":{"starterCode":{"javascript":"/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function(board) {\n\n};","python":"from typing import List\n\ndef solve(board: List[List[str]]) -> None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    pass","typescript":"/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nfunction solve(board: character[][]): void {\n\n};"},"testCases":[{"input":"[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]","expectedOutput":"[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]","isHidden":false},{"input":"[[\"X\"]]","expectedOutput":"[[\"X\"]]","isHidden":false},{"input":"[[\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\"]]","expectedOutput":"[[\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\"]]","isHidden":true},{"input":"[[\"X\",\"O\",\"X\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"X\"]]","expectedOutput":"[[\"X\",\"O\",\"X\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"X\"]]","isHidden":true},{"input":"[[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]","expectedOutput":"[[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function(board) {\n    if (!board || board.length === 0) {\n        return;\n    }\n\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(r, c) {\n        if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] !== 'O') {\n            return;\n        }\n        board[r][c] = 'T'; // Mark as 'Temporary' or 'Traversed' (not to be flipped)\n        dfs(r + 1, c);\n        dfs(r - 1, c);\n        dfs(r, c + 1);\n        dfs(r, c - 1);\n    }\n\n    // 1. Traverse borders and mark connected 'O's as 'T'\n    // Top and bottom borders\n    for (let c = 0; c < n; c++) {\n        if (board[0][c] === 'O') {\n            dfs(0, c);\n        }\n        if (board[m - 1][c] === 'O') {\n            dfs(m - 1, c);\n        }\n    }\n\n    // Left and right borders\n    for (let r = 0; r < m; r++) {\n        if (board[r][0] === 'O') {\n            dfs(r, 0);\n        }\n        if (board[r][n - 1] === 'O') {\n            dfs(r, n - 1);\n        }\n    }\n\n    // 2. Iterate through the board to flip 'O's and restore 'T's\n    for (let r = 0; r < m; r++) {\n        for (let c = 0; c < n; c++) {\n            if (board[r][c] === 'O') {\n                board[r][c] = 'X'; // Surrounded 'O's are flipped to 'X'\n            } else if (board[r][c] === 'T') {\n                board[r][c] = 'O'; // 'T's are restored to 'O's\n            }\n        }\n    }\n};"}}}
{"leetcodeId":136,"title":"Single Number","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n\n};\n","python":"def single_number(nums: list[int]) -> int:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction singleNumber(nums: number[]): number {\n\n};\n"},"testCases":[{"input":"[2,2,1]","expectedOutput":1,"isHidden":false},{"input":"[4,1,2,1,2]","expectedOutput":4,"isHidden":false},{"input":"[1]","expectedOutput":1,"isHidden":false},{"input":"[7,3,5,4,5,3,4]","expectedOutput":7,"isHidden":true},{"input":"[-1,-1,-2]","expectedOutput":-2,"isHidden":true},{"input":"[100]","expectedOutput":100,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    let single = 0;\n    for (let i = 0; i < nums.length; i++) {\n        single ^= nums[i];\n    }\n    return single;\n};\n"}}}
{"leetcodeId":137,"title":"Single Number II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n\n};","python":"def single_number(nums: list[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction singleNumber(nums: number[]): number {\n\n};"},"testCases":[{"input":"[2,2,3,2]","expectedOutput":3,"isHidden":false},{"input":"[0,1,0,1,0,1,99]","expectedOutput":99,"isHidden":false},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[-2,-2,1,-2]","expectedOutput":1,"isHidden":true},{"input":"[2147483647,2147483647,2147483647,-1]","expectedOutput":-1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    let single = 0;\n\n    for (let i = 0; i < 32; i++) {\n        let sum = 0;\n        for (const num of nums) {\n            // Check the i-th bit of the current number\n            if ((num >> i) & 1) {\n                sum++;\n            }\n        }\n        // If the sum of the i-th bits is not a multiple of 3,\n        // then the i-th bit of the single number must be 1.\n        if (sum % 3 !== 0) {\n            single |= (1 << i);\n        }\n    }\n\n    return single;\n};"}}}
{"leetcodeId":139,"title":"Word Break","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nvar wordBreak = function(s, wordDict) {\n\n};","python":"def wordBreak(s: str, wordDict: list[str]) -> bool:\n    pass","typescript":"function wordBreak(s: string, wordDict: string[]): boolean {\n\n};"},"testCases":[{"input":"\"leetcode\"\n[\"leet\",\"code\"]","expectedOutput":true,"isHidden":false},{"input":"\"applepenapple\"\n[\"apple\",\"pen\"]","expectedOutput":true,"isHidden":false},{"input":"\"catsandog\"\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]","expectedOutput":false,"isHidden":false},{"input":"\"a\"\n[\"a\"]","expectedOutput":true,"isHidden":true},{"input":"\"aaaaaaa\"\n[\"aaaa\",\"aaa\"]","expectedOutput":true,"isHidden":true},{"input":"\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nvar wordBreak = function(s, wordDict) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(false);\n    dp[0] = true;\n\n    const wordSet = new Set(wordDict);\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && wordSet.has(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    return dp[n];\n};"}}}
{"leetcodeId":141,"title":"Linked List Cycle","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function(head) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction hasCycle(head: ListNode | null): boolean {\n\n};"},"testCases":[{"input":"{\"_is_linked_list\": true, \"values\": [3,2,0,-4], \"pos\": 1}","expectedOutput":"true","isHidden":false},{"input":"{\"_is_linked_list\": true, \"values\": [1,2], \"pos\": 0}","expectedOutput":"true","isHidden":false},{"input":"{\"_is_linked_list\": true, \"values\": [1], \"pos\": -1}","expectedOutput":"false","isHidden":false},{"input":"{\"_is_linked_list\": true, \"values\": [], \"pos\": -1}","expectedOutput":"false","isHidden":true},{"input":"{\"_is_linked_list\": true, \"values\": [1,2,3,4,5], \"pos\": -1}","expectedOutput":"false","isHidden":true},{"input":"{\"_is_linked_list\": true, \"values\": [1,2,3,4,5], \"pos\": 2}","expectedOutput":"true","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function(head) {\n    if (!head || !head.next) {\n        return false;\n    }\n\n    let slow = head;\n    let fast = head.next;\n\n    while (fast && fast.next) {\n        if (slow === fast) {\n            return true;\n        }\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    return false;\n};"}}}
{"leetcodeId":140,"title":"Word Break II","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nvar wordBreak = function(s, wordDict) {\n    \n};","python":"def wordBreak(s: str, wordDict: list[str]) -> list[str]:\n    pass","typescript":"/**\n * @param s\n * @param wordDict\n * @return\n */\nfunction wordBreak(s: string, wordDict: string[]): string[] {\n\n};"},"testCases":[{"input":"\"catsanddog\"\n[\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]","expectedOutput":["cats and dog","cat sand dog"],"isHidden":false},{"input":"\"pineapplepenapple\"\n[\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]","expectedOutput":["pine apple pen apple","pineapple pen apple","pine applepen apple"],"isHidden":false},{"input":"\"catsandog\"\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]","expectedOutput":[],"isHidden":false},{"input":"\"a\"\n[\"b\"]","expectedOutput":[],"isHidden":true},{"input":"\"aaaaaaa\"\n[\"aaaa\",\"aa\",\"a\"]","expectedOutput":["a a a a a a a","aa a a a a a","a aa a a a a","a a aa a a a","a a a aa a a","a a a a aa a","a a a a a aa","aa aa a a a","aa a aa a a","aa a a aa a","aa a a a aa","a aa aa a a","a aa a aa a","a aa a a aa","a a aa aa a","a a aa a aa","a a a aa aa","aaaa a a a","aaaa aa a","aaaa a aa","a aaaa a a","a aaaa aa","a a aaaa a","a a a aaaa","aa aaaa a","aa a aaaa","a aa aaaa"],"isHidden":true},{"input":"\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]","expectedOutput":[],"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nvar wordBreak = function(s, wordDict) {\n    const wordSet = new Set(wordDict);\n    const memo = new Map();\n\n    function backtrack(startIndex) {\n        if (startIndex === s.length) {\n            return [\"\"]; // Base case: if we reached the end, return an empty string to signify a valid path\n        }\n\n        if (memo.has(startIndex)) {\n            return memo.get(startIndex);\n        }\n\n        const result = [];\n        for (let i = startIndex; i < s.length; i++) {\n            const word = s.substring(startIndex, i + 1);\n            if (wordSet.has(word)) {\n                const restOfSentences = backtrack(i + 1);\n                for (const sentence of restOfSentences) {\n                    if (sentence === \"\") {\n                        result.push(word);\n                    } else {\n                        result.push(word + \" \" + sentence);\n                    }\n                }\n            }\n        }\n\n        memo.set(startIndex, result);\n        return result;\n    }\n\n    return backtrack(0);\n};"}}}
{"leetcodeId":145,"title":"Binary Tree Postorder Traversal","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction postorderTraversal(root: TreeNode | null): number[] {\n\n};"},"testCases":[{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"right\":null,\"left\":null},\"right\":null}}","expectedOutput":"[3,2,1]","isHidden":false},{"input":"null","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"[1]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"[2,1]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":"[2,1]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":5,\"left\":null,\"right\":null}},\"right\":{\"val\":3,\"left\":{\"val\":6,\"left\":null,\"right\":null},\"right\":null}}","expectedOutput":"[4,5,2,6,3,1]","isHidden":true},{"input":"{\"val\":-100,\"left\":null,\"right\":{\"val\":100,\"left\":null,\"right\":null}}","expectedOutput":"[100,-100]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    const result = [];\n    const stack = [];\n    if (root) {\n        stack.push(root);\n    }\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n        result.unshift(node.val); // Add to the beginning of the result array\n\n        if (node.left) {\n            stack.push(node.left);\n        }\n        if (node.right) {\n            stack.push(node.right);\n        }\n    }\n\n    return result;\n};\n"}}}
{"leetcodeId":144,"title":"Binary Tree Preorder Traversal","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n    \n};","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nfunction preorderTraversal(root: TreeNode | null): number[] {\n\n};"},"testCases":[{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}","expectedOutput":"[1,2,3]","isHidden":false},{"input":"null","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"[1]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"[1,2]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":null,\"right\":null}}","expectedOutput":"[1,2]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":5,\"left\":null,\"right\":null}},\"right\":{\"val\":3,\"left\":{\"val\":6,\"left\":null,\"right\":null},\"right\":null}}","expectedOutput":"[1,2,4,5,3,6]","isHidden":true},{"input":"{\"val\":-100,\"left\":null,\"right\":null}","expectedOutput":"[-100]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n    const result = [];\n    const stack = [];\n\n    if (root === null) {\n        return result;\n    }\n\n    stack.push(root);\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n        result.push(node.val);\n\n        // Push right child first so that left child is processed first (LIFO)\n        if (node.right !== null) {\n            stack.push(node.right);\n        }\n        if (node.left !== null) {\n            stack.push(node.left);\n        }\n    }\n\n    return result;\n};"}}}
{"leetcodeId":143,"title":"Reorder List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\nfunction reorderList(head) {\n    // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\ndef reorderList(head: ListNode) -> None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    # Your code here","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {void}\n */\nfunction reorderList(head: ListNode | null): void {\n    // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":4,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":5,\"next\":{\"val\":2,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":null}","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\nfunction reorderList(head) {\n    if (!head || !head.next) {\n        return;\n    }\n\n    // Step 1: Find the middle of the list\n    let slow = head;\n    let fast = head;\n    while (fast.next && fast.next.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // Step 2: Split the list into two halves\n    // head1 is the first half, head2 is the second half\n    let head1 = head;\n    let head2 = slow.next;\n    slow.next = null; // Break the link to separate the two halves\n\n    // Step 3: Reverse the second half\n    let prev = null;\n    let curr = head2;\n    while (curr) {\n        let nextTemp = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = nextTemp;\n    }\n    head2 = prev; // head2 is now the reversed second half\n\n    // Step 4: Merge the two halves\n    // L0 -> Ln -> L1 -> Ln-1 -> ...\n    let p1 = head1;\n    let p2 = head2;\n    while (p1 && p2) {\n        let p1Next = p1.next;\n        let p2Next = p2.next;\n\n        p1.next = p2;\n        p2.next = p1Next;\n\n        p1 = p1Next;\n        p2 = p2Next;\n    }\n}"}}}
{"leetcodeId":138,"title":"Copy List with Random Pointer","codingData":{"starterCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, next, random) {\n *    this.val = val;\n *    this.next = next;\n *    this.random = random;\n * };\n */\n\n/**\n * @param {Node} head\n * @return {Node}\n */\nvar copyRandomList = function(head) {\n    \n};\n","python":"# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\nclass Solution:\n    def copyRandomList(self, head: 'Node') -> 'Node':\n        pass\n","typescript":"/**\n * Definition for a Node.\n * class Node {\n *     val: number\n *     next: Node | null\n *     random: Node | null\n *     constructor(val?: number, next?: Node, random?: Node) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *         this.random = (random===undefined ? null : random)\n *     }\n * }\n */\n\nfunction copyRandomList(head: Node | null): Node | null {\n\n};\n"},"testCases":[{"input":"[[7,null],[13,0],[11,4],[10,2],[1,0]]","expectedOutput":"[[7,null],[13,0],[11,4],[10,2],[1,0]]","isHidden":false},{"input":"[[1,1],[2,1]]","expectedOutput":"[[1,1],[2,1]]","isHidden":false},{"input":"[[3,null],[3,0],[3,null]]","expectedOutput":"[[3,null],[3,0],[3,null]]","isHidden":false},{"input":"[]","expectedOutput":"[]","isHidden":false},{"input":"[[1,null]]","expectedOutput":"[[1,null]]","isHidden":true},{"input":"[[1,0]]","expectedOutput":"[[1,0]]","isHidden":true},{"input":"[[1,null],[2,null],[3,null]]","expectedOutput":"[[1,null],[2,null],[3,null]]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a Node.\n * function Node(val, next, random) {\n *    this.val = val;\n *    this.next = next;\n *    this.random = random;\n * };\n */\n\n/**\n * @param {Node} head\n * @return {Node}\n */\nvar copyRandomList = function(head) {\n    if (!head) {\n        return null;\n    }\n\n    // Step 1: Create new nodes and interweave them with original nodes\n    // Original: A -> B -> C\n    // Interweaved: A -> A' -> B -> B' -> C -> C'\n    let current = head;\n    while (current) {\n        let newNode = new Node(current.val, current.next, null);\n        current.next = newNode;\n        current = newNode.next;\n    }\n\n    // Step 2: Assign random pointers for the new nodes\n    current = head;\n    while (current) {\n        if (current.random) {\n            current.next.random = current.random.next;\n        }\n        current = current.next.next;\n    }\n\n    // Step 3: Separate the original list from the copied list\n    let originalHead = head;\n    let copiedHead = head.next;\n    let copiedCurrent = copiedHead;\n\n    current = head;\n    while (current) {\n        current.next = current.next.next;\n        if (copiedCurrent.next) {\n            copiedCurrent.next = copiedCurrent.next.next;\n        }\n        current = current.next;\n        copiedCurrent = copiedCurrent.next;\n    }\n\n    return copiedHead;\n};\n"}}}
{"leetcodeId":142,"title":"Linked List Cycle II","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n\n};"},"testCases":[{"input":"{\"_is_linked_list\": true, \"values\": [3,2,0,-4], \"pos\": 1}","expectedOutput":"{\"_is_linked_list\": true, \"values\": [2,0,-4], \"pos\": 0}","isHidden":false},{"input":"{\"_is_linked_list\": true, \"values\": [1,2], \"pos\": 0}","expectedOutput":"{\"_is_linked_list\": true, \"values\": [1,2], \"pos\": 0}","isHidden":false},{"input":"{\"_is_linked_list\": true, \"values\": [1], \"pos\": -1}","expectedOutput":"null","isHidden":false},{"input":"{\"_is_linked_list\": true, \"values\": [], \"pos\": -1}","expectedOutput":"null","isHidden":true},{"input":"{\"_is_linked_list\": true, \"values\": [1,2,3,4,5], \"pos\": -1}","expectedOutput":"null","isHidden":true},{"input":"{\"_is_linked_list\": true, \"values\": [1,2,3,4,5], \"pos\": 2}","expectedOutput":"{\"_is_linked_list\": true, \"values\": [3,4,5], \"pos\": 0}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (!head || !head.next) {\n        return null;\n    }\n\n    let slow = head;\n    let fast = head;\n\n    // Phase 1: Detect if a cycle exists\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            break; // Cycle detected\n        }\n    }\n\n    // If fast or fast.next is null, no cycle exists\n    if (fast === null || fast.next === null) {\n        return null;\n    }\n\n    // Phase 2: Find the start of the cycle\n    // Reset one pointer to the head and move both at the same pace\n    // They will meet at the start of the cycle\n    let ptr1 = head;\n    let ptr2 = slow; // slow is currently at the meeting point\n\n    while (ptr1 !== ptr2) {\n        ptr1 = ptr1.next;\n        ptr2 = ptr2.next;\n    }\n\n    return ptr1;\n};"}}}
{"leetcodeId":150,"title":"Evaluate Reverse Polish Notation","codingData":{"starterCode":{"javascript":"/**\n * @param {string[]} tokens\n * @return {number}\n */\nvar evalRPN = function(tokens) {\n    \n};","python":"class Solution:\n    def evalRPN(self, tokens: list[str]) -> int:\n        pass","typescript":"/**\n * @param {string[]} tokens\n * @return {number}\n */\nfunction evalRPN(tokens: string[]): number {\n\n};"},"testCases":[{"input":"[\"2\",\"1\",\"+\",\"3\",\"*\"]","expectedOutput":9,"isHidden":false},{"input":"[\"4\",\"13\",\"5\",\"/\",\"+\"]","expectedOutput":6,"isHidden":false},{"input":"[\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]","expectedOutput":22,"isHidden":false},{"input":"[\"0\",\"3\",\"/\"]","expectedOutput":0,"isHidden":true},{"input":"[\"1\"]","expectedOutput":1,"isHidden":true},{"input":"[\"-7\",\"-3\",\"/\"]","expectedOutput":2,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string[]} tokens\n * @return {number}\n */\nvar evalRPN = function(tokens) {\n    const stack = [];\n    const operators = {\n        '+': (a, b) => a + b,\n        '-': (a, b) => a - b,\n        '*': (a, b) => a * b,\n        '/': (a, b) => {\n            // Division should truncate toward zero\n            return Math.trunc(a / b);\n        }\n    };\n\n    for (const token of tokens) {\n        if (operators[token]) {\n            const operand2 = stack.pop();\n            const operand1 = stack.pop();\n            stack.push(operators[token](operand1, operand2));\n        } else {\n            stack.push(parseInt(token));\n        }\n    }\n\n    return stack.pop();\n};"}}}
{"leetcodeId":152,"title":"Maximum Product Subarray","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxProduct = function(nums) {\n\n};\n","python":"from typing import List\n\ndef max_product(nums: List[int]) -> int:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction maxProduct(nums: number[]): number {\n\n};\n"},"testCases":[{"input":"[2,3,-2,4]","expectedOutput":6,"isHidden":false},{"input":"[-2,0,-1]","expectedOutput":0,"isHidden":false},{"input":"[0]","expectedOutput":0,"isHidden":true},{"input":"[-2]","expectedOutput":-2,"isHidden":true},{"input":"[3,-1,4]","expectedOutput":4,"isHidden":true},{"input":"[-2,-3,-1]","expectedOutput":6,"isHidden":true},{"input":"[1,2,3,4,5]","expectedOutput":120,"isHidden":true},{"input":"[-1,-2,-9,-6]","expectedOutput":108,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxProduct = function(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n\n    let maxSoFar = nums[0];\n    let minSoFar = nums[0];\n    let result = maxSoFar;\n\n    for (let i = 1; i < nums.length; i++) {\n        let curr = nums[i];\n        // When encountering a negative number, max and min products swap roles\n        // because multiplying a negative number by the current max will give a new min,\n        // and multiplying by the current min will give a new max.\n        let tempMax = Math.max(curr, Math.max(maxSoFar * curr, minSoFar * curr));\n        minSoFar = Math.min(curr, Math.min(maxSoFar * curr, minSoFar * curr));\n\n        maxSoFar = tempMax;\n\n        result = Math.max(maxSoFar, result);\n    }\n\n    return result;\n};\n"}}}
{"leetcodeId":149,"title":"Max Points on a Line","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} points\n * @return {number}\n */\nvar maxPoints = function(points) {\n    \n};","python":"from typing import List\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        pass","typescript":"/**\n * @param {number[][]} points\n * @return {number}\n */\nfunction maxPoints(points: number[][]): number {\n\n};"},"testCases":[{"input":"[[1,1],[2,2],[3,3]]","expectedOutput":3,"isHidden":false},{"input":"[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]","expectedOutput":4,"isHidden":false},{"input":"[[0,0]]","expectedOutput":1,"isHidden":true},{"input":"[[0,0],[1,1],[0,0]]","expectedOutput":3,"isHidden":true},{"input":"[[1,1],[2,1],[3,1],[4,1],[5,1]]","expectedOutput":5,"isHidden":true},{"input":"[[0,0],[1,0],[2,0],[3,0],[4,0],[5,0]]","expectedOutput":6,"isHidden":true},{"input":"[[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9]]","expectedOutput":10,"isHidden":true},{"input":"[[2,3],[3,3],[-5,3]]","expectedOutput":3,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} points\n * @return {number}\n */\nvar maxPoints = function(points) {\n    const n = points.length;\n    if (n <= 2) {\n        return n;\n    }\n\n    let maxCount = 0;\n\n    // Helper function to calculate GCD\n    const gcd = (a, b) => {\n        return b === 0 ? a : gcd(b, a % b);\n    };\n\n    for (let i = 0; i < n; i++) {\n        const p1 = points[i];\n        const slopes = new Map(); // Map to store slopes: \"dx/dy\" -> count\n        let verticalPoints = 0; // Count of points with same x-coordinate (vertical line)\n        let samePoints = 0;     // Count of points identical to p1\n        let currentMax = 0;     // Max points on a line passing through p1 (excluding samePoints)\n\n        for (let j = i + 1; j < n; j++) {\n            const p2 = points[j];\n\n            if (p1[0] === p2[0] && p1[1] === p2[1]) {\n                samePoints++;\n                continue;\n            }\n\n            if (p1[0] === p2[0]) {\n                verticalPoints++;\n                continue;\n            }\n\n            const dy = p2[1] - p1[1];\n            const dx = p2[0] - p1[0];\n\n            const commonDivisor = gcd(Math.abs(dx), Math.abs(dy));\n            const reducedDy = dy / commonDivisor;\n            const reducedDx = dx / commonDivisor;\n\n            // Use a string representation for the slope to handle negative signs consistently\n            const slopeKey = `${reducedDy}/${reducedDx}`;\n            slopes.set(slopeKey, (slopes.get(slopeKey) || 0) + 1);\n            currentMax = Math.max(currentMax, slopes.get(slopeKey));\n        }\n\n        // Update maxCount considering all types of lines through p1\n        // currentMax: max points on non-vertical, non-same lines\n        // verticalPoints: max points on vertical lines\n        // samePoints: points identical to p1, which lie on any line passing through p1\n        maxCount = Math.max(maxCount, currentMax + samePoints + 1, verticalPoints + samePoints + 1);\n    }\n\n    return maxCount;\n};"}}}
{"leetcodeId":153,"title":"Find Minimum in Rotated Sorted Array","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    \n};","python":"from typing import List\n\ndef find_min(nums: List[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction findMin(nums: number[]): number {\n\n};"},"testCases":[{"input":"[3,4,5,1,2]","expectedOutput":1,"isHidden":false},{"input":"[4,5,6,7,0,1,2]","expectedOutput":0,"isHidden":false},{"input":"[11,13,15,17]","expectedOutput":11,"isHidden":false},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[2,1]","expectedOutput":1,"isHidden":true},{"input":"[5,1,2,3,4]","expectedOutput":1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    // If the array is not rotated (or rotated n times), the first element is the minimum.\n    // This also handles the case of a single element array.\n    if (nums[left] <= nums[right]) {\n        return nums[left];\n    }\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n\n        // Check if mid is the minimum element\n        // If nums[mid] > nums[mid + 1], then nums[mid+1] is the smallest\n        if (mid < nums.length - 1 && nums[mid] > nums[mid + 1]) {\n            return nums[mid + 1];\n        }\n        // If nums[mid - 1] > nums[mid], then nums[mid] is the smallest\n        if (mid > 0 && nums[mid - 1] > nums[mid]) {\n            return nums[mid];\n        }\n\n        // Decide whether to go left or right\n        if (nums[left] <= nums[mid]) {\n            // Left half is sorted, meaning the pivot (minimum) is in the right half\n            left = mid + 1;\n        } else {\n            // Right half is sorted, meaning the pivot (minimum) is in the left half\n            right = mid - 1;\n        }\n    }\n    // This line should ideally not be reached if the input is valid as per constraints\n    return -1; \n};"}}}
{"leetcodeId":148,"title":"Sort List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction sortList(head) {\n  // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction sortList(head: ListNode | null): ListNode | null {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":4,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":3,\"next\":null}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}","isHidden":false},{"input":"{\"val\":-1,\"next\":{\"val\":5,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":0,\"next\":null}}}}}","expectedOutput":"{\"val\":-1,\"next\":{\"val\":0,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":false},{"input":"{\"val\":1,\"next\":null}","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true},{"input":"{\"val\":2,\"next\":{\"val\":1,\"next\":null}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","isHidden":true},{"input":"{\"val\":5,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":null}}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction sortList(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n\n    // Function to split the list into two halves\n    function splitList(node) {\n        let slow = node;\n        let fast = node;\n        let prev = null;\n\n        while (fast && fast.next) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if (prev) {\n            prev.next = null; // Break the list into two halves\n        }\n        return slow;\n    }\n\n    // Function to merge two sorted lists\n    function mergeTwoLists(l1, l2) {\n        const dummyHead = new ListNode(0);\n        let current = dummyHead;\n\n        while (l1 && l2) {\n            if (l1.val <= l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n\n        if (l1) {\n            current.next = l1;\n        } else if (l2) {\n            current.next = l2;\n        }\n\n        return dummyHead.next;\n    }\n\n    // Find the middle of the list to split it\n    const mid = splitList(head);\n\n    // Recursively sort the two halves\n    const left = sortList(head);\n    const right = sortList(mid);\n\n    // Merge the sorted halves\n    return mergeTwoLists(left, right);\n}"}}}
{"leetcodeId":155,"title":"Min Stack","codingData":{"starterCode":{"javascript":"/**\n * @class MinStack\n */\nvar MinStack = function() {\n    \n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function(val) {\n    \n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n    \n};\n","python":"class MinStack:\n\n    def __init__(self):\n        \n\n    def push(self, val: int) -> None:\n        \n\n    def pop(self) -> None:\n        \n\n    def top(self) -> int:\n        \n\n    def get_min(self) -> int:\n        \n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.get_min()","typescript":"class MinStack {\n    constructor() {\n\n    }\n\n    push(val: number): void {\n\n    }\n\n    pop(): void {\n\n    }\n\n    top(): number {\n\n    }\n\n    getMin(): number {\n\n    }\n}"},"testCases":[{"input":"[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]","expectedOutput":"[null,null,null,null,-3,null,0,-2]","isHidden":false},{"input":"[\"MinStack\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"top\"]\n[[],[2147483647],[2147483646],[2147483645],[],[],[]]","expectedOutput":"[null,null,null,null,null,2147483646,2147483646]","isHidden":true},{"input":"[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\n[[],[0],[1],[0],[2],[],[],[],[],[],[],[]]","expectedOutput":"[null,null,null,null,null,0,null,0,null,0,null,null]","isHidden":true},{"input":"[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"getMin\"]\n[[],[-10],[10],[-20],[],[],[]]","expectedOutput":"[null,null,null,null,-20,null,-10]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @class MinStack\n */\nvar MinStack = function() {\n    this.stack = [];\n    this.minStack = [];\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function(val) {\n    this.stack.push(val);\n    if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n        this.minStack.push(val);\n    } else {\n        this.minStack.push(this.minStack[this.minStack.length - 1]);\n    }\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n    this.stack.pop();\n    this.minStack.pop();\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n    return this.stack[this.stack.length - 1];\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n    return this.minStack[this.minStack.length - 1];\n};\n"}}}
{"leetcodeId":147,"title":"Insertion Sort List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar insertionSortList = function(head) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param head {ListNode | null}\n * @return {ListNode | null}\n */\nfunction insertionSortList(head: ListNode | null): ListNode | null {\n\n};"},"testCases":[{"input":"{\"val\":4,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":{\"val\":3,\"next\":null}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":null}}}}","isHidden":false},{"input":"{\"val\":-1,\"next\":{\"val\":5,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":0,\"next\":null}}}}}","expectedOutput":"{\"val\":-1,\"next\":{\"val\":0,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":null}","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true},{"input":"{\"val\":5,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":null}}}}}","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":true},{"input":"{\"val\":-5000,\"next\":{\"val\":0,\"next\":{\"val\":5000,\"next\":null}}}","expectedOutput":"{\"val\":-5000,\"next\":{\"val\":0,\"next\":{\"val\":5000,\"next\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar insertionSortList = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n\n    // Create a dummy node to simplify insertions at the beginning\n    const dummy = new ListNode(0);\n    dummy.next = head;\n\n    let current = head.next; // The node to be inserted\n    let lastSorted = head;   // The last node in the sorted portion\n\n    while (current) {\n        if (current.val >= lastSorted.val) {\n            // If current node is already in sorted order, just extend the sorted portion\n            lastSorted = current;\n            current = current.next;\n        } else {\n            // Current node needs to be inserted into the sorted portion\n            // Find the insertion point in the sorted list (from dummy.next to lastSorted)\n            let prev = dummy;\n            while (prev.next.val < current.val) {\n                prev = prev.next;\n            }\n\n            // Perform the insertion:\n            // 1. Disconnect current from its original position\n            lastSorted.next = current.next;\n            // 2. Insert current between prev and prev.next\n            current.next = prev.next;\n            prev.next = current;\n\n            // Move to the next node to be sorted (which was originally after current)\n            current = lastSorted.next;\n        }\n    }\n\n    return dummy.next;\n};"}}}
{"leetcodeId":151,"title":"Reverse Words in a String","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function(s) {\n    \n};\n","python":"class Solution:\n    def reverseWords(self, s: str) -> str:\n        \n","typescript":"/**\n * @param {string} s\n * @return {string}\n */\nfunction reverseWords(s: string): string {\n\n};\n"},"testCases":[{"input":"\"the sky is blue\"","expectedOutput":"blue is sky the","isHidden":false},{"input":"\"  hello world  \"","expectedOutput":"world hello","isHidden":false},{"input":"\"a good   example\"","expectedOutput":"example good a","isHidden":false},{"input":"\"  Bob    Loves  Alice   \"","expectedOutput":"Alice Loves Bob","isHidden":false},{"input":"\"Alice does not even like bob\"","expectedOutput":"bob like even not does Alice","isHidden":false},{"input":"\"a\"","expectedOutput":"a","isHidden":true},{"input":"\"   singleWord   \"","expectedOutput":"singleWord","isHidden":true},{"input":"\"   leading and trailing spaces   \"","expectedOutput":"spaces trailing and leading","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function(s) {\n    // Trim leading/trailing spaces and split by one or more spaces\n    const words = s.trim().split(/\\s+/);\n    \n    // Reverse the array of words\n    words.reverse();\n    \n    // Join the words back with a single space\n    return words.join(' ');\n};\n"}}}
{"leetcodeId":146,"title":"LRU Cache","codingData":{"starterCode":{"javascript":"/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n\n};\n\n/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */","python":"class LRUCache:\n\n    def __init__(self, capacity: int):\n\n\n    def get(self, key: int) -> int:\n\n\n    def put(self, key: int, value: int) -> None:\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)","typescript":"class LRUCache {\n    constructor(capacity: number) {\n\n    }\n\n    get(key: number): number {\n\n    }\n\n    put(key: number, value: number): void {\n\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */"},"testCases":[{"input":"[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]","expectedOutput":"[null, null, null, 1, null, -1, null, -1, 3, 4]","isHidden":false},{"input":"[\"LRUCache\", \"put\", \"put\", \"put\", \"put\", \"get\", \"get\"]\n[[2], [2, 1], [1, 1], [2, 3], [4, 1], [1], [2]]","expectedOutput":"[null, null, null, null, null, -1, 3]","isHidden":true},{"input":"[\"LRUCache\", \"get\", \"put\", \"get\", \"put\", \"put\", \"get\", \"get\"]\n[[1], [0], [0, 0], [0], [1, 1], [2, 2], [0], [1]]","expectedOutput":"[null, -1, null, 0, null, null, -1, 1]","isHidden":true},{"input":"[\"LRUCache\", \"put\", \"get\", \"put\", \"get\", \"get\"]\n[[1], [2, 1], [2], [3, 2], [2], [3]]","expectedOutput":"[null, null, 1, null, -1, 2]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map(); // Stores key-value pairs\n    this.head = {}; // Dummy head of the doubly linked list\n    this.tail = {}; // Dummy tail of the doubly linked list\n\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n};\n\n/**\n * Helper function to add a node to the front of the list (most recently used).\n * @param {object} node\n */\nLRUCache.prototype._addNode = function(node) {\n    node.prev = this.head;\n    node.next = this.head.next;\n\n    this.head.next.prev = node;\n    this.head.next = node;\n};\n\n/**\n * Helper function to remove a node from the list.\n * @param {object} node\n */\nLRUCache.prototype._removeNode = function(node) {\n    let prev = node.prev;\n    let next = node.next;\n\n    prev.next = next;\n    next.prev = prev;\n};\n\n/**\n * Helper function to move an existing node to the front of the list.\n * @param {object} node\n */\nLRUCache.prototype._moveToFront = function(node) {\n    this._removeNode(node);\n    this._addNode(node);\n};\n\n/**\n * Helper function to pop the least recently used node (from the tail).\n * @return {object} The removed node.\n */\nLRUCache.prototype._popTail = function() {\n    let res = this.tail.prev;\n    this._removeNode(res);\n    return res;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    let node = this.cache.get(key);\n\n    if (!node) {\n        return -1;\n    }\n\n    // Move the accessed node to the front (most recently used)\n    this._moveToFront(node);\n\n    return node.value;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    let node = this.cache.get(key);\n\n    if (node) {\n        // Key exists, update value and move to front\n        node.value = value;\n        this._moveToFront(node);\n    } else {\n        // Key does not exist, create new node\n        let newNode = { key: key, value: value };\n        this.cache.set(key, newNode);\n        this._addNode(newNode);\n\n        // Check capacity\n        if (this.cache.size > this.capacity) {\n            // Evict the least recently used item\n            let tailNode = this._popTail();\n            this.cache.delete(tailNode.key);\n        }\n    }\n};\n\n/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */"}}}
{"leetcodeId":154,"title":"Find Minimum in Rotated Sorted Array II","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n\n};","python":"def findMin(nums: list[int]) -> int:\n    pass","typescript":"function findMin(nums: number[]): number {\n\n};"},"testCases":[{"input":"[1,3,5]","expectedOutput":1,"isHidden":false},{"input":"[2,2,2,0,1]","expectedOutput":0,"isHidden":false},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[3,1,3]","expectedOutput":1,"isHidden":true},{"input":"[10,1,10,10,10]","expectedOutput":1,"isHidden":true},{"input":"[1,1,1,1,1]","expectedOutput":1,"isHidden":true},{"input":"[3,3,1,3]","expectedOutput":1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n\n        if (nums[mid] < nums[right]) {\n            // The minimum is in the left half including mid\n            right = mid;\n        } else if (nums[mid] > nums[right]) {\n            // The minimum is in the right half excluding mid\n            left = mid + 1;\n        } else {\n            // nums[mid] == nums[right]\n            // We cannot determine which side the minimum is on.\n            // For example, [1,3,3] -> mid=1, right=2, nums[mid]=3, nums[right]=3. Min is 1.\n            // [3,1,3] -> mid=1, right=2, nums[mid]=1, nums[right]=3. Min is 1.\n            // In this case, we can safely discard the rightmost element\n            // because nums[right] is a duplicate of nums[mid] and\n            // nums[mid] is not the minimum (otherwise nums[mid] < nums[right] would be true).\n            // Or, if nums[right] is the minimum, we will find it eventually.\n            right--;\n        }\n    }\n\n    return nums[left];\n};"}}}
{"leetcodeId":162,"title":"Find Peak Element","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findPeakElement = function(nums) {\n\n};","python":"from typing import List\n\ndef find_peak_element(nums: List[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction findPeakElement(nums: number[]): number {\n\n};"},"testCases":[{"input":"[1,2,3,1]","expectedOutput":2,"isHidden":false},{"input":"[1,2,1,3,5,6,4]","expectedOutput":5,"isHidden":false},{"input":"[1]","expectedOutput":0,"isHidden":true},{"input":"[3,2,1]","expectedOutput":0,"isHidden":true},{"input":"[1,2,3]","expectedOutput":2,"isHidden":true},{"input":"[2,1]","expectedOutput":0,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findPeakElement = function(nums) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n\n        // If nums[mid] is greater than its right neighbor, then a peak\n        // must exist in the left half (including mid) because the trend is downwards\n        // or it's the peak itself.\n        if (nums[mid] > nums[mid + 1]) {\n            right = mid;\n        } else {\n            // If nums[mid] is less than its right neighbor, then a peak\n            // must exist in the right half (excluding mid) because the trend is upwards.\n            left = mid + 1;\n        }\n    }\n\n    // When left === right, we have found a peak element.\n    return left;\n};"}}}
{"leetcodeId":159,"title":"Longest Substring with At Most Two Distinct Characters","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstringTwoDistinct = function(s) {\n    \n};","python":"def lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    pass","typescript":"function lengthOfLongestSubstringTwoDistinct(s: string): number {\n\n};"},"testCases":[{"input":"\"eceba\"","expectedOutput":3,"isHidden":false},{"input":"\"ccaabbb\"","expectedOutput":5,"isHidden":false},{"input":"\"abcabcabc\"","expectedOutput":2,"isHidden":true},{"input":"\"aba\"","expectedOutput":3,"isHidden":true},{"input":"\"a\"","expectedOutput":1,"isHidden":true},{"input":"\"abaccc\"","expectedOutput":4,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstringTwoDistinct = function(s) {\n    if (s.length < 3) {\n        return s.length;\n    }\n\n    let left = 0;\n    let right = 0;\n    let maxLength = 0;\n    const charCount = new Map();\n\n    while (right < s.length) {\n        const charR = s[right];\n        charCount.set(charR, (charCount.get(charR) || 0) + 1);\n\n        while (charCount.size > 2) {\n            const charL = s[left];\n            charCount.set(charL, charCount.get(charL) - 1);\n            if (charCount.get(charL) === 0) {\n                charCount.delete(charL);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n        right++;\n    }\n\n    return maxLength;\n};"}}}
{"leetcodeId":165,"title":"Compare Version Numbers","codingData":{"starterCode":{"javascript":"/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\nvar compareVersion = function(version1, version2) {\n\n};","python":"class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        pass","typescript":"/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\nfunction compareVersion(version1: string, version2: string): number {\n\n};"},"testCases":[{"input":"\"1.01\"\n\"1.001\"","expectedOutput":0,"isHidden":false},{"input":"\"1.0\"\n\"1.0.0\"","expectedOutput":0,"isHidden":false},{"input":"\"0.1\"\n\"1.1\"","expectedOutput":-1,"isHidden":false},{"input":"\"1.0.1\"\n\"1\"","expectedOutput":1,"isHidden":false},{"input":"\"7.5.2.4\"\n\"7.5.3\"","expectedOutput":-1,"isHidden":false},{"input":"\"1.0.0.0\"\n\"1\"","expectedOutput":0,"isHidden":true},{"input":"\"1.10\"\n\"1.2\"","expectedOutput":1,"isHidden":true},{"input":"\"1.0.0.0.0.1\"\n\"1.0.0.0.0.0\"","expectedOutput":1,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\nvar compareVersion = function(version1, version2) {\n    const v1Revisions = version1.split('.');\n    const v2Revisions = version2.split('.');\n\n    const maxLength = Math.max(v1Revisions.length, v2Revisions.length);\n\n    for (let i = 0; i < maxLength; i++) {\n        const num1 = i < v1Revisions.length ? parseInt(v1Revisions[i], 10) : 0;\n        const num2 = i < v2Revisions.length ? parseInt(v2Revisions[i], 10) : 0;\n\n        if (num1 < num2) {\n            return -1;\n        } else if (num1 > num2) {\n            return 1;\n        }\n    }\n\n    return 0;\n};"}}}
{"leetcodeId":164,"title":"Maximum Gap","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumGap = function(nums) {\n\n};","python":"from typing import List\n\ndef maximum_gap(nums: List[int]) -> int:\n    pass","typescript":"function maximumGap(nums: number[]): number {\n\n};"},"testCases":[{"input":"[3,6,9,1]","expectedOutput":3,"isHidden":false},{"input":"[10]","expectedOutput":0,"isHidden":false},{"input":"[1,1,1,1]","expectedOutput":0,"isHidden":true},{"input":"[1,5,2,8]","expectedOutput":3,"isHidden":true},{"input":"[100,3,2,1]","expectedOutput":97,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumGap = function(nums) {\n    if (nums.length < 2) {\n        return 0;\n    }\n\n    // Radix Sort implementation for non-negative integers\n    function radixSort(arr) {\n        let maxVal = 0;\n        for (let num of arr) {\n            maxVal = Math.max(maxVal, num);\n        }\n\n        let exp = 1;\n        while (Math.floor(maxVal / exp) > 0) {\n            let output = new Array(arr.length).fill(0);\n            let count = new Array(10).fill(0);\n\n            for (let i = 0; i < arr.length; i++) {\n                count[Math.floor(arr[i] / exp) % 10]++;\n            }\n\n            for (let i = 1; i < 10; i++) {\n                count[i] += count[i - 1];\n            }\n\n            for (let i = arr.length - 1; i >= 0; i--) {\n                output[count[Math.floor(arr[i] / exp) % 10] - 1] = arr[i];\n                count[Math.floor(arr[i] / exp) % 10]--;\n            }\n\n            for (let i = 0; i < arr.length; i++) {\n                arr[i] = output[i];\n            }\n            exp *= 10;\n        }\n        return arr;\n    }\n\n    const sortedNums = radixSort(nums);\n\n    let maxDiff = 0;\n    for (let i = 1; i < sortedNums.length; i++) {\n        maxDiff = Math.max(maxDiff, sortedNums[i] - sortedNums[i - 1]);\n    }\n\n    return maxDiff;\n};"}}}
{"leetcodeId":163,"title":"Missing Ranges","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} lower\n * @param {number} upper\n * @return {string[]}\n */\nvar findMissingRanges = function(nums, lower, upper) {\n    \n};\n","python":"from typing import List\n\ndef findMissingRanges(nums: List[int], lower: int, upper: int) -> List[str]:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @param {number} lower\n * @param {number} upper\n * @return {string[]}\n */\nfunction findMissingRanges(nums: number[], lower: number, upper: number): string[] {\n\n};\n"},"testCases":[{"input":"[0,1,3,50,75]\n0\n99","expectedOutput":"[\"2\",\"4->49\",\"51->74\",\"76->99\"]","isHidden":false},{"input":"[]\n1\n1","expectedOutput":"[\"1\"]","isHidden":false},{"input":"[]\n-3\n-1","expectedOutput":"[\"-3->-1\"]","isHidden":false},{"input":"[-1]\n-1\n-1","expectedOutput":"[]","isHidden":false},{"input":"[-1]\n-2\n-1","expectedOutput":"[\"-2\"]","isHidden":false},{"input":"[1,2,3]\n1\n3","expectedOutput":"[]","isHidden":true},{"input":"[]\n-1000000000\n1000000000","expectedOutput":"[\"-1000000000->1000000000\"]","isHidden":true},{"input":"[10]\n0\n10","expectedOutput":"[\"0->9\"]","isHidden":true},{"input":"[0]\n0\n10","expectedOutput":"[\"1->10\"]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} lower\n * @param {number} upper\n * @return {string[]}\n */\nvar findMissingRanges = function(nums, lower, upper) {\n    const result = [];\n\n    const formatRange = (start, end) => {\n        if (start === end) {\n            return String(start);\n        } else {\n            return `${start}->${end}`;\n        }\n    };\n\n    let current = lower;\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > current) {\n            result.push(formatRange(current, nums[i] - 1));\n        }\n        // Update current to be one greater than the current number in nums\n        // This handles cases where nums[i] is equal to current, effectively skipping it\n        // And also prepares for the next potential missing range\n        current = nums[i] + 1;\n    }\n\n    // After iterating through nums, check for any missing range from current to upper\n    if (current <= upper) {\n        result.push(formatRange(current, upper));\n    }\n\n    return result;\n};\n"}}}
{"leetcodeId":156,"title":"Binary Tree Upside Down","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nfunction upsideDownBinaryTree(root) {\n  // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def upsideDownBinaryTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode | null} root\n * @return {TreeNode | null}\n */\nfunction upsideDownBinaryTree(root: TreeNode | null): TreeNode | null {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":5,\"left\":null,\"right\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":null}}","expectedOutput":"{\"val\":4,\"left\":{\"val\":5,\"left\":null,\"right\":null},\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":1,\"left\":null,\"right\":null}}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":null}","expectedOutput":"{\"val\":1,\"left\":null,\"right\":null}","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"{\"val\":2,\"left\":null,\"right\":{\"val\":1,\"left\":null,\"right\":null}}","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":{\"val\":8,\"left\":null,\"right\":null},\"right\":{\"val\":9,\"left\":null,\"right\":null}},\"right\":{\"val\":5,\"left\":{\"val\":10,\"left\":null,\"right\":null},\"right\":null}},\"right\":{\"val\":3,\"left\":{\"val\":6,\"left\":null,\"right\":null},\"right\":{\"val\":7,\"left\":null,\"right\":null}}}","expectedOutput":"{\"val\":8,\"left\":{\"val\":9,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":{\"val\":10,\"left\":null,\"right\":null},\"right\":{\"val\":2,\"left\":{\"val\":6,\"left\":null,\"right\":null},\"right\":{\"val\":1,\"left\":{\"val\":7,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nfunction upsideDownBinaryTree(root) {\n  if (!root || !root.left) {\n    return root;\n  }\n\n  let newRoot = upsideDownBinaryTree(root.left);\n\n  // The original left child (root.left) becomes the new root.\n  // The original root becomes the new right child of the original left child.\n  // The original right child (root.right) becomes the new left child of the original left child.\n  root.left.left = root.right; // Original right child becomes new left child\n  root.left.right = root;     // Original root becomes new right child\n\n  // Disconnect the original connections to avoid cycles\n  root.left = null;\n  root.right = null;\n\n  return newRoot;\n}"}}}
{"leetcodeId":161,"title":"One Edit Distance","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isOneEditDistance = function(s, t) {\n    \n};","python":"def is_one_edit_distance(s: str, t: str) -> bool:\n    pass","typescript":"/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nfunction isOneEditDistance(s: string, t: string): boolean {\n\n};"},"testCases":[{"input":"\"ab\"\n\"acb\"","expectedOutput":true,"isHidden":false},{"input":"\"\"\n\"\"","expectedOutput":false,"isHidden":false},{"input":"\"a\"\n\"\"","expectedOutput":true,"isHidden":false},{"input":"\"\"\n\"A\"","expectedOutput":true,"isHidden":false},{"input":"\"pale\"\n\"ple\"","expectedOutput":true,"isHidden":true},{"input":"\"pales\"\n\"pale\"","expectedOutput":true,"isHidden":true},{"input":"\"pale\"\n\"bale\"","expectedOutput":true,"isHidden":true},{"input":"\"pale\"\n\"bake\"","expectedOutput":false,"isHidden":true},{"input":"\"a\"\n\"b\"","expectedOutput":true,"isHidden":true},{"input":"\"ab\"\n\"ba\"","expectedOutput":false,"isHidden":true},{"input":"\"abc\"\n\"axc\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"ab\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"abcd\"","expectedOutput":true,"isHidden":true},{"input":"\"abc\"\n\"abc\"","expectedOutput":false,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isOneEditDistance = function(s, t) {\n    const n = s.length;\n    const m = t.length;\n\n    // Ensure s is always the shorter or equal length string\n    if (n > m) {\n        return isOneEditDistance(t, s);\n    }\n\n    // If difference in lengths is more than 1, it's not one edit distance\n    if (m - n > 1) {\n        return false;\n    }\n\n    // Case 1: Same length strings (replace operation)\n    if (n === m) {\n        let diffCount = 0;\n        for (let i = 0; i < n; i++) {\n            if (s[i] !== t[i]) {\n                diffCount++;\n            }\n        }\n        return diffCount === 1;\n    }\n\n    // Case 2: Difference in length is 1 (insert/delete operation)\n    // s is shorter, t is longer (m = n + 1)\n    let i = 0; // pointer for s\n    let j = 0; // pointer for t\n    let diffFound = false;\n\n    while (i < n && j < m) {\n        if (s[i] !== t[j]) {\n            if (diffFound) {\n                return false; // Second difference found\n            }\n            diffFound = true;\n            // Only advance j (effectively inserting a character into s to match t[j])\n            j++;\n        } else {\n            i++;\n            j++;\n        }\n    }\n\n    // If we reach here, it means either:\n    // 1. One difference was found and handled (e.g., s=\"ab\", t=\"acb\")\n    // 2. No difference was found until the end of s (e.g., s=\"ab\", t=\"abc\")\n    // In both cases, it's one edit distance if diffFound is true or if we reached the end of s and t has one extra char\n    return true;\n};"}}}
{"leetcodeId":160,"title":"Intersection of Two Linked Lists","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    \n};","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        ","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode | null}\n */\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n\n};"},"testCases":[{"input":"{\"_is_ListNode\":true,\"val\":4,\"next\":{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":8,\"next\":{\"_is_ListNode\":true,\"val\":4,\"next\":{\"_is_ListNode\":true,\"val\":5,\"next\":null}}}}}\n{\"_is_ListNode\":true,\"val\":5,\"next\":{\"_is_ListNode\":true,\"val\":6,\"next\":{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":8,\"next\":{\"_is_ListNode\":true,\"val\":4,\"next\":{\"_is_ListNode\":true,\"val\":5,\"next\":null}}}}}}","expectedOutput":"{\"_is_ListNode\":true,\"val\":8,\"next\":{\"_is_ListNode\":true,\"val\":4,\"next\":{\"_is_ListNode\":true,\"val\":5,\"next\":null}}}","isHidden":false},{"input":"{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":9,\"next\":{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":2,\"next\":{\"_is_ListNode\":true,\"val\":4,\"next\":null}}}}}\n{\"_is_ListNode\":true,\"val\":3,\"next\":{\"_is_ListNode\":true,\"val\":2,\"next\":{\"_is_ListNode\":true,\"val\":4,\"next\":null}}}","expectedOutput":"{\"_is_ListNode\":true,\"val\":2,\"next\":{\"_is_ListNode\":true,\"val\":4,\"next\":null}}","isHidden":false},{"input":"{\"_is_ListNode\":true,\"val\":2,\"next\":{\"_is_ListNode\":true,\"val\":6,\"next\":{\"_is_ListNode\":true,\"val\":4,\"next\":null}}}\n{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":5,\"next\":null}}","expectedOutput":null,"isHidden":false},{"input":"null\nnull","expectedOutput":null,"isHidden":true},{"input":"{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":2,\"next\":null}}\nnull","expectedOutput":null,"isHidden":true},{"input":"null\n{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":2,\"next\":null}}","expectedOutput":null,"isHidden":true},{"input":"{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":2,\"next\":{\"_is_ListNode\":true,\"val\":3,\"next\":null}}}\n{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":2,\"next\":{\"_is_ListNode\":true,\"val\":3,\"next\":null}}}","expectedOutput":"{\"_is_ListNode\":true,\"val\":1,\"next\":{\"_is_ListNode\":true,\"val\":2,\"next\":{\"_is_ListNode\":true,\"val\":3,\"next\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) {\n        return null;\n    }\n\n    let pointerA = headA;\n    let pointerB = headB;\n\n    // Traverse both lists. If a pointer reaches the end of its list,\n    // redirect it to the head of the other list. They will meet at the\n    // intersection node or at null if there's no intersection.\n    while (pointerA !== pointerB) {\n        pointerA = pointerA ? pointerA.next : headB;\n        pointerB = pointerB ? pointerB.next : headA;\n    }\n\n    return pointerA;\n};"}}}
{"leetcodeId":157,"title":"Read N Characters Given Read4","codingData":{"starterCode":{"javascript":"/**\n * Definition for read4()\n * \n * @param {character[]} buf4 Destination buffer\n * @return {number} The number of actual characters read\n */\nconst read4 = function(buf4) {\n    // Replace this with the actual read4 implementation provided by LeetCode\n    // For local testing, you might mock it like this:\n    // let fileContent = \"\"; // This would be set by the test runner\n    // let filePointer = 0;\n    // const charsToRead = Math.min(4, fileContent.length - filePointer);\n    // for (let i = 0; i < charsToRead; i++) {\n    //     buf4[i] = fileContent[filePointer + i];\n    // }\n    // filePointer += charsToRead;\n    // return charsToRead;\n    throw new Error(\"read4 is not implemented. This function is provided by the LeetCode environment.\");\n};\n\n/**\n * @param {character[]} buf Destination buffer\n * @param {number} n Number of characters to read\n * @return {number} The number of actual characters read\n */\nconst read = function(buf, n) {\n    // Implement your solution here\n};\n","python":"# The read4 API is already defined for you.\n# def read4(buf4: list[str]) -> int:\n#     pass\n\nclass Solution:\n    def read(self, buf: list[str], n: int) -> int:\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Number of characters to read (int)\n        :rtype: The number of actual characters read (int)\n        \"\"\"\n        # Implement your solution here\n        pass\n","typescript":"/**\n * Definition for read4()\n * \n * @param {character[]} buf4 Destination buffer\n * @return {number} The number of actual characters read\n */\ndeclare function read4(buf4: character[]): number;\n\n/**\n * @param {character[]} buf Destination buffer\n * @param {number} n Number of characters to read\n * @return {number} The number of actual characters read\n */\nfunction read(buf: character[], n: number): number {\n    // Implement your solution here\n    return 0;\n};\n"},"testCases":[{"input":"[\"a\",\"b\",\"c\"]\n4","expectedOutput":3,"isHidden":false},{"input":"[\"a\",\"b\",\"c\",\"d\",\"e\"]\n5","expectedOutput":5,"isHidden":false},{"input":"[\"a\",\"b\",\"c\",\"d\",\"A\",\"B\",\"C\",\"D\",\"1\",\"2\",\"3\",\"4\"]\n12","expectedOutput":12,"isHidden":false},{"input":"[\"l\",\"e\",\"e\",\"t\",\"c\",\"o\",\"d\",\"e\"]\n5","expectedOutput":5,"isHidden":false},{"input":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n10","expectedOutput":10,"isHidden":true},{"input":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n26","expectedOutput":26,"isHidden":true},{"input":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n1","expectedOutput":1,"isHidden":true},{"input":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n0","expectedOutput":0,"isHidden":true},{"input":"[]\n10","expectedOutput":0,"isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for read4()\n * \n * @param {character[]} buf4 Destination buffer\n * @return {number} The number of actual characters read\n */\n// const read4 = function(buf4) {\n//     // This is a placeholder for the actual read4 implementation provided by LeetCode.\n//     // For local testing, you would need to mock this function.\n//     throw new Error(\"read4 is not implemented. This function is provided by the LeetCode environment.\");\n// };\n\n/**\n * @param {character[]} buf Destination buffer\n * @param {number} n Number of characters to read\n * @return {number} The number of actual characters read\n */\nconst read = function(buf, n) {\n    let totalCharsRead = 0;\n    let eof = false;\n    const buf4 = new Array(4);\n\n    while (totalCharsRead < n && !eof) {\n        // Read up to 4 characters into buf4\n        const charsFromRead4 = read4(buf4);\n\n        // If read4 returns less than 4, it means we've reached the end of the file\n        if (charsFromRead4 < 4) {\n            eof = true;\n        }\n\n        // Copy characters from buf4 to the destination buffer 'buf'\n        // We should copy at most 'n - totalCharsRead' characters\n        // and at most 'charsFromRead4' characters\n        const charsToCopy = Math.min(n - totalCharsRead, charsFromRead4);\n\n        for (let i = 0; i < charsToCopy; i++) {\n            buf[totalCharsRead + i] = buf4[i];\n        }\n\n        totalCharsRead += charsToCopy;\n    }\n\n    return totalCharsRead;\n};\n"}}}
{"leetcodeId":158,"title":"Read N Characters Given Read4 II - Call multiple times","codingData":{"starterCode":{"javascript":"/**\n * Definition for read4()\n * \n * @param {character[]} buf4 Destination buffer\n * @return {number} The number of actual characters read\n */\nconst read4 = function(buf4) {\n  // Replace with actual read4 implementation in a real environment\n  // For testing purposes, this will be provided by the test runner\n  return 0;\n};\n\n/**\n * @param {character[]} buf Destination buffer\n * @param {number} n Number of characters to read\n * @return {number} The number of actual characters read\n */\nvar solution = function(read4) {\n  // Persistent buffer and pointers for multiple calls\n  let buffer = [];\n  let bufferPtr = 0;\n  let bufferCnt = 0;\n\n  /**\n   * @param {character[]} buf Destination buffer\n   * @param {number} n Number of characters to read\n   * @return {number} The number of actual characters read\n   */\n  return function(buf, n) {\n    let charsRead = 0;\n    while (charsRead < n) {\n      if (bufferPtr === bufferCnt) {\n        // Buffer is empty, read more from file\n        bufferPtr = 0;\n        bufferCnt = read4(buffer);\n        if (bufferCnt === 0) {\n          // No more characters in file\n          break;\n        }\n      }\n\n      while (charsRead < n && bufferPtr < bufferCnt) {\n        buf[charsRead++] = buffer[bufferPtr++];\n      }\n    }\n    return charsRead;\n  };\n};\n","python":"# The read4 API is already defined for you.\n# def read4(buf4: List[str]) -> int:\n\nclass Solution:\n    def __init__(self):\n        self.buffer = [''] * 4  # Persistent buffer for leftover characters\n        self.buffer_ptr = 0    # Pointer to the next character to read from self.buffer\n        self.buffer_cnt = 0    # Number of characters currently in self.buffer\n\n    def read(self, buf: List[str], n: int) -> int:\n        \"\"\"\n        :type buf: List[str]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        chars_read = 0\n        while chars_read < n:\n            if self.buffer_ptr == self.buffer_cnt:\n                # Buffer is empty, read more from file\n                self.buffer_ptr = 0\n                self.buffer_cnt = read4(self.buffer)\n                if self.buffer_cnt == 0:\n                    # No more characters in file\n                    break\n            \n            while chars_read < n and self.buffer_ptr < self.buffer_cnt:\n                buf[chars_read] = self.buffer[self.buffer_ptr]\n                chars_read += 1\n                self.buffer_ptr += 1\n                \n        return chars_read\n","typescript":"/**\n * Definition for read4()\n * \n * @param {character[]} buf4 Destination buffer\n * @return {number} The number of actual characters read\n */\ndeclare function read4(buf4: character[]): number;\n\ninterface SolutionInterface {\n    read(buf: character[], n: number): number;\n}\n\nclass Solution implements SolutionInterface {\n    private buffer: character[] = new Array(4);\n    private bufferPtr: number = 0;\n    private bufferCnt: number = 0;\n\n    /**\n     * @param {character[]} buf Destination buffer\n     * @param {number} n Number of characters to read\n     * @return {number} The number of actual characters read\n     */\n    read(buf: character[], n: number): number {\n        let charsRead: number = 0;\n        while (charsRead < n) {\n            if (this.bufferPtr === this.bufferCnt) {\n                // Buffer is empty, read more from file\n                this.bufferPtr = 0;\n                this.bufferCnt = read4(this.buffer);\n                if (this.bufferCnt === 0) {\n                    // No more characters in file\n                    break;\n                }\n            }\n\n            while (charsRead < n && this.bufferPtr < this.bufferCnt) {\n                buf[charsRead++] = this.buffer[this.bufferPtr++];\n            }\n        }\n        return charsRead;\n    }\n}\n"},"testCases":[{"input":"\"abc\"\n[1,2,1]","expectedOutput":"[1,2,0]","isHidden":false},{"input":"\"abc\"\n[4,1]","expectedOutput":"[3,0]","isHidden":false},{"input":"\"abcdefg\"\n[2,3,5]","expectedOutput":"[2,3,2]","isHidden":true},{"input":"\"a\"\n[1,1]","expectedOutput":"[1,0]","isHidden":true},{"input":"\"\"\n[1,1]","expectedOutput":"[0,0]","isHidden":true},{"input":"\"longstringwithmanycharacters\"\n[3,5,10,20]","expectedOutput":"[3,5,10,10]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for read4()\n * \n * @param {character[]} buf4 Destination buffer\n * @return {number} The number of actual characters read\n */\nconst read4 = function(buf4) {\n  // This will be provided by the test runner\n  return 0;\n};\n\n/**\n * @param {character[]} buf Destination buffer\n * @param {number} n Number of characters to read\n * @return {number} The number of actual characters read\n */\nvar solution = function(read4) {\n  // Persistent buffer and pointers for multiple calls\n  let buffer = new Array(4);\n  let bufferPtr = 0;\n  let bufferCnt = 0;\n\n  /**\n   * @param {character[]} buf Destination buffer\n   * @param {number} n Number of characters to read\n   * @return {number} The number of actual characters read\n   */\n  return function(buf, n) {\n    let charsRead = 0;\n    while (charsRead < n) {\n      if (bufferPtr === bufferCnt) {\n        // Buffer is empty or fully consumed, read more from file\n        bufferPtr = 0;\n        bufferCnt = read4(buffer);\n        if (bufferCnt === 0) {\n          // No more characters in file\n          break;\n        }\n      }\n\n      // Copy characters from internal buffer to destination buf\n      while (charsRead < n && bufferPtr < bufferCnt) {\n        buf[charsRead++] = buffer[bufferPtr++];\n      }\n    }\n    return charsRead;\n  };\n};\n"}}}
{"leetcodeId":172,"title":"Factorial Trailing Zeroes","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar trailingZeroes = function(n) {\n    \n};\n","python":"def trailingZeroes(n: int) -> int:\n    pass\n","typescript":"/**\n * @param {number} n\n * @return {number}\n */\nfunction trailingZeroes(n: number): number {\n\n};\n"},"testCases":[{"input":"3","expectedOutput":0,"isHidden":false},{"input":"5","expectedOutput":1,"isHidden":false},{"input":"0","expectedOutput":0,"isHidden":false},{"input":"10","expectedOutput":2,"isHidden":true},{"input":"25","expectedOutput":6,"isHidden":true},{"input":"10000","expectedOutput":2499,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar trailingZeroes = function(n) {\n    let count = 0;\n    while (n >= 5) {\n        n = Math.floor(n / 5);\n        count += n;\n    }\n    return count;\n};\n"}}}
{"leetcodeId":171,"title":"Excel Sheet Column Number","codingData":{"starterCode":{"javascript":"/**\n * @param {string} columnTitle\n * @return {number}\n */\nvar titleToNumber = function(columnTitle) {\n    \n};\n","python":"def title_to_number(columnTitle: str) -> int:\n    pass\n","typescript":"function titleToNumber(columnTitle: string): number {\n\n};\n"},"testCases":[{"input":"\"A\"","expectedOutput":1,"isHidden":false},{"input":"\"AB\"","expectedOutput":28,"isHidden":false},{"input":"\"ZY\"","expectedOutput":701,"isHidden":false},{"input":"\"FXSHRXW\"","expectedOutput":2147483647,"isHidden":false},{"input":"\"Z\"","expectedOutput":26,"isHidden":true},{"input":"\"AAA\"","expectedOutput":703,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} columnTitle\n * @return {number}\n */\nvar titleToNumber = function(columnTitle) {\n    let result = 0;\n    for (let i = 0; i < columnTitle.length; i++) {\n        const charCode = columnTitle.charCodeAt(i) - 'A'.charCodeAt(0) + 1;\n        result = result * 26 + charCode;\n    }\n    return result;\n};\n"}}}
{"leetcodeId":167,"title":"Two Sum II - Input array is sorted","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n    \n};","python":"def two_sum(numbers: list[int], target: int) -> list[int]:\n    \"\"\"\n    :param numbers: An array of integers sorted in ascending order.\n    :param target: The target sum.\n    :return: The 1-indexed indices of the two numbers that add up to the target.\n    \"\"\"\n    pass","typescript":"/**\n * @param numbers An array of integers sorted in ascending order.\n * @param target The target sum.\n * @return The 1-indexed indices of the two numbers that add up to the target.\n */\nfunction twoSum(numbers: number[], target: number): number[] {\n\n};"},"testCases":[{"input":"[2,7,11,15]\n9","expectedOutput":"[1,2]","isHidden":false},{"input":"[2,3,4]\n6","expectedOutput":"[1,3]","isHidden":false},{"input":"[-1,0]\n-1","expectedOutput":"[1,2]","isHidden":false},{"input":"[0,0,3,4]\n0","expectedOutput":"[1,2]","isHidden":true},{"input":"[5,25,75]\n100","expectedOutput":"[2,3]","isHidden":true},{"input":"[1,2,3,4,5,6,7,8,9,10]\n19","expectedOutput":"[9,10]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n    let left = 0;\n    let right = numbers.length - 1;\n\n    while (left < right) {\n        const sum = numbers[left] + numbers[right];\n\n        if (sum === target) {\n            return [left + 1, right + 1];\n        } else if (sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    // As per problem constraints, exactly one solution exists, so this line should not be reached.\n    return []; \n};"}}}
{"leetcodeId":168,"title":"Excel Sheet Column Title","codingData":{"starterCode":{"javascript":"/**\n * @param {number} columnNumber\n * @return {string}\n */\nvar convertToTitle = function(columnNumber) {\n\n};\n","python":"def convert_to_title(column_number: int) -> str:\n    pass\n","typescript":"function convertToTitle(columnNumber: number): string {\n\n};\n"},"testCases":[{"input":"1","expectedOutput":"A","isHidden":false},{"input":"28","expectedOutput":"AB","isHidden":false},{"input":"701","expectedOutput":"ZY","isHidden":false},{"input":"2147483647","expectedOutput":"FXSHRXW","isHidden":false},{"input":"26","expectedOutput":"Z","isHidden":true},{"input":"52","expectedOutput":"AZ","isHidden":true},{"input":"703","expectedOutput":"AAA","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} columnNumber\n * @return {string}\n */\nvar convertToTitle = function(columnNumber) {\n    let result = [];\n    while (columnNumber > 0) {\n        columnNumber--; // Adjust to 0-indexed (A=0, B=1, ..., Z=25)\n        const remainder = columnNumber % 26;\n        result.push(String.fromCharCode(65 + remainder)); // 65 is ASCII for 'A'\n        columnNumber = Math.floor(columnNumber / 26);\n    }\n    return result.reverse().join('');\n};\n"}}}
{"leetcodeId":177,"title":"Nth Highest Salary","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {string}\n */\nvar getNthHighestSalary = function(n) {\n    // This is a SQL problem, so the JavaScript function will return a SQL query string.\n    // Implement your SQL logic here to construct the query.\n    // Example: SELECT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET (n - 1);\n    return ``;\n};","python":"def getNthHighestSalary(n: int) -> str:\n    \"\"\"\n    This is a SQL problem, so the Python function will return a SQL query string.\n    Implement your SQL logic here to construct the query.\n    Example: SELECT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET (n - 1);\n    \"\"\"\n    return \"\"","typescript":"/**\n * @param {number} n\n * @return {string}\n */\nfunction getNthHighestSalary(n: number): string {\n    // This is a SQL problem, so the TypeScript function will return a SQL query string.\n    // Implement your SQL logic here to construct the query.\n    // Example: SELECT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET (n - 1);\n    return ``;\n}"},"testCases":[{"input":"2","expectedOutput":"SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1;","isHidden":false},{"input":"1","expectedOutput":"SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 0;","isHidden":true},{"input":"3","expectedOutput":"SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 2;","isHidden":true},{"input":"0","expectedOutput":"SELECT NULL AS \"getNthHighestSalary(0)\";","isHidden":true},{"input":"5","expectedOutput":"SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 4;","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {string}\n */\nvar getNthHighestSalary = function(n) {\n    if (n <= 0) {\n        return `SELECT NULL AS \"getNthHighestSalary(${n})\"`;\n    }\n    // The problem asks for the nth highest salary, which implies distinct salaries.\n    // If there are duplicate salaries, we should still count them as one rank.\n    // For example, if salaries are 300, 200, 200, 100, the 2nd highest is 200.\n    // Using DISTINCT ensures we consider unique salary values for ranking.\n    // LIMIT 1 OFFSET (n - 1) fetches the nth distinct salary after sorting in descending order.\n    return `SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET ${n - 1};`;\n};"}}}
{"leetcodeId":174,"title":"Dungeon Game","codingData":{"starterCode":{"javascript":"/**\n * @param {number[][]} dungeon\n * @return {number}\n */\nvar calculateMinimumHP = function(dungeon) {\n    \n};\n","python":"class Solution:\n    def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:\n        \n","typescript":"function calculateMinimumHP(dungeon: number[][]): number {\n\n};\n"},"testCases":[{"input":"[[-2,-3,3],[-5,-10,1],[10,30,-5]]","expectedOutput":7,"isHidden":false},{"input":"[[0]]","expectedOutput":1,"isHidden":false},{"input":"[[100]]","expectedOutput":1,"isHidden":true},{"input":"[[-1]]","expectedOutput":2,"isHidden":true},{"input":"[[1,-3,3],[0,-2,0],[-3,-3,-3]]","expectedOutput":3,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[][]} dungeon\n * @return {number}\n */\nvar calculateMinimumHP = function(dungeon) {\n    const m = dungeon.length;\n    const n = dungeon[0].length;\n\n    // dp[i][j] represents the minimum health needed when entering cell (i, j)\n    // to survive until the end.\n    // We need to initialize dp table with dimensions (m+1) x (n+1) to handle boundary conditions.\n    // Initialize with Infinity, except for the target cell's adjacent cells.\n    const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(Infinity));\n\n    // Base cases: To survive the last cell (m-1, n-1), the health needed upon entering\n    // the 'virtual' cells to its right or bottom should be 1.\n    // This ensures that when we calculate for (m-1, n-1), min(dp[m][n-1], dp[m-1][n])\n    // will correctly reflect the minimum health needed to proceed from there.\n    dp[m][n - 1] = 1;\n    dp[m - 1][n] = 1;\n\n    // Iterate from bottom-right to top-left\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            // The minimum health required to exit this cell (i, j) and proceed\n            // to either (i+1, j) or (i, j+1) is the minimum of the healths\n            // required for those next steps.\n            const minHealthNeededFromNext = Math.min(dp[i + 1][j], dp[i][j + 1]);\n\n            // The health required upon entering cell (i, j) is:\n            // minHealthNeededFromNext - dungeon[i][j]\n            // If this value is 0 or less, it means the current cell's value\n            // is enough to cover the deficit and still have at least 1 health.\n            // So, the minimum health needed upon entering (i, j) is 1.\n            dp[i][j] = Math.max(1, minHealthNeededFromNext - dungeon[i][j]);\n        }\n    }\n\n    // The result is the minimum health needed when entering the top-left cell (0, 0).\n    return dp[0][0];\n};\n"}}}
{"leetcodeId":166,"title":"Fraction to Recurring Decimal","codingData":{"starterCode":{"javascript":"/**\n * @param {number} numerator\n * @param {number} denominator\n * @return {string}\n */\nvar fractionToDecimal = function(numerator, denominator) {\n    \n};","python":"def fractionToDecimal(numerator: int, denominator: int) -> str:\n    pass","typescript":"function fractionToDecimal(numerator: number, denominator: number): string {\n\n};"},"testCases":[{"input":"1\n2","expectedOutput":"0.5","isHidden":false},{"input":"2\n1","expectedOutput":"2","isHidden":false},{"input":"2\n3","expectedOutput":"0.(6)","isHidden":false},{"input":"4\n333","expectedOutput":"0.(012)","isHidden":false},{"input":"1\n5","expectedOutput":"0.2","isHidden":false},{"input":"1\n-2","expectedOutput":"-0.5","isHidden":true},{"input":"-50\n8","expectedOutput":"-6.25","isHidden":true},{"input":"7\n-12","expectedOutput":"-0.58(3)","isHidden":true},{"input":"0\n-5","expectedOutput":"0","isHidden":true},{"input":"-1\n-2147483648","expectedOutput":"0.0000000004656612873077392578125","isHidden":true},{"input":"-2147483648\n1","expectedOutput":"-2147483648","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} numerator\n * @param {number} denominator\n * @return {string}\n */\nvar fractionToDecimal = function(numerator, denominator) {\n    if (numerator === 0) {\n        return \"0\";\n    }\n\n    let result = [];\n\n    // Determine the sign\n    if ((numerator < 0) !== (denominator < 0)) {\n        result.push(\"-\");\n    }\n\n    // Use absolute values for calculation\n    let num = Math.abs(numerator);\n    let den = Math.abs(denominator);\n\n    // Integer part\n    result.push(Math.floor(num / den));\n\n    let remainder = num % den;\n    if (remainder === 0) {\n        return result.join(\"\");\n    }\n\n    result.push(\".\");\n\n    // Fractional part\n    let remainderMap = new Map(); // Stores remainder -> index in result array\n    let fractionalPartStart = result.length;\n\n    while (remainder !== 0 && !remainderMap.has(remainder)) {\n        remainderMap.set(remainder, result.length);\n        remainder *= 10;\n        result.push(Math.floor(remainder / den));\n        remainder %= den;\n    }\n\n    if (remainder !== 0) {\n        // Repeating part found\n        let insertIndex = remainderMap.get(remainder);\n        result.splice(insertIndex, 0, \"(\");\n        result.push(\")\");\n    }\n\n    return result.join(\"\");\n};"}}}
{"leetcodeId":170,"title":"Two Sum III - Data structure design","codingData":{"starterCode":{"javascript":"/**\n * Initializes the TwoSum object.\n */\nvar TwoSum = function() {\n    \n};\n\n/** \n * @param {number} number\n * @return {void}\n */\nTwoSum.prototype.add = function(number) {\n    \n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nTwoSum.prototype.find = function(value) {\n    \n};\n\n/** \n * Your TwoSum object will be instantiated and called as such:\n * var obj = new TwoSum()\n * obj.add(number)\n * var param_2 = obj.find(value)\n */","python":"class TwoSum:\n\n    def __init__(self):\n        \"\"\"\n        Initializes the TwoSum object.\n        \"\"\"\n        \n\n    def add(self, number: int) -> None:\n        \"\"\"\n        Adds 'number' to the data structure.\n        \"\"\"\n        \n\n    def find(self, value: int) -> bool:\n        \"\"\"\n        Returns 'true' if there exists any pair of numbers whose sum is equal to 'value', otherwise, it returns 'false'.\n        \"\"\"\n        \n\n\n# Your TwoSum object will be instantiated and called as such:\n# obj = TwoSum()\n# obj.add(number)\n# param_2 = obj.find(value)","typescript":"class TwoSum {\n    /**\n     * Initializes the TwoSum object.\n     */\n    constructor() {\n\n    }\n\n    /**\n     * @param number\n     * @return void\n     */\n    add(number: number): void {\n\n    }\n\n    /**\n     * @param value\n     * @return boolean\n     */\n    find(value: number): boolean {\n\n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * var obj = new TwoSum()\n * obj.add(number)\n * var param_2 = obj.find(value)\n */"},"testCases":[{"input":"[\"TwoSum\", \"add\", \"add\", \"add\", \"find\", \"find\"]\n[[], [1], [3], [5], [4], [7]]","expectedOutput":"[null, null, null, null, true, false]","isHidden":false},{"input":"[\"TwoSum\", \"add\", \"add\", \"find\", \"add\", \"find\"]\n[[], [0], [0], [0], [1], [1]]","expectedOutput":"[null, null, null, true, null, true]","isHidden":true},{"input":"[\"TwoSum\", \"add\", \"find\", \"add\", \"find\"]\n[[], [3], [6], [3], [6]]","expectedOutput":"[null, null, false, null, true]","isHidden":true},{"input":"[\"TwoSum\", \"add\", \"add\", \"add\", \"add\", \"add\", \"find\", \"find\", \"find\", \"find\"]\n[[], [100000], [-100000], [1], [0], [0], [0], [1], [100000], [-100000]]","expectedOutput":"[null, null, null, null, null, null, true, true, true, true]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Initializes the TwoSum object.\n */\nvar TwoSum = function() {\n    this.counts = new Map();\n};\n\n/** \n * @param {number} number\n * @return {void}\n */\nTwoSum.prototype.add = function(number) {\n    this.counts.set(number, (this.counts.get(number) || 0) + 1);\n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nTwoSum.prototype.find = function(value) {\n    for (const [num, count] of this.counts.entries()) {\n        const complement = value - num;\n        if (this.counts.has(complement)) {\n            if (complement === num) {\n                // If the complement is the same number, we need at least two occurrences\n                if (count >= 2) {\n                    return true;\n                }\n            } else {\n                // If the complement is a different number, one occurrence is enough\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/** \n * Your TwoSum object will be instantiated and called as such:\n * var obj = new TwoSum()\n * obj.add(number)\n * var param_2 = obj.find(value)\n */"}}}
{"leetcodeId":173,"title":"Binary Search Tree Iterator","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n    \n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n    \n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: TreeNode):\n        \n\n    def next(self) -> int:\n        \n\n    def hasNext(self) -> bool:\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass BSTIterator {\n    /**\n     * @param {TreeNode} root\n     */\n    constructor(root: TreeNode | null) {\n\n    }\n\n    /**\n     * @return {number}\n     */\n    next(): number {\n\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasNext(): boolean {\n\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"},"testCases":[{"input":"[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]","expectedOutput":"[null, 3, 7, true, 9, true, 15, true, 20, false]","isHidden":false},{"input":"[\"BSTIterator\", \"next\", \"hasNext\"]\n[[[1]], [], []]","expectedOutput":"[null, 1, false]","isHidden":true},{"input":"[\"BSTIterator\", \"hasNext\", \"next\", \"hasNext\"]\n[[[5, 3, 8, 1, 4, 6, 9]], [], [], []]","expectedOutput":"[null, true, 1, true]","isHidden":true},{"input":"[\"BSTIterator\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next"}]}}
{"leetcodeId":169,"title":"Majority Element","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n\n};","python":"def majority_element(nums: list[int]) -> int:\n    pass","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction majorityElement(nums: number[]): number {\n\n};"},"testCases":[{"input":"[3,2,3]","expectedOutput":3,"isHidden":false},{"input":"[2,2,1,1,1,2,2]","expectedOutput":2,"isHidden":false},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[6,5,5]","expectedOutput":5,"isHidden":true},{"input":"[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7"}]}}
{"leetcodeId":191,"title":"Number of 1 Bits","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nvar hammingWeight = function(n) {\n    \n};","python":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        pass","typescript":"function hammingWeight(n: number): number {\n\n};"},"testCases":[{"input":"11","expectedOutput":3,"isHidden":false},{"input":"128","expectedOutput":1,"isHidden":false},{"input":"4294967293","expectedOutput":31,"isHidden":false},{"input":"0","expectedOutput":0,"isHidden":true},{"input":"2147483647","expectedOutput":31,"isHidden":true},{"input":"4294967295","expectedOutput":32,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nvar hammingWeight = function(n) {\n    let count = 0;\n    while (n !== 0) {\n        n = n & (n - 1); // This operation removes the rightmost '1' bit\n        count++;\n    }\n    return count;\n};\n"}}}
{"leetcodeId":190,"title":"Reverse Bits","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nvar reverseBits = function(n) {\n    \n};","python":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        pass","typescript":"/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nfunction reverseBits(n: number): number {\n\n};"},"testCases":[{"input":"43261596","expectedOutput":"964176192","isHidden":false},{"input":"4294967293","expectedOutput":"3221225471","isHidden":false},{"input":"0","expectedOutput":"0","isHidden":true},{"input":"1","expectedOutput":"2147483648","isHidden":true},{"input":"2147483648","expectedOutput":"1","isHidden":true},{"input":"4294967295","expectedOutput":"4294967295","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nvar reverseBits = function(n) {\n    let result = 0;\n    for (let i = 0; i < 32; i++) {\n        // Shift result to the left to make space for the next bit\n        result <<= 1;\n        // Add the least significant bit of n to result\n        // (n & 1) extracts the last bit\n        result |= (n & 1);\n        // Shift n to the right to process the next bit\n        n >>>= 1; // Use unsigned right shift\n    }\n    return result >>> 0; // Ensure the result is treated as unsigned 32-bit integer\n};"}}}
{"leetcodeId":187,"title":"Repeated DNA Sequences","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @return {string[]}\n */\nvar findRepeatedDnaSequences = function(s) {\n    \n};","python":"def findRepeatedDnaSequences(s: str) -> list[str]:\n    pass","typescript":"/**\n * @param {string} s\n * @return {string[]}\n */\nfunction findRepeatedDnaSequences(s: string): string[] {\n\n};"},"testCases":[{"input":"\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"","expectedOutput":["AAAAACCCCC","CCCCCAAAAA"],"isHidden":false},{"input":"\"AAAAAAAAAAAAA\"","expectedOutput":["AAAAAAAAAA"],"isHidden":false},{"input":"\"AAAAAAAAAA\"","expectedOutput":[],"isHidden":true},{"input":"\"AGAGAGAGAGAGAGAGAGAG\"","expectedOutput":["AGAGAGAGAG"],"isHidden":true},{"input":"\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTTCCCCC\"","expectedOutput":["AAAAACCCCC","CCCCCAAAAA"],"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @return {string[]}\n */\nvar findRepeatedDnaSequences = function(s) {\n    const seen = new Set();\n    const repeated = new Set();\n    const L = 10;\n\n    if (s.length < L) {\n        return [];\n    }\n\n    for (let i = 0; i <= s.length - L; i++) {\n        const sequence = s.substring(i, i + L);\n        if (seen.has(sequence)) {\n            repeated.add(sequence);\n        } else {\n            seen.add(sequence);\n        }\n    }\n\n    return Array.from(repeated);\n};"}}}
{"leetcodeId":179,"title":"Largest Number","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function(nums) {\n\n};\n","python":"from typing import List\n\ndef largest_number(nums: List[int]) -> str:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @return {string}\n */\nfunction largestNumber(nums: number[]): string {\n\n};\n"},"testCases":[{"input":"[10,2]","expectedOutput":"210","isHidden":false},{"input":"[3,30,34,5,9]","expectedOutput":"9534330","isHidden":false},{"input":"[1]","expectedOutput":"1","isHidden":false},{"input":"[10]","expectedOutput":"10","isHidden":false},{"input":"[0,0]","expectedOutput":"0","isHidden":true},{"input":"[0]","expectedOutput":"0","isHidden":true},{"input":"[121,12]","expectedOutput":"12121","isHidden":true},{"input":"[8,89]","expectedOutput":"898","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function(nums) {\n    if (nums.every(num => num === 0)) {\n        return \"0\";\n    }\n\n    nums.sort((a, b) => {\n        const s1 = String(a);\n        const s2 = String(b);\n        // Compare s2 + s1 with s1 + s2\n        // If s2 + s1 is greater, then b should come before a\n        // This means b - a is positive, so b is sorted before a\n        return (s2 + s1) - (s1 + s2);\n    });\n\n    return nums.join('');\n};\n"}}}
{"leetcodeId":189,"title":"Rotate Array","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function(nums, k) {\n\n};","python":"def rotate(nums: list[int], k: int) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    pass","typescript":"/**\n * @param nums {number[]}\n * @param k {number}\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nfunction rotate(nums: number[], k: number): void {\n\n};"},"testCases":[{"input":"[1,2,3,4,5,6,7]\n3","expectedOutput":"[5,6,7,1,2,3,4]","isHidden":false},{"input":"[-1,-100,3,99]\n2","expectedOutput":"[3,99,-1,-100]","isHidden":false},{"input":"[1]\n0","expectedOutput":"[1]","isHidden":true},{"input":"[1,2]\n3","expectedOutput":"[2,1]","isHidden":true},{"input":"[1,2,3,4,5,6,7,8,9,10]\n10","expectedOutput":"[1,2,3,4,5,6,7,8,9,10]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function(nums, k) {\n    const n = nums.length;\n    k = k % n;\n\n    if (k === 0) {\n        return;\n    }\n\n    // Helper function to reverse a portion of the array\n    const reverse = (arr, start, end) => {\n        while (start < end) {\n            [arr[start], arr[end]] = [arr[end], arr[start]];\n            start++;\n            end--;\n        }\n    };\n\n    // Reverse the entire array\n    reverse(nums, 0, n - 1);\n    // Reverse the first k elements\n    reverse(nums, 0, k - 1);\n    // Reverse the remaining n-k elements\n    reverse(nums, k, n - 1);\n};"}}}
{"leetcodeId":194,"title":"Transpose File","codingData":{"starterCode":{"javascript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nvar transposeFile = function(fileContent) {\n    // Your code here\n};\n","python":"def transpose_file(file_content: str) -> str:\n    # Your code here\n    pass\n","typescript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nfunction transposeFile(fileContent: string): string {\n    // Your code here\n}\n"},"testCases":[{"input":"name age\nalice 21\nryan 30","expectedOutput":"name alice ryan\nage 21 30","isHidden":false},{"input":"col1 col2 col3\na b c\nd e f","expectedOutput":"col1 a d\ncol2 b e\ncol3 c f","isHidden":false},{"input":"single","expectedOutput":"single","isHidden":true},{"input":"a b c d e\n1 2 3 4 5","expectedOutput":"a 1\nb 2\nc 3\nd 4\ne 5","isHidden":true},{"input":"header\nvalue","expectedOutput":"header value","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nvar transposeFile = function(fileContent) {\n    if (!fileContent) {\n        return \"\";\n    }\n\n    const lines = fileContent.split('\\n');\n    if (lines.length === 0) {\n        return \"\";\n    }\n\n    const rows = lines.map(line => line.split(' '));\n\n    if (rows.length === 0 || rows[0].length === 0) {\n        return \"\";\n    }\n\n    const numRows = rows.length;\n    const numCols = rows[0].length;\n\n    const transposedRows = [];\n    for (let j = 0; j < numCols; j++) {\n        const newRow = [];\n        for (let i = 0; i < numRows; i++) {\n            // Handle cases where a row might be shorter than expected (though problem states same number of columns)\n            if (rows[i] && rows[i][j] !== undefined) {\n                newRow.push(rows[i][j]);\n            } else {\n                // If a row is unexpectedly short, push an empty string or handle as error\n                // Based on problem, this path should not be hit if 'each row has the same number of columns'\n                newRow.push(''); \n            }\n        }\n        transposedRows.push(newRow);\n    }\n\n    return transposedRows.map(row => row.join(' ')).join('\\n');\n};\n"}}}
{"leetcodeId":186,"title":"Reverse Words in a String II","codingData":{"starterCode":{"javascript":"/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseWords = function(s) {\n\n};","python":"from typing import List\n\ndef reverse_words(s: List[str]) -> None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    pass","typescript":"/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nfunction reverseWords(s: string[]): void {\n\n};"},"testCases":[{"input":"[\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"]","expectedOutput":"[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]","isHidden":false},{"input":"[\"a\"]","expectedOutput":"[\"a\"]","isHidden":false},{"input":"[\"o\",\"n\",\"e\",\" \",\"t\",\"w\",\"o\",\" \",\"t\",\"h\",\"r\",\"e\",\"e\"]","expectedOutput":"[\"t\",\"h\",\"r\",\"e\",\"e\",\" \",\"t\",\"w\",\"o\",\" \",\"o\",\"n\",\"e\"]","isHidden":true},{"input":"[\"h\",\"e\",\"l\",\"l\",\"o\"]","expectedOutput":"[\"h\",\"e\",\"l\",\"l\",\"o\"]","isHidden":true},{"input":"[\"a\",\" \",\"b\"]","expectedOutput":"[\"b\",\" \",\"a\"]","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseWords = function(s) {\n    const reverse = (arr, left, right) => {\n        while (left < right) {\n            [arr[left], arr[right]] = [arr[right], arr[left]];\n            left++;\n            right--;\n        }\n    };\n\n    // 1. Reverse the entire string\n    reverse(s, 0, s.length - 1);\n\n    // 2. Reverse each word\n    let start = 0;\n    for (let i = 0; i <= s.length; i++) {\n        if (i === s.length || s[i] === ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n};"}}}
{"leetcodeId":188,"title":"Best Time to Buy and Sell Stock IV","codingData":{"starterCode":{"javascript":"/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(k, prices) {\n    \n};","python":"def max_profit(k: int, prices: list[int]) -> int:\n    pass","typescript":"/**\n * @param k\n * @param prices\n */\nfunction maxProfit(k: number, prices: number[]): number {\n\n};"},"testCases":[{"input":"2\n[2,4,1]","expectedOutput":2,"isHidden":false},{"input":"2\n[3,2,6,5,0,3]","expectedOutput":7,"isHidden":false},{"input":"0\n[1,2,3,4,5]","expectedOutput":0,"isHidden":true},{"input":"1\n[7,6,4,3,1]","expectedOutput":0,"isHidden":true},{"input":"3\n[1,2,3,4,5,6,7,8,9,10]","expectedOutput":9,"isHidden":true},{"input":"100\n[]","expectedOutput":0,"isHidden":true},{"input":"2\n[1,2,4,2,5,7,2,4,9,0,9]","expectedOutput":17,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(k, prices) {\n    const n = prices.length;\n\n    if (n === 0 || k === 0) {\n        return 0;\n    }\n\n    // If k is very large, it's equivalent to Best Time to Buy and Sell Stock II\n    // where we can make as many transactions as we want.\n    if (k >= n / 2) {\n        let maxProfitUnlimited = 0;\n        for (let i = 1; i < n; i++) {\n            if (prices[i] > prices[i - 1]) {\n                maxProfitUnlimited += prices[i] - prices[i - 1];\n            }\n        }\n        return maxProfitUnlimited;\n    }\n\n    // dp[i][j] represents the maximum profit after j transactions on day i\n    // We need to track two states for each transaction: buying and selling\n    // dp[t][0] = max profit with t transactions, currently holding a stock\n    // dp[t][1] = max profit with t transactions, currently not holding a stock\n\n    // Initialize dp arrays\n    // buy[t] stores the maximum profit after t transactions, ending with a buy (or holding a stock)\n    // sell[t] stores the maximum profit after t transactions, ending with a sell (or not holding a stock)\n    const buy = new Array(k + 1).fill(-Infinity);\n    const sell = new Array(k + 1).fill(0);\n\n    for (let i = 0; i < n; i++) {\n        const price = prices[i];\n        for (let j = 1; j <= k; j++) {\n            // To reach buy[j] on current day:\n            // 1. Stay in buy[j] state from previous day (already holding stock from j transactions)\n            // 2. Buy stock on current day, completing j-1 transactions and then buying\n            //    (sell[j-1] - price)\n            buy[j] = Math.max(buy[j], sell[j - 1] - price);\n\n            // To reach sell[j] on current day:\n            // 1. Stay in sell[j] state from previous day (already sold stock from j transactions)\n            // 2. Sell stock on current day, completing j transactions\n            //    (buy[j] + price)\n            sell[j] = Math.max(sell[j], buy[j] + price);\n        }\n    }\n\n    // The maximum profit will be in sell[k] (after k transactions, not holding a stock)\n    return sell[k];\n};"}}}
{"leetcodeId":193,"title":"Valid Phone Numbers","codingData":{"starterCode":{"javascript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nvar validPhoneNumbers = function(fileContent) {\n    // This problem is designed for a bash script, not a typical programming language function.\n    // However, if we were to simulate it in JavaScript, we would process the file content line by line.\n    // The bash solution would typically use 'grep -P' or 'sed -r'.\n    // For this function, we'll return a placeholder or an empty string as it's not the intended solution method.\n    return \"\"; \n};","python":"def valid_phone_numbers(file_content: str) -> str:\n    \"\"\"\n    This problem is designed for a bash script, not a typical programming language function.\n    However, if we were to simulate it in Python, we would process the file content line by line.\n    The bash solution would typically use 'grep -P' or 'sed -r'.\n    For this function, we'll return a placeholder or an empty string as it's not the intended solution method.\n    \"\"\"\n    return \"\"","typescript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nfunction validPhoneNumbers(fileContent: string): string {\n    // This problem is designed for a bash script, not a typical programming language function.\n    // However, if we were to simulate it in TypeScript, we would process the file content line by line.\n    // The bash solution would typically use 'grep -P' or 'sed -r'.\n    // For this function, we'll return a placeholder or an empty string as it's not the intended solution method.\n    return \"\";\n}"},"testCases":[{"input":"\"987-123-4567\\n123 456 7890\\n(123) 456-7890\"","expectedOutput":"987-123-4567\\n(123) 456-7890","isHidden":false},{"input":"\"123-456-7890\\n(000) 111-2222\\n+1 123-456-7890\\n123-456-789\\n(123)456-7890\\n(123) 456-7890\"","expectedOutput":"123-456-7890\\n(000) 111-2222\\n(123) 456-7890","isHidden":true},{"input":"\"\\n\\n(555) 555-5555\\n111-222-3333\\nnot-a-phone-number\\n(123) 456-7890\"","expectedOutput":"(555) 555-5555\\n111-222-3333\\n(123) 456-7890","isHidden":true},{"input":"\"123-456-7890\\n(123) 456-7890\\n123-456-7890\\n(123) 456-7890\"","expectedOutput":"123-456-7890\\n(123) 456-7890\\n123-456-7890\\n(123) 456-7890","isHidden":true},{"input":"\"123-456-78900\\n(123) 456-789\\n123-45-6789\\n(123) 456-78901\"","expectedOutput":"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nvar validPhoneNumbers = function(fileContent) {\n    // This problem is specifically designed for a bash script using `grep` or `sed`.\n    // The prompt asks for a one-liner bash script.\n    // Implementing this in JavaScript would be a workaround for a different problem type.\n    // However, if we were to simulate the logic:\n    const lines = fileContent.split('\\n');\n    const validNumbers = [];\n    const regex1 = /^\\d{3}-\\d{3}-\\d{4}$/;\n    const regex2 = /^\\(\\d{3}\\) \\d{3}-\\d{4}$/;\n\n    for (const line of lines) {\n        if (regex1.test(line) || regex2.test(line)) {\n            validNumbers.push(line);\n        }\n    }\n    return validNumbers.join('\\n');\n};"}}}
{"leetcodeId":192,"title":"Word Frequency","codingData":{"starterCode":{"javascript":"/**\n * @param {string} wordsTxtContent\n * @return {string}\n */\nvar wordFrequency = function(wordsTxtContent) {\n    // This problem is designed for a bash script, not JavaScript.\n    // However, if you were to implement similar logic in JavaScript,\n    // you would parse the string, count words, and format the output.\n    // Example: wordsTxtContent = \"the day is sunny the the\\nthe sunny is is\"\n    \n    // Split the content into words, filter out empty strings, and convert to lowercase.\n    const words = wordsTxtContent.toLowerCase().split(/\\s+/).filter(word => word.length > 0);\n\n    // Count word frequencies\n    const wordCounts = {};\n    for (const word of words) {\n        wordCounts[word] = (wordCounts[word] || 0) + 1;\n    }\n\n    // Sort by frequency in descending order\n    const sortedWords = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);\n\n    // Format the output\n    let result = '';\n    for (const [word, count] of sortedWords) {\n        result += `${word} ${count}\\n`;\n    }\n    return result.trim();\n};","python":"def word_frequency(words_txt_content: str) -> str:\n    \"\"\"\n    Calculates the frequency of each word in a given text content.\n    This problem is designed for a bash script, not Python.\n    However, if you were to implement similar logic in Python,\n    you would parse the string, count words, and format the output.\n    Example: words_txt_content = \"the day is sunny the the\\nthe sunny is is\"\n    \"\"\"\n    import re\n    from collections import Counter\n\n    # Split the content into words, filter out empty strings, and convert to lowercase.\n    words = re.findall(r'\\b[a-z]+\\b', words_txt_content.lower())\n\n    # Count word frequencies\n    word_counts = Counter(words)\n\n    # Sort by frequency in descending order\n    sorted_words = sorted(word_counts.items(), key=lambda item: item[1], reverse=True)\n\n    # Format the output\n    result = []\n    for word, count in sorted_words:\n        result.append(f\"{word} {count}\")\n    return \"\\n\".join(result)","typescript":"/**\n * @param {string} wordsTxtContent\n * @return {string}\n */\nfunction wordFrequency(wordsTxtContent: string): string {\n    // This problem is designed for a bash script, not TypeScript.\n    // However, if you were to implement similar logic in TypeScript,\n    // you would parse the string, count words, and format the output.\n    // Example: wordsTxtContent = \"the day is sunny the the\\nthe sunny is is\"\n\n    // Split the content into words, filter out empty strings, and convert to lowercase.\n    const words = wordsTxtContent.toLowerCase().split(/\\s+/).filter(word => word.length > 0);\n\n    // Count word frequencies\n    const wordCounts: { [key: string]: number } = {};\n    for (const word of words) {\n        wordCounts[word] = (wordCounts[word] || 0) + 1;\n    }\n\n    // Sort by frequency in descending order\n    const sortedWords = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);\n\n    // Format the output\n    let result = '';\n    for (const [word, count] of sortedWords) {\n        result += `${word} ${count}\\n`;\n    }\n    return result.trim();\n}"},"testCases":[{"input":"\"the day is sunny the the\\nthe sunny is is\"","expectedOutput":"the 4\nis 3\nsunny 2\nday 1","isHidden":false},{"input":"\"hello world hello\"","expectedOutput":"hello 2\nworld 1","isHidden":true},{"input":"\"a b c a b a\"","expectedOutput":"a 3\nb 2\nc 1","isHidden":true},{"input":"\"singleword\"","expectedOutput":"singleword 1","isHidden":true},{"input":"\"  multiple   spaces   between   words  \"","expectedOutput":"spaces 1\nmultiple 1\nbetween 1\nwords 1","isHidden":true},{"input":"\"\"","expectedOutput":"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} wordsTxtContent\n * @return {string}\n */\nvar wordFrequency = function(wordsTxtContent) {\n    const words = wordsTxtContent.toLowerCase().split(/\\s+/).filter(word => word.length > 0);\n\n    const wordCounts = {};\n    for (const word of words) {\n        wordCounts[word] = (wordCounts[word] || 0) + 1;\n    }\n\n    const sortedWords = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);\n\n    let result = '';\n    for (const [word, count] of sortedWords) {\n        result += `${word} ${count}\\n`;\n    }\n    return result.trim();\n};"}}}
{"leetcodeId":202,"title":"Happy Number","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {boolean}\n */\nvar isHappy = function(n) {\n    \n};\n","python":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        \n","typescript":"function isHappy(n: number): boolean {\n\n};\n"},"testCases":[{"input":"19","expectedOutput":"true","isHidden":false},{"input":"2","expectedOutput":"false","isHidden":false},{"input":"7","expectedOutput":"true","isHidden":true},{"input":"1","expectedOutput":"true","isHidden":true},{"input":"4","expectedOutput":"false","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {boolean}\n */\nvar isHappy = function(n) {\n    const seen = new Set();\n\n    function getNext(num) {\n        let sum = 0;\n        while (num > 0) {\n            const digit = num % 10;\n            sum += digit * digit;\n            num = Math.floor(num / 10);\n        }\n        return sum;\n    }\n\n    while (n !== 1 && !seen.has(n)) {\n        seen.add(n);\n        n = getNext(n);\n    }\n\n    return n === 1;\n};\n"}}}
{"leetcodeId":204,"title":"Count Primes","codingData":{"starterCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar countPrimes = function(n) {\n    \n};\n","python":"def countPrimes(n: int) -> int:\n    pass\n","typescript":"function countPrimes(n: number): number {\n\n};\n"},"testCases":[{"input":"10","expectedOutput":4,"isHidden":false},{"input":"0","expectedOutput":0,"isHidden":false},{"input":"1","expectedOutput":0,"isHidden":false},{"input":"2","expectedOutput":0,"isHidden":true},{"input":"3","expectedOutput":1,"isHidden":true},{"input":"100","expectedOutput":25,"isHidden":true},{"input":"499979","expectedOutput":41537,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number} n\n * @return {number}\n */\nvar countPrimes = function(n) {\n    if (n <= 2) {\n        return 0;\n    }\n\n    const isPrime = new Array(n).fill(true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n\n    for (let p = 2; p * p < n; p++) {\n        if (isPrime[p]) {\n            for (let multiple = p * p; multiple < n; multiple += p) {\n                isPrime[multiple] = false;\n            }\n        }\n    }\n\n    let count = 0;\n    for (let i = 2; i < n; i++) {\n        if (isPrime[i]) {\n            count++;\n        }\n    }\n\n    return count;\n};\n"}}}
{"leetcodeId":205,"title":"Isomorphic Strings","codingData":{"starterCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isIsomorphic = function(s, t) {\n    \n};","python":"def isIsomorphic(s: str, t: str) -> bool:\n    pass","typescript":"/**\n * @param s {string}\n * @param t {string}\n * @return {boolean}\n */\nfunction isIsomorphic(s: string, t: string): boolean {\n\n};"},"testCases":[{"input":"\"egg\"\n\"add\"","expectedOutput":true,"isHidden":false},{"input":"\"foo\"\n\"bar\"","expectedOutput":false,"isHidden":false},{"input":"\"paper\"\n\"title\"","expectedOutput":true,"isHidden":false},{"input":"\"badc\"\n\"baba\"","expectedOutput":false,"isHidden":true},{"input":"\"ab\"\n\"aa\"","expectedOutput":false,"isHidden":true},{"input":"\"a\"\n\"a\"","expectedOutput":true,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isIsomorphic = function(s, t) {\n    if (s.length !== t.length) {\n        return false;\n    }\n\n    const sMap = new Map();\n    const tMap = new Map();\n\n    for (let i = 0; i < s.length; i++) {\n        const charS = s[i];\n        const charT = t[i];\n\n        if (sMap.has(charS)) {\n            if (sMap.get(charS) !== charT) {\n                return false;\n            }\n        } else {\n            sMap.set(charS, charT);\n        }\n\n        if (tMap.has(charT)) {\n            if (tMap.get(charT) !== charS) {\n                return false;\n            }\n        } else {\n            tMap.set(charT, charS);\n        }\n    }\n\n    return true;\n};"}}}
{"leetcodeId":198,"title":"House Robber","codingData":{"starterCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};\n","python":"def rob(nums: list[int]) -> int:\n    pass\n","typescript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction rob(nums: number[]): number {\n\n};\n"},"testCases":[{"input":"[1,2,3,1]","expectedOutput":4,"isHidden":false},{"input":"[2,7,9,3,1]","expectedOutput":12,"isHidden":false},{"input":"[0]","expectedOutput":0,"isHidden":true},{"input":"[1]","expectedOutput":1,"isHidden":true},{"input":"[1,2]","expectedOutput":2,"isHidden":true},{"input":"[400,0,0,0,400]","expectedOutput":800,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n    if (nums.length === 1) {\n        return nums[0];\n    }\n\n    // dp[i] represents the maximum amount of money that can be robbed up to house i\n    // without robbing adjacent houses.\n    // dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    let dp = new Array(nums.length);\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n\n    for (let i = 2; i < nums.length; i++) {\n        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n    }\n\n    return dp[nums.length - 1];\n};\n"}}}
{"leetcodeId":195,"title":"Tenth Line","codingData":{"starterCode":{"javascript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nvar tenthLine = function(fileContent) {\n    // Your code here\n};\n","python":"def tenth_line(file_content: str) -> str:\n    # Your code here\n    pass\n","typescript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nfunction tenthLine(fileContent: string): string {\n    // Your code here\n}\n"},"testCases":[{"input":"\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\\nLine 10\"","expectedOutput":"Line 10","isHidden":false},{"input":"\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\"","expectedOutput":"","isHidden":true},{"input":"\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\\nLine 10\\nLine 11\\nLine 12\"","expectedOutput":"Line 10","isHidden":true},{"input":"\"\"","expectedOutput":"","isHidden":true},{"input":"\"Only one line\"","expectedOutput":"","isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {string} fileContent\n * @return {string}\n */\nvar tenthLine = function(fileContent) {\n    const lines = fileContent.split('\\n');\n    if (lines.length >= 10) {\n        return lines[9];\n    } else {\n        return \"\";\n    }\n};\n"}}}
{"leetcodeId":206,"title":"Reverse Linked List","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction reverseList(head) {\n  // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode | null} head\n * @return {ListNode | null}\n */\nfunction reverseList(head: ListNode | null): ListNode | null {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","expectedOutput":"{\"val\":5,\"next\":{\"val\":4,\"next\":{\"val\":3,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":null}}}}}","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":null}}","expectedOutput":"{\"val\":2,\"next\":{\"val\":1,\"next\":null}}","isHidden":false},{"input":"null","expectedOutput":"null","isHidden":false},{"input":"{\"val\":1,\"next\":null}","expectedOutput":"{\"val\":1,\"next\":null}","isHidden":true},{"input":"{\"val\":-5000,\"next\":{\"val\":0,\"next\":{\"val\":5000,\"next\":null}}}","expectedOutput":"{\"val\":5000,\"next\":{\"val\":0,\"next\":{\"val\":-5000,\"next\":null}}}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction reverseList(head) {\n  let prev = null;\n  let current = head;\n\n  while (current !== null) {\n    let nextTemp = current.next; // Save next node\n    current.next = prev;        // Reverse current node's pointer\n    prev = current;             // Move prev to current node\n    current = nextTemp;         // Move current to next node\n  }\n\n  return prev;\n}"}}}
{"leetcodeId":200,"title":"Number of Islands","codingData":{"starterCode":{"javascript":"/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n\n};","python":"class Solution:\n    def numIslands(self, grid: list[list[str]]) -> int:\n        pass","typescript":"function numIslands(grid: string[][]): number {\n\n};"},"testCases":[{"input":"[\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]","expectedOutput":1,"isHidden":false},{"input":"[\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]","expectedOutput":3,"isHidden":false},{"input":"[\n  [\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\"]\n]","expectedOutput":0,"isHidden":true},{"input":"[\n  [\"1\"]\n]","expectedOutput":1,"isHidden":true},{"input":"[\n  [\"1\",\"0\",\"1\"],\n  [\"0\",\"1\",\"0\"],\n  [\"1\",\"0\",\"1\"]\n]","expectedOutput":5,"isHidden":true}],"solutionCode":{"javascript":"/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n    if (!grid || grid.length === 0) {\n        return 0;\n    }\n\n    const m = grid.length;\n    const n = grid[0].length;\n    let numIslands = 0;\n\n    function dfs(row, col) {\n        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] === '0') {\n            return;\n        }\n\n        grid[row][col] = '0'; // Mark as visited\n\n        dfs(row + 1, col);\n        dfs(row - 1, col);\n        dfs(row, col + 1);\n        dfs(row, col - 1);\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === '1') {\n                numIslands++;\n                dfs(i, j);\n            }\n        }\n    }\n\n    return numIslands;\n};"}}}
{"leetcodeId":203,"title":"Remove Linked List Elements","codingData":{"starterCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nfunction removeElements(head, val) {\n    // Your code here\n}","python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\ndef removeElements(head: ListNode, val: int) -> ListNode:\n    # Your code here\n","typescript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nfunction removeElements(head: ListNode | null, val: number): ListNode | null {\n    // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":6,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":{\"val\":6,\"next\":null}}}}}}}\n6","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":{\"val\":4,\"next\":{\"val\":5,\"next\":null}}}}}","isHidden":false},{"input":"null\n1","expectedOutput":"null","isHidden":false},{"input":"{\"val\":7,\"next\":{\"val\":7,\"next\":{\"val\":7,\"next\":{\"val\":7,\"next\":null}}}}\n7","expectedOutput":"null","isHidden":false},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}\n4","expectedOutput":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":3,\"next\":null}}}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":1,\"next\":{\"val\":2,\"next\":null}}}\n1","expectedOutput":"{\"val\":2,\"next\":null}","isHidden":true},{"input":"{\"val\":1,\"next\":{\"val\":2,\"next\":{\"val\":1,\"next\":null}}}\n1","expectedOutput":"{\"val\":2,\"next\":null}","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nfunction removeElements(head, val) {\n    // Create a dummy node that points to the head of the list.\n    // This simplifies handling cases where the head itself needs to be removed.\n    const dummyHead = new ListNode(0);\n    dummyHead.next = head;\n\n    let current = dummyHead;\n\n    // Iterate through the list\n    while (current.next !== null) {\n        // If the next node's value is the one we want to remove\n        if (current.next.val === val) {\n            // Skip the next node by pointing current.next to current.next.next\n            current.next = current.next.next;\n        } else {\n            // Otherwise, move to the next node\n            current = current.next;\n        }\n    }\n\n    // The actual head of the modified list is dummyHead.next\n    return dummyHead.next;\n}"}}}
{"leetcodeId":199,"title":"Binary Tree Right Side View","codingData":{"starterCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nfunction rightSideView(root) {\n  // Your code here\n}","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import Optional, List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef right_side_view(root: Optional[TreeNode]) -> List[int]:\n    # Your code here\n","typescript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * @param {TreeNode | null} root\n * @return {number[]}\n */\nfunction rightSideView(root: TreeNode | null): number[] {\n  // Your code here\n}"},"testCases":[{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":4,\"left\":null,\"right\":null}}}","expectedOutput":"[1,3,4]","isHidden":false},{"input":"{\"val\":1,\"left\":null,\"right\":{\"val\":3,\"left\":null,\"right\":null}}","expectedOutput":"[1,3]","isHidden":false},{"input":"null","expectedOutput":"[]","isHidden":false},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":null,\"right\":null},\"right\":null}","expectedOutput":"[1,2]","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":null}}}","expectedOutput":"[1,3,5]","isHidden":true},{"input":"{\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":null}","expectedOutput":"[1,2,3,4]","isHidden":true}],"solutionCode":{"javascript":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nfunction rightSideView(root) {\n  if (!root) {\n    return [];\n  }\n\n  const result = [];\n  const queue = [root];\n\n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    // The last node in the current level is the rightmost node\n    result.push(queue[levelSize - 1].val);\n\n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n\n      if (node.left) {\n        queue.push(node.left);\n      }\n      if (node.right) {\n        queue.push(node.right);\n      }\n    }\n  }\n\n  return result;\n}"}}}
